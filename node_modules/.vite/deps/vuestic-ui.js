import {
  Fragment,
  Teleport,
  Transition,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  h,
  init_vue_runtime_esm_bundler,
  inject,
  mergeProps,
  nextTick,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUnmounted,
  onUpdated,
  openBlock,
  provide,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  toHandlers,
  useCssVars,
  vModelDynamic,
  vModelText,
  vShow,
  watch,
  watchEffect,
  watchPostEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-7SSID6R3.js";
import {
  isRef,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  reactive,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toRef,
  toRefs,
  unref
} from "./chunk-N4IOAUZO.js";
import "./chunk-QOVRSCHT.js";

// node_modules/vuestic-ui/dist/es/_commonjsHelpers.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};

// node_modules/vuestic-ui/dist/es/vendor.js
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear;
var listCacheDelete = _listCacheDelete;
var listCacheGet = _listCacheGet;
var listCacheHas = _listCacheHas;
var listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$6 = root$8.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$9(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$9;
function isObject$c(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$c;
var baseGetTag$8 = _baseGetTag;
var isObject$b = isObject_1;
var asyncTag = "[object AsyncFunction]";
var funcTag$2 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$b(value)) {
    return false;
  }
  var tag = baseGetTag$8(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1;
var isMasked = _isMasked;
var isObject$a = isObject_1;
var toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$b = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$a(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative;
var getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var root$6 = _root;
var Map$3 = getNative$6(root$6, "Map");
var _Map = Map$3;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear;
var hashDelete = _hashDelete;
var hashGet = _hashGet;
var hashHas = _hashHas;
var hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash;
var ListCache$2 = _ListCache;
var Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear;
var mapCacheDelete = _mapCacheDelete;
var mapCacheGet = _mapCacheGet;
var mapCacheHas = _mapCacheHas;
var mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache;
var Map$1 = _Map;
var MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache;
var stackClear = _stackClear;
var stackDelete = _stackDelete;
var stackGet = _stackGet;
var stackHas = _stackHas;
var stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
function arrayEach$1(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue;
var eq$2 = eq_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq$2(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue;
var baseAssignValue$1 = _baseAssignValue;
function copyObject$6(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$6;
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$b(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
var baseGetTag$7 = _baseGetTag;
var isObjectLike$a = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$a(value) && baseGetTag$7(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments;
var isObjectLike$9 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$9(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isArray$a = Array.isArray;
var isArray_1 = isArray$a;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$4;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$6 = _baseGetTag;
var isLength$2 = isLength_1;
var isObjectLike$8 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$2 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag$1 = "[object Function]";
var mapTag$4 = "[object Map]";
var numberTag$3 = "[object Number]";
var objectTag$3 = "[object Object]";
var regexpTag$2 = "[object RegExp]";
var setTag$4 = "[object Set]";
var stringTag$3 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$8(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$6(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray;
var baseUnary$3 = _baseUnary;
var nodeUtil$3 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$3 && nodeUtil$3.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes;
var isArguments$3 = isArguments_1;
var isArray$9 = isArray_1;
var isBuffer$2 = isBuffer$3.exports;
var isIndex$3 = _isIndex;
var isTypedArray$1 = isTypedArray_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$9(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$5 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype;
var nativeKeys = _nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1;
var isLength$1 = isLength_1;
function isArrayLike$4(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$4;
var arrayLikeKeys$1 = _arrayLikeKeys;
var baseKeys = _baseKeys;
var isArrayLike$3 = isArrayLike_1;
function keys$3(object) {
  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$3;
var copyObject$5 = _copyObject;
var keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$5(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$9 = isObject_1;
var isPrototype$1 = _isPrototype;
var nativeKeysIn = _nativeKeysIn;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$9(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys;
var baseKeysIn = _baseKeysIn;
var isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
  return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$4 = _copyObject;
var keysIn$4 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$4(source, keysIn$4(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
function copyArray$2(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$2;
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter;
var stubArray$1 = stubArray_1;
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$3 = _copyObject;
var getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$3(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$3(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var arrayPush$2 = _arrayPush;
var getPrototype$2 = _getPrototype;
var getSymbols$1 = _getSymbols;
var stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$1(object));
    object = getPrototype$2(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$2 = _copyObject;
var getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$2(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush$1 = _arrayPush;
var isArray$8 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$8(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys;
var getSymbols = _getSymbols;
var keys$1 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys;
var getSymbolsIn = _getSymbolsIn;
var keysIn$3 = keysIn_1;
function getAllKeysIn$2(object) {
  return baseGetAllKeys(object, keysIn$3, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$2;
var getNative$3 = _getNative;
var root$5 = _root;
var DataView$1 = getNative$3(root$5, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative;
var root$4 = _root;
var Promise$2 = getNative$2(root$4, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative;
var root$3 = _root;
var Set$1 = getNative$1(root$3, "Set");
var _Set = Set$1;
var getNative = _getNative;
var root$2 = _root;
var WeakMap$1 = getNative(root$2, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView = _DataView;
var Map = _Map;
var Promise$1 = _Promise;
var Set2 = _Set;
var WeakMap = _WeakMap;
var baseGetTag$5 = _baseGetTag;
var toSource = _toSource;
var mapTag$3 = "[object Map]";
var objectTag$2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$3 = "[object Set]";
var weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set2);
var weakMapCtorString = toSource(WeakMap);
var getTag$3 = baseGetTag$5;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag$3(new Map()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set2 && getTag$3(new Set2()) != setTag$3 || WeakMap && getTag$3(new WeakMap()) != weakMapTag$1) {
  getTag$3 = function(value) {
    var result = baseGetTag$5(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$3;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var root$1 = _root;
var Uint8Array$1 = root$1.Uint8Array;
var _Uint8Array = Uint8Array$1;
var Uint8Array = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
var cloneArrayBuffer = _cloneArrayBuffer;
var cloneDataView = _cloneDataView;
var cloneRegExp = _cloneRegExp;
var cloneSymbol = _cloneSymbol;
var cloneTypedArray$1 = _cloneTypedArray;
var boolTag$1 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var mapTag$2 = "[object Map]";
var numberTag$2 = "[object Number]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$2 = "[object String]";
var symbolTag$2 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray$1(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$8 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$8(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate;
var getPrototype$1 = _getPrototype;
var isPrototype = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$2;
var getTag$2 = _getTag;
var isObjectLike$7 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$7(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap;
var baseUnary$2 = _baseUnary;
var nodeUtil$2 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag;
var isObjectLike$6 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$6(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet;
var baseUnary$1 = _baseUnary;
var nodeUtil$1 = _nodeUtil.exports;
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$1 = _Stack;
var arrayEach = _arrayEach;
var assignValue$1 = _assignValue;
var baseAssign = _baseAssign;
var baseAssignIn = _baseAssignIn;
var cloneBuffer$1 = _cloneBuffer.exports;
var copyArray$1 = _copyArray;
var copySymbols = _copySymbols;
var copySymbolsIn = _copySymbolsIn;
var getAllKeys = _getAllKeys;
var getAllKeysIn$1 = _getAllKeysIn;
var getTag = _getTag;
var initCloneArray = _initCloneArray;
var initCloneByTag = _initCloneByTag;
var initCloneObject$1 = _initCloneObject;
var isArray$7 = isArray_1;
var isBuffer$1 = isBuffer$3.exports;
var isMap = isMap_1;
var isObject$7 = isObject_1;
var isSet = isSet_1;
var keys = keys_1;
var keysIn$2 = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1;
var CLONE_FLAT_FLAG$1 = 2;
var CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag = "[object Error]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var mapTag = "[object Map]";
var numberTag$1 = "[object Number]";
var objectTag$1 = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$2(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$7(value)) {
    return value;
  }
  var isArr = isArray$7(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer$1(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject$1(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$1());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$1 : getAllKeys : isFlat ? keysIn$2 : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$2;
var baseClone$1 = _baseClone;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep_1 = cloneDeep;
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
function arrayMap$2(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var baseGetTag$4 = _baseGetTag;
var isObjectLike$5 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$5(value) && baseGetTag$4(value) == symbolTag;
}
var isSymbol_1 = isSymbol$4;
var Symbol$2 = _Symbol;
var arrayMap$1 = _arrayMap;
var isArray$6 = isArray_1;
var isSymbol$3 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$6(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$6(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$6;
var deburrLetter = _deburrLetter;
var toString$5 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$3 = "\\u0300-\\u036f";
var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsCombo$2 = "[" + rsComboRange$3 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr$1(string) {
  string = toString$5(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange$2 = "\\ud800-\\udfff";
var rsComboMarksRange$2 = "\\u0300-\\u036f";
var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['\u2019]";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo$1 = "[" + rsComboRange$2 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")";
var rsNonAstral$1 = "[^" + rsAstralRange$2 + "]";
var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ$2 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod$1 = rsModifier$1 + "?";
var rsOptVar$1 = "[" + rsVarRange$2 + "]?";
var rsOptJoin$1 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
var rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords;
var hasUnicodeWord = _hasUnicodeWord;
var toString$4 = toString_1;
var unicodeWords = _unicodeWords;
function words$1(string, pattern, guard) {
  string = toString$4(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce;
var deburr = deburr_1;
var words = words_1;
var rsApos = "['\u2019]";
var reApos = RegExp(rsApos, "g");
function createCompounder$3(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder$3;
var createCompounder$2 = _createCompounder;
var kebabCase = createCompounder$2(function(result, word, index) {
  return result + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
function baseSlice$2(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseSlice$1 = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice$1(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray;
var hasUnicode$1 = _hasUnicode;
var unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice;
var hasUnicode = _hasUnicode;
var stringToArray = _stringToArray;
var toString$3 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString$3(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$2 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$2;
var toString$2 = toString_1;
var upperFirst$1 = upperFirst_1;
function capitalize$1(string) {
  return upperFirst$1(toString$2(string).toLowerCase());
}
var capitalize_1 = capitalize$1;
var capitalize = capitalize_1;
var createCompounder$1 = _createCompounder;
var camelCase = createCompounder$1(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});
var camelCase_1 = camelCase;
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim;
var isObject$6 = isObject_1;
var isSymbol$2 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN;
  }
  if (isObject$6(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$6(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var isObject$5 = isObject_1;
var now = now_1;
var toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$1 = Math.max;
var nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$5(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var isArray$5 = isArray_1;
var isSymbol$1 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$5(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
var isArray$4 = isArray_1;
var isKey = _isKey;
var stringToPath = _stringToPath;
var toString$1 = toString_1;
function castPath$6(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString$1(value));
}
var _castPath = castPath$6;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$5 = _castPath;
var toKey$3 = _toKey;
function baseGet$2(object, path) {
  path = castPath$5(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$3(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$2;
var assignValue = _assignValue;
var castPath$4 = _castPath;
var isIndex$2 = _isIndex;
var isObject$4 = isObject_1;
var toKey$2 = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$4(object)) {
    return object;
  }
  path = castPath$4(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey$2(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$4(objValue) ? objValue : isIndex$2(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet$1 = _baseGet;
var baseSet = _baseSet;
var castPath$3 = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet$1(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath$3(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath;
var isArguments$2 = isArguments_1;
var isArray$3 = isArray_1;
var isIndex$1 = _isIndex;
var isLength = isLength_1;
var toKey$1 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey$1(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$3(object) || isArguments$2(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn;
var hasPath = _hasPath;
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var basePickBy = _basePickBy;
var hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var Symbol$1 = _Symbol;
var isArguments$1 = isArguments_1;
var isArray$2 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$2(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush;
var isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
var constant = constant_1;
var defineProperty = _defineProperty;
var identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString;
var shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var flatten = flatten_1;
var overRest$1 = _overRest;
var setToString$1 = _setToString;
function flatRest$2(func) {
  return setToString$1(overRest$1(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$2;
var basePick = _basePick;
var flatRest$1 = _flatRest;
var pick = flatRest$1(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
var toString = toString_1;
var idCounter = 0;
function uniqueId(prefix2) {
  var id = ++idCounter;
  return toString(prefix2) + id;
}
var uniqueId_1 = uniqueId;
var baseGetTag$3 = _baseGetTag;
var isArray$1 = isArray_1;
var isObjectLike$4 = isObjectLike_1;
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$4(value) && baseGetTag$3(value) == stringTag;
}
var isString_1 = isString;
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
var baseGet = _baseGet;
var baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$1 = _castPath;
var last = last_1;
var parent = _parent;
var toKey = _toKey;
function baseUnset$1(object, path) {
  path = castPath$1(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}
var _baseUnset = baseUnset$1;
var baseGetTag$2 = _baseGetTag;
var getPrototype = _getPrototype;
var isObjectLike$3 = isObjectLike_1;
var objectTag = "[object Object]";
var funcProto = Function.prototype;
var objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$3(value) || baseGetTag$2(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
var isPlainObject$1 = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject$1(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap = _arrayMap;
var baseClone = _baseClone;
var baseUnset = _baseUnset;
var castPath = _castPath;
var copyObject$1 = _copyObject;
var customOmitClone = _customOmitClone;
var flatRest = _flatRest;
var getAllKeysIn = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject$1(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
var baseAssignValue = _baseAssignValue;
var eq$1 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$1(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var isArrayLike$1 = isArrayLike_1;
var isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$2(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var copyObject = _copyObject;
var keysIn$1 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue;
var cloneBuffer = _cloneBuffer.exports;
var cloneTypedArray = _cloneTypedArray;
var copyArray = _copyArray;
var initCloneObject = _initCloneObject;
var isArguments = isArguments_1;
var isArray = isArray_1;
var isArrayLikeObject = isArrayLikeObject_1;
var isBuffer = isBuffer$3.exports;
var isFunction = isFunction_1;
var isObject$3 = isObject_1;
var isPlainObject = isPlainObject_1;
var isTypedArray = isTypedArray_1;
var safeGet$1 = _safeGet;
var toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack = _Stack;
var assignMergeValue = _assignMergeValue;
var baseFor = _baseFor;
var baseMergeDeep = _baseMergeDeep;
var isObject$2 = isObject_1;
var keysIn = keysIn_1;
var safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;
var identity = identity_1;
var overRest = _overRest;
var setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1;
var isArrayLike = isArrayLike_1;
var isIndex = _isIndex;
var isObject$1 = isObject_1;
function isIterateeCall$1(value, index, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest;
var isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge;
var createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
function baseClamp$1(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp$1;
var baseClamp = _baseClamp;
var toNumber = toNumber_1;
function clamp(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp(toNumber(number), lower, upper);
}
var clamp_1 = clamp;
function noop() {
}
var noop_1 = noop;
var debounce = debounce_1;
var isObject = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
var createCompounder = _createCompounder;
var upperFirst = upperFirst_1;
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? " " : "") + upperFirst(word);
});
var startCase_1 = startCase;
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
var baseGetTag$1 = _baseGetTag;
var isObjectLike$1 = isObjectLike_1;
var dateTag = "[object Date]";
function baseIsDate$1(value) {
  return isObjectLike$1(value) && baseGetTag$1(value) == dateTag;
}
var _baseIsDate = baseIsDate$1;
var baseIsDate = _baseIsDate;
var baseUnary = _baseUnary;
var nodeUtil = _nodeUtil.exports;
var nodeIsDate = nodeUtil && nodeUtil.isDate;
var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
var isDate_1 = isDate;
var baseGetTag = _baseGetTag;
var isObjectLike = isObjectLike_1;
var numberTag = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
var isNumber_1 = isNumber;

// node_modules/vuestic-ui/dist/es/src/services/global-config/global-config.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/services/global-config/config-default/index.js
var getComponentsDefaultConfig = () => ({
  VaIcon: {
    sizesConfig: {
      defaultSize: 24,
      sizes: {
        small: 16,
        medium: 24,
        large: 32
      }
    }
  },
  VaRating: {
    sizesConfig: {
      defaultSize: 24,
      sizes: {
        small: 16,
        medium: 24,
        large: 32
      }
    }
  },
  all: {},
  presets: {
    VaButton: {
      default: {
        backgroundOpacity: 1,
        hoverBehavior: "mask",
        hoverOpacity: 0.15,
        pressedBehavior: "mask",
        pressedOpacity: 0.13
      },
      primary: {
        backgroundOpacity: 0.1,
        hoverBehavior: "opacity",
        hoverOpacity: 0.07,
        pressedBehavior: "opacity",
        pressedOpacity: 0.13
      },
      secondary: {
        backgroundOpacity: 0,
        hoverBehavior: "opacity",
        hoverOpacity: 0.07,
        pressedBehavior: "opacity",
        pressedOpacity: 0.13
      },
      plain: {
        plain: true,
        hoverBehavior: "mask",
        hoverOpacity: 0.15,
        pressedBehavior: "mask",
        pressedOpacity: 0.13
      },
      plainOpacity: {
        plain: true,
        textOpacity: 0.6,
        hoverBehavior: "opacity",
        hoverOpacity: 1,
        pressedBehavior: "opacity",
        pressedOpacity: 0.9
      }
    }
  }
});

// node_modules/vuestic-ui/dist/es/src/services/icon-config/presets/fonts.js
var VuesticIconFonts = [
  {
    name: "mi-{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  },
  {
    name: "{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  }
];

// node_modules/vuestic-ui/dist/es/src/services/icon-config/presets/vuestic-aliases.js
var VuesticIconAliases = [
  {
    name: "va-arrow-first",
    to: "mi-first_page"
  },
  {
    name: "va-arrow-last",
    to: "mi-last_page"
  },
  {
    name: "va-arrow-right",
    to: "mi-chevron_right"
  },
  {
    name: "va-arrow-left",
    to: "mi-chevron_left"
  },
  {
    name: "va-arrow-down",
    to: "mi-expand_more"
  },
  {
    name: "va-arrow-up",
    to: "mi-expand_less"
  },
  {
    name: "va-calendar",
    to: "mi-calendar_today"
  },
  {
    name: "va-delete",
    to: "mi-delete_outline"
  },
  {
    name: "va-check",
    to: "mi-check"
  },
  {
    name: "va-check-circle",
    to: "mi-check_circle"
  },
  {
    name: "va-warning",
    to: "mi-warning"
  },
  {
    name: "va-clear",
    to: "mi-highlight_off"
  },
  {
    name: "va-close",
    to: "mi-close"
  },
  {
    name: "va-loading",
    to: "mi-loop"
  }
];

// node_modules/vuestic-ui/dist/es/src/services/icon-config/icon-config-helpers.js
var createIconsConfig = (config) => {
  config.aliases = config.aliases || [];
  config.fonts = config.fonts || [];
  return [
    ...config.aliases,
    ...VuesticIconAliases,
    ...config.fonts,
    ...VuesticIconFonts
  ];
};

// node_modules/vuestic-ui/dist/es/src/services/color-config/color-theme-presets.js
var colorsPresets = {
  light: {
    primary: "#154EC1",
    secondary: "#767C88",
    success: "#3D9209",
    info: "#158DE3",
    danger: "#E42222",
    warning: "#FFD43A",
    backgroundPrimary: "#f6f6f6",
    backgroundSecondary: "#FFFFFF",
    backgroundElement: "#EBF1F4",
    backgroundBorder: "#DEE5F2",
    textPrimary: "#262824",
    textInverted: "#FFFFFF",
    shadow: "rgba(0, 0, 0, 0.12)",
    focus: "#FFFF00"
  },
  dark: {
    primary: "#3472F0",
    secondary: "#767C88",
    success: "#66BE33",
    info: "#3EAAF8",
    danger: "#F34030",
    warning: "#FFD952",
    backgroundPrimary: "#050A10",
    backgroundSecondary: "#1F262F",
    backgroundElement: "#131A22",
    backgroundBorder: "#3D4C58",
    textPrimary: "#F1F1F1",
    textInverted: "#0B121A",
    shadow: "rgba(0, 0, 0, 0.37)",
    focus: "#FF0"
  }
};

// node_modules/vuestic-ui/dist/es/src/services/i18n/defaults.js
var getI18nConfigDefaults = () => ({
  search: "Search",
  noOptions: "Items not found",
  ok: "Ok",
  cancel: "Cancel",
  uploadFile: "Upload file",
  undo: "Undo",
  dropzone: "Drop files here to upload",
  fileDeleted: "File deleted",
  closeAlert: "close alert",
  backToTop: "back to top",
  toggleDropdown: "toggle dropdown",
  carousel: "carousel",
  goPreviousSlide: "go previous slide",
  goNextSlide: "go next slide",
  goSlide: "go slide {index}",
  slideOf: "slide {index} of {length}",
  close: "close",
  openColorPicker: "open color picker",
  colorSelection: "color selection",
  colorName: "color {color}",
  decreaseCounter: "decrease counter",
  increaseCounter: "increase counter",
  selectAllRows: "select all rows",
  sortColumnBy: "sort column by {name}",
  selectRowByIndex: "select row {index}",
  resetDate: "reset date",
  nextPeriod: "next period",
  switchView: "switch view",
  previousPeriod: "previous period",
  removeFile: "remove file",
  reset: "reset",
  pagination: "pagination",
  goToTheFirstPage: "go to the first page",
  goToPreviousPage: "go to the previous page",
  goToSpecificPage: "go to the {page} page",
  goToSpecificPageInput: "enter the page number to go",
  goNextPage: "go next page",
  goLastPage: "go last page",
  currentRating: "current rating {value} of {max}",
  voteRating: "`vote rating {value} of {max}`",
  optionsFilter: "options filter",
  splitPanels: "split panels",
  movePaginationLeft: "move pagination left",
  movePaginationRight: "move pagination right",
  resetTime: "reset time",
  closeToast: "close toast",
  selectedOption: "Selected option",
  noSelectedOption: "Option is not selected",
  breadcrumbs: "breadcrumbs",
  counterValue: "counter value",
  selectedDate: "selected date",
  selectedTime: "selected time",
  progressState: "progress state",
  color: "color"
});

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/index.js
var vaBreakpointSymbol = Symbol("vaBreakpoint");
var defaultThresholds = {
  xs: 0,
  sm: 640,
  md: 1024,
  lg: 1440,
  xl: 1920
};
var getBreakpointDefaultConfig = () => ({
  enabled: true,
  bodyClass: true,
  thresholds: defaultThresholds
});

// node_modules/vuestic-ui/dist/es/src/vuestic-plugin/utils/global-properties.js
var extractGlobalProperties = (app2) => app2.config.globalProperties;
var defineGlobalProperty = (app2, key, v2) => {
  const globalProperties = extractGlobalProperties(app2);
  globalProperties[key] = v2;
};
var getGlobalProperty = (app2, key) => {
  return extractGlobalProperties(app2)[key];
};

// node_modules/vuestic-ui/dist/es/src/services/current-app.js
init_vue_runtime_esm_bundler();
var app;
var setCurrentApp = (instance) => {
  app = instance;
};
var getCurrentApp = () => app;
var inject2 = (key, value) => {
  var _a;
  const app2 = (_a = getCurrentApp()) == null ? void 0 : _a._context.provides[key];
  return app2 || inject(key, value);
};

// node_modules/vuestic-ui/dist/es/src/utils/merge-deep.js
var isObject2 = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
var mergeDeep = (target, source) => {
  if (!isObject2(target) || !isObject2(source)) {
    return source;
  }
  Object.keys(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (isObject2(targetValue) && isObject2(sourceValue)) {
      target[key] = mergeDeep(Object.assign({}, targetValue), sourceValue);
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
};

// node_modules/vuestic-ui/dist/es/src/services/global-config/global-config.js
var GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
var createGlobalConfig = () => {
  const globalConfig = ref({
    colors: {
      variables: colorsPresets.light,
      threshold: 150,
      presets: {
        light: colorsPresets.light,
        dark: colorsPresets.dark
      },
      currentPresetName: "light"
    },
    icons: createIconsConfig({}),
    components: getComponentsDefaultConfig(),
    breakpoint: getBreakpointDefaultConfig(),
    i18n: getI18nConfigDefaults()
  });
  const getGlobalConfig = () => globalConfig.value;
  const setGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = cloneDeep_1(config);
  };
  const mergeGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = mergeDeep(cloneDeep_1(globalConfig.value), config);
  };
  return {
    getGlobalConfig,
    setGlobalConfig,
    mergeGlobalConfig,
    globalConfig
  };
};
function useGlobalConfigSafe() {
  return inject2(GLOBAL_CONFIG);
}
function useGlobalConfig() {
  const injected = inject2(GLOBAL_CONFIG);
  if (!injected) {
    const vm = getCurrentInstance();
    if (!vm) {
      throw new Error("useGlobalConfig must be called in setup function");
    }
    const config = getGlobalProperty(vm.appContext, "$vaConfig");
    if (!config) {
      throw new Error("Vuestic GlobalConfigPlugin is not registered");
    }
    return config;
  }
  return injected;
}

// node_modules/vuestic-ui/dist/es/src/vuestic-plugin/types/index.js
var defineVuesticPlugin = (fabric) => fabric;

// node_modules/vuestic-ui/dist/es/src/services/global-config/plugin/index.js
var GlobalConfigPlugin = defineVuesticPlugin((config) => ({
  install(app2) {
    const globalConfig = createGlobalConfig();
    if (config) {
      globalConfig.mergeGlobalConfig(config);
    }
    if (config == null ? void 0 : config.componentsAll) {
      console.warn("Global config -> `componentsAll` was moved to Global config -> components.all. Please replace this to make it work. More info here: https://github.com/epicmaxco/vuestic-ui/issues/1967");
    }
    app2.provide(GLOBAL_CONFIG, globalConfig);
    defineGlobalProperty(app2, "$vaConfig", globalConfig);
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/color-config/plugin/create-color-config-plugin.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/utils/ssr-utils.js
var isServer = () => typeof window === "undefined";
var isClient = () => !isServer();
var getWindow = () => typeof window === "undefined" ? void 0 : window;
var fakeGlobal = {};
var getGlobal = () => {
  if (isServer()) {
    if (typeof globalThis === "undefined") {
      return fakeGlobal;
    }
    return globalThis;
  } else {
    return window;
  }
};

// node_modules/vuestic-ui/dist/es/src/services/color-config/utils.js
var cssVariableName = (colorName) => `--va-${kebabCase_1(colorName)}`;
var normalizeColorName = (colorName) => camelCase_1(colorName);

// node_modules/vuestic-ui/dist/es/src/composables/useColors.js
init_vue_runtime_esm_bundler();

// node_modules/colortranslator/dist/esm/index.js
var t;
var e;
var r;
var n;
var i = function() {
  return i = Object.assign || function(t2) {
    for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
      for (var i2 in e2 = arguments[r2])
        Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
    return t2;
  }, i.apply(this, arguments);
};
function o(t2, e2, r2) {
  if (r2 || arguments.length === 2)
    for (var n2, i2 = 0, o2 = e2.length; i2 < o2; i2++)
      !n2 && i2 in e2 || (n2 || (n2 = Array.prototype.slice.call(e2, 0, i2)), n2[i2] = e2[i2]);
  return t2.concat(n2 || Array.prototype.slice.call(e2));
}
!function(t2) {
  t2.HEX = "HEX", t2.RGB = "RGB", t2.RGBA = "RGBA", t2.HSL = "HSL", t2.HSLA = "HSLA", t2.CMYK = "CMYK";
}(t || (t = {})), function(t2) {
  t2.ANALOGOUS = "ANALOGOUS", t2.COMPLEMENTARY = "COMPLEMENTARY", t2.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", t2.TRIADIC = "TRIADIC", t2.TETRADIC = "TETRADIC", t2.SQUARE = "SQUARE";
}(e || (e = {})), function(t2) {
  t2.ADDITIVE = "ADDITIVE", t2.SUBTRACTIVE = "SUBTRACTIVE";
}(r || (r = {})), function(t2) {
  t2.black = "#000000", t2.silver = "#C0C0C0", t2.gray = "#808080", t2.white = "#FFFFFF", t2.maroon = "#800000", t2.red = "#FF0000", t2.purple = "#800080", t2.fuchsia = "#FF00FF", t2.green = "#008000", t2.lime = "#00FF00", t2.olive = "#808000", t2.yellow = "#FFFF00", t2.navy = "#000080", t2.blue = "#0000FF", t2.teal = "#008080", t2.aqua = "#00FFFF", t2.orange = "#FFA500", t2.aliceblue = "#F0F8FF", t2.antiquewhite = "#FAEBD7", t2.aquamarine = "#7FFFD4", t2.azure = "#F0FFFF", t2.beige = "#F5F5DC", t2.bisque = "#FFE4C4", t2.blanchedalmond = "#FFEBCD", t2.blueviolet = "#8A2BE2", t2.brown = "#A52A2A", t2.burlywood = "#DEB887", t2.cadetblue = "#5F9EA0", t2.chartreuse = "#7FFF00", t2.chocolate = "#D2691E", t2.coral = "#FF7F50", t2.cornflowerblue = "#6495ED", t2.cornsilk = "#FFF8DC", t2.crimson = "#DC143C", t2.cyan = "#00FFFF", t2.darkblue = "#00008B", t2.darkcyan = "#008B8B", t2.darkgoldenrod = "#B8860B", t2.darkgray = "#A9A9A9", t2.darkgreen = "#006400", t2.darkgrey = "#A9A9A9", t2.darkkhaki = "#BDB76B", t2.darkmagenta = "#8B008B", t2.darkolivegreen = "#556B2F", t2.darkorange = "#FF8C00", t2.darkorchid = "#9932CC", t2.darkred = "#8B0000", t2.darksalmon = "#E9967A", t2.darkseagreen = "#8FBC8F", t2.darkslateblue = "#483D8B", t2.darkslategray = "#2F4F4F", t2.darkslategrey = "#2F4F4F", t2.darkturquoise = "#00CED1", t2.darkviolet = "#9400D3", t2.deeppink = "#FF1493", t2.deepskyblue = "#00BFFF", t2.dimgray = "#696969", t2.dimgrey = "#696969", t2.dodgerblue = "#1E90FF", t2.firebrick = "#B22222", t2.floralwhite = "#FFFAF0", t2.forestgreen = "#228B22", t2.gainsboro = "#DCDCDC", t2.ghostwhite = "#F8F8FF", t2.gold = "#FFD700", t2.goldenrod = "#DAA520", t2.greenyellow = "#ADFF2F", t2.grey = "#808080", t2.honeydew = "#F0FFF0", t2.hotpink = "#FF69B4", t2.indianred = "#CD5C5C", t2.indigo = "#4B0082", t2.ivory = "#FFFFF0", t2.khaki = "#F0E68C", t2.lavender = "#E6E6FA", t2.lavenderblush = "#FFF0F5", t2.lawngreen = "#7CFC00", t2.lemonchiffon = "#FFFACD", t2.lightblue = "#ADD8E6", t2.lightcoral = "#F08080", t2.lightcyan = "#E0FFFF", t2.lightgoldenrodyellow = "#FAFAD2", t2.lightgray = "#D3D3D3", t2.lightgreen = "#90EE90", t2.lightgrey = "#D3D3D3", t2.lightpink = "#FFB6C1", t2.lightsalmon = "#FFA07A", t2.lightseagreen = "#20B2AA", t2.lightskyblue = "#87CEFA", t2.lightslategray = "#778899", t2.lightslategrey = "#778899", t2.lightsteelblue = "#B0C4DE", t2.lightyellow = "#FFFFE0", t2.limegreen = "#32CD32", t2.linen = "#FAF0E6", t2.magenta = "#FF00FF", t2.mediumaquamarine = "#66CDAA", t2.mediumblue = "#0000CD", t2.mediumorchid = "#BA55D3", t2.mediumpurple = "#9370DB", t2.mediumseagreen = "#3CB371", t2.mediumslateblue = "#7B68EE", t2.mediumspringgreen = "#00FA9A", t2.mediumturquoise = "#48D1CC", t2.mediumvioletred = "#C71585", t2.midnightblue = "#191970", t2.mintcream = "#F5FFFA", t2.mistyrose = "#FFE4E1", t2.moccasin = "#FFE4B5", t2.navajowhite = "#FFDEAD", t2.oldlace = "#FDF5E6", t2.olivedrab = "#6B8E23", t2.orangered = "#FF4500", t2.orchid = "#DA70D6", t2.palegoldenrod = "#EEE8AA", t2.palegreen = "#98FB98", t2.paleturquoise = "#AFEEEE", t2.palevioletred = "#DB7093", t2.papayawhip = "#FFEFD5", t2.peachpuff = "#FFDAB9", t2.peru = "#CD853F", t2.pink = "#FFC0CB", t2.plum = "#DDA0DD", t2.powderblue = "#B0E0E6", t2.rosybrown = "#BC8F8F", t2.royalblue = "#4169E1", t2.saddlebrown = "#8B4513", t2.salmon = "#FA8072", t2.sandybrown = "#F4A460", t2.seagreen = "#2E8B57", t2.seashell = "#FFF5EE", t2.sienna = "#A0522D", t2.skyblue = "#87CEEB", t2.slateblue = "#6A5ACD", t2.slategray = "#708090", t2.slategrey = "#708090", t2.snow = "#FFFAFA", t2.springgreen = "#00FF7F", t2.steelblue = "#4682B4", t2.tan = "#D2B48C", t2.thistle = "#D8BFD8", t2.tomato = "#FF6347", t2.turquoise = "#40E0D0", t2.violet = "#EE82EE", t2.wheat = "#F5DEB3", t2.whitesmoke = "#F5F5F5", t2.yellowgreen = "#9ACD32", t2.rebeccapurple = "#663399";
}(n || (n = {}));
var u;
var a;
var s;
var c;
var d;
var f;
var h2;
var l = Object.keys(n);
var p = ((u = {})[t.HEX] = /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i, u[t.RGB] = /^rgb\s*\(\s*(?:(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)|(\d+)\s*,\s*(\d+)\s*,\s*(\d+))\s*\)$/, u[t.RGBA] = /^rgba\s*\(\s*(?:(\d+%)\s*,\s*(\d+%)\s*,\s*(\d+%)|(\d+)\s*,\s*(\d+)\s*,\s*(\d+))\s*,\s*(\d\.?\d*)\s*\)$/, u[t.HSL] = /^hsl\s*\(\s*(-?\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%s*\)$/, u[t.HSLA] = /^hsla\s*\(\s*(-?\d+\.?\d*)\s*,\s*(\d+\.?\d*)%\s*,\s*(\d+\.?\d*)%\s*,\s*(\d\.?\d*)\s*\)$/, u[t.CMYK] = /^(?:device-cmyk|cmyk)\s*\(\s*(?:(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)\s*,\s*(\d+\.?\d*%)|(\d\.?\d*)\s*,\s*(\d\.?\d*)\s*,\s*(\d\.?\d*)\s*,\s*(\d\.?\d*))\s*\)$/, u);
var g = /^(\d+(?:\.\d+)?|\.\d+)%$/;
var b = /^0x([a-f\d]{1,2})$/i;
var F = "The provided string color doesn't have a correct format";
var A = "The provided color object doesn't have the proper keys or format";
var m = function(t2, e2, r2) {
  return r2 < 0 && (r2 += 6), r2 >= 6 && (r2 -= 6), r2 < 1 ? Math.round(255 * ((e2 - t2) * r2 + t2)) : r2 < 3 ? Math.round(255 * e2) : r2 < 4 ? Math.round(255 * ((e2 - t2) * (4 - r2) + t2)) : Math.round(255 * t2);
};
var y = function(t2, e2, r2) {
  e2 /= 100;
  var n2 = (r2 /= 100) <= 0.5 ? r2 * (e2 + 1) : r2 + e2 - r2 * e2, i2 = 2 * r2 - n2;
  return { r: m(i2, n2, (t2 /= 60) + 2), g: m(i2, n2, t2), b: m(i2, n2, t2 - 2) };
};
var E = function(t2, e2, r2, n2) {
  return n2 = 1 - n2, { r: Math.round(255 * (1 - t2) * n2), g: Math.round(255 * (1 - e2) * n2), b: Math.round(255 * (1 - r2) * n2) };
};
var H = function(t2, e2, r2) {
  t2 /= 255, e2 /= 255, r2 /= 255;
  var n2 = 1 - Math.max(t2, e2, r2), i2 = 1 - n2, o2 = (i2 - t2) / i2, u2 = (i2 - e2) / i2, a2 = (i2 - r2) / i2;
  return { c: Math.round(100 * o2), m: Math.round(100 * u2), y: Math.round(100 * a2), k: Math.round(100 * n2) };
};
var B = function(t2, e2, r2, n2) {
  n2 === void 0 && (n2 = 1), t2 /= 255, e2 /= 255, r2 /= 255, n2 = Math.min(n2, 1);
  var i2 = Math.max(t2, e2, r2), o2 = Math.min(t2, e2, r2), u2 = i2 - o2, a2 = 0, s2 = 0, c2 = (i2 + o2) / 2;
  if (u2 === 0)
    a2 = 0, s2 = 0;
  else {
    switch (i2) {
      case t2:
        a2 = (e2 - r2) / u2 % 6;
        break;
      case e2:
        a2 = (r2 - t2) / u2 + 2;
        break;
      case r2:
        a2 = (t2 - e2) / u2 + 4;
    }
    (a2 = Math.round(60 * a2)) < 0 && (a2 += 360), s2 = u2 / (1 - Math.abs(2 * c2 - 1));
  }
  return { h: a2, s: Math.round(100 * s2), l: Math.round(100 * c2), a: n2 };
};
var v = function(t2, e2) {
  if (t2 < 0 && (t2 += 360), t2 > 360 && (t2 -= 360), t2 === 360 || t2 === 0)
    return t2;
  var r2 = [[0, 120], [120, 180], [180, 240], [240, 360]], n2 = [[0, 60], [60, 120], [120, 240], [240, 360]], i2 = e2 ? n2 : r2, o2 = 0, u2 = 0, a2 = 0, s2 = 0;
  return (e2 ? r2 : n2).find(function(e3, r3) {
    return t2 >= e3[0] && t2 < e3[1] && (o2 = e3[0], u2 = e3[1], a2 = i2[r3][0], s2 = i2[r3][1], true);
  }), a2 + (s2 - a2) / (u2 - o2) * (t2 - o2);
};
var M = function(t2, e2) {
  return Object.prototype.hasOwnProperty.call(t2, e2);
};
var R = function(t2) {
  return g.test("" + t2) ? +("" + t2).replace(g, "$1") : Math.min(+t2, 100);
};
var S = function(t2) {
  return t2.length === 1 && (t2 += t2), parseInt(t2, 16);
};
var C = function(t2) {
  var e2 = parseInt("" + t2).toString(16).toUpperCase();
  return e2.length === 1 ? "0x0" + e2 : "0x" + e2;
};
var L = function(t2) {
  var e2 = parseInt("" + t2).toString(16).toUpperCase();
  return e2.length === 1 && (e2 = "0" + e2), e2;
};
var D = function(t2, e2) {
  return e2 === void 0 && (e2 = false), !e2 && g.test(t2) ? Math.min(255 * +t2.replace(g, "$1") / 100, 255) : b.test(t2) ? t2.length === 3 ? e2 ? parseInt(t2 + t2.slice(-1)) / 255 : parseInt(t2 + t2.slice(-1)) : e2 ? parseInt(t2) / 255 : parseInt(t2) : Math.min(+t2, e2 ? 1 : 255);
};
var G = function(t2) {
  return Math.min(g.test(t2) ? +t2.replace(g, "$1") / 100 : +t2, 1);
};
var k = function(t2) {
  return t2.sort().join().toUpperCase();
};
var O = function(t2, e2) {
  e2 === void 0 && (e2 = 0);
  var r2 = Math.pow(10, e2);
  return Math.round(+t2 * r2) / r2;
};
var X = function(t2, e2, r2) {
  return Math.max(e2, Math.min(t2, r2));
};
var I = ((a = {})[t.HEX] = function(t2) {
  return "#" + L(t2.r) + L(t2.g) + L(t2.b) + (M(t2, "a") && L(t2.a) || "");
}, a[t.RGB] = function(t2) {
  return "rgb" + (M(t2, "a") ? "a" : "") + "(" + O(t2.r) + "," + O(t2.g) + "," + O(t2.b) + (M(t2, "a") && "," + O(t2.a, 2) || "") + ")";
}, a[t.HSL] = function(t2) {
  return "hsl" + (M(t2, "a") ? "a" : "") + "(" + O(t2.h) + "," + O(t2.s) + "%," + O(t2.l) + "%" + (M(t2, "a") && "," + O(t2.a, 2) || "") + ")";
}, a[t.CMYK] = function(t2) {
  return "cmyk(" + O(t2.c) + "%," + O(t2.m) + "%," + O(t2.y) + "%," + O(t2.k) + "%)";
}, a);
var j = function(t2) {
  return (t2 > 360 || t2 < 0) && (t2 -= 360 * Math.floor(t2 / 360)), t2;
};
var T = function(t2) {
  return isNaN(+t2) || t2 > 1 ? 1 : O(t2, 2);
};
var Y = function(t2, e2, n2) {
  return e2.reduce(function(e3, u2) {
    return o(o([], e3, true), [i(i({}, t2), { h: n2 === r.ADDITIVE ? j(t2.h + u2) : j(v(v(t2.h, false) + u2, true)) })], false);
  }, [i({}, t2)]);
};
var P = function(t2, e2) {
  return Y(t2, [30, -30], e2);
};
var w = function(t2, e2) {
  return Y(t2, [180], e2);
};
var K = function(t2, e2) {
  return Y(t2, [150, -150], e2);
};
var x = function(t2, e2) {
  return Y(t2, [120, -120], e2);
};
var N = function(t2, e2) {
  return Y(t2, [60, -120, 180], e2);
};
var V = function(t2, e2) {
  return Y(t2, [90, -90, 180], e2);
};
var U = function(e2) {
  return typeof e2 == "string" ? function(e3) {
    var r2;
    if (Object.keys(t).some(function(t2) {
      if (p[t2].test(e3))
        return r2 = t2, true;
    }), !r2 && ~l.indexOf(e3) && (r2 = t.HEX), !r2)
      throw new Error(F);
    return r2;
  }(e2) : function(e3) {
    var r2, n2 = false, i2 = k(Object.keys(e3));
    if (Object.keys(t).filter(function(e4) {
      return e4 !== t.HEX;
    }).some(function(t2) {
      if (k(t2.split("")) === i2)
        return r2 = t2, true;
    }), r2 && r2 === t.RGB || r2 === t.RGBA) {
      var o2 = Object.entries(e3).map(function(t2) {
        return b.test("" + t2[1]);
      }), u2 = Object.entries(e3).map(function(t2) {
        return g.test("" + t2[1]) || !b.test("" + t2[1]) && !isNaN(+t2[1]) && +t2[1] <= 255;
      }), a2 = o2.some(function(t2, e4) {
        return e4 > 0 && t2 !== o2[e4 - 1];
      }), s2 = u2.some(function(t2, e4) {
        return e4 > 0 && t2 !== u2[e4 - 1];
      });
      !(n2 = a2 || s2 || !o2[0] && !u2[0]) && o2[0] && (r2 = t.HEX);
    }
    if (!r2 || n2)
      throw new Error(A);
    return r2;
  }(e2);
};
var $ = ((s = {})[t.HEX] = function(t2) {
  var e2 = (~l.indexOf(t2) ? n[t2] : t2).match(p.HEX), r2 = { r: S(e2[1] || e2[5]), g: S(e2[2] || e2[6]), b: S(e2[3] || e2[7]) }, i2 = e2[4] || e2[8];
  return i2 !== void 0 && (r2.a = S(i2) / 255), r2;
}, s[t.RGB] = function(t2) {
  var e2 = t2.match(p.RGB), r2 = D(e2[1] || e2[4]), n2 = D(e2[2] || e2[5]), i2 = D(e2[3] || e2[6]);
  return { r: Math.min(r2, 255), g: Math.min(n2, 255), b: Math.min(i2, 255) };
}, s[t.RGBA] = function(t2) {
  var e2 = t2.match(p.RGBA), r2 = D(e2[1] || e2[4]), n2 = D(e2[2] || e2[5]), i2 = D(e2[3] || e2[6]), o2 = +e2[7];
  return { r: Math.min(r2, 255), g: Math.min(n2, 255), b: Math.min(i2, 255), a: T(o2) };
}, s[t.HSL] = function(t2) {
  var e2 = t2.match(p.HSL), r2 = j(+e2[1]), n2 = R(e2[2]), i2 = R(e2[3]);
  return y(r2, n2, i2);
}, s[t.HSLA] = function(t2) {
  var e2 = t2.match(p.HSLA), r2 = j(+e2[1]), n2 = R(e2[2]), i2 = R(e2[3]), o2 = +e2[4], u2 = y(r2, n2, i2);
  return u2.a = T(o2), u2;
}, s[t.CMYK] = function(t2) {
  var e2 = t2.match(p.CMYK), r2 = G(e2[1] || e2[5]), n2 = G(e2[2] || e2[6]), i2 = G(e2[3] || e2[7]), o2 = G(e2[4] || e2[8]);
  return E(r2, n2, i2, o2);
}, s);
var q = ((c = {})[t.HEX] = function(t2) {
  var e2 = { r: D("" + t2.r), g: D("" + t2.g), b: D("" + t2.b) };
  return e2.a = M(t2, "a") ? Math.min(D("" + t2.a, true), 1) : 1, e2;
}, c[t.RGB] = function(t2) {
  var e2 = this.HEX(t2);
  return delete e2.a, e2;
}, c[t.RGBA] = function(t2) {
  return this.HEX(t2);
}, c[t.HSL] = function(t2) {
  var e2 = R("" + t2.s), r2 = R("" + t2.l);
  return y(j(t2.h), e2, r2);
}, c[t.HSLA] = function(t2) {
  var e2 = this.HSL(t2);
  return e2.a = T(t2.a), e2;
}, c[t.CMYK] = function(t2) {
  var e2 = G("" + t2.c), r2 = G("" + t2.m), n2 = G("" + t2.y), i2 = G("" + t2.k);
  return E(e2, r2, n2, i2);
}, c);
var Q = function(t2, e2) {
  return e2 === void 0 && (e2 = U(t2)), typeof t2 == "string" ? $[e2](t2) : q[e2](t2);
};
var _ = ((d = {})[t.HEX] = function(t2) {
  return { r: C(t2.r), g: C(t2.g), b: C(t2.b) };
}, d.HEXA = function(t2) {
  var e2 = _.HEX(t2);
  return e2.a = M(t2, "a") ? C(255 * t2.a) : "0xFF", e2;
}, d[t.RGB] = function(t2) {
  return M(t2, "a") && delete t2.a, t2;
}, d[t.RGBA] = function(t2) {
  return t2.a = M(t2, "a") ? O(t2.a, 2) : 1, t2;
}, d[t.HSL] = function(t2) {
  var e2 = B(t2.r, t2.g, t2.b);
  return delete e2.a, e2;
}, d[t.HSLA] = function(t2) {
  var e2 = _.HSL(t2);
  return e2.a = M(t2, "a") ? O(t2.a, 2) : 1, e2;
}, d[t.CMYK] = function(t2) {
  return H(t2.r, t2.g, t2.b);
}, d);
var z = function(e2, r2, n2) {
  var o2 = U(e2), u2 = typeof e2 == "string", a2 = Q(e2, o2), s2 = typeof e2 == "string" && M(a2, "a") || typeof e2 != "string" && M(e2, "a"), c2 = B(a2.r, a2.g, a2.b, a2.a);
  s2 || delete c2.a;
  var d2 = n2 ? c2.l / (r2 + 1) : (100 - c2.l) / (r2 + 1), f2 = Array(r2).fill(null).map(function(t2, e3) {
    return i(i({}, c2), { l: c2.l + d2 * (e3 + 1) * (1 - 2 * +n2) });
  });
  switch (o2) {
    case t.HEX:
    default:
      return f2.map(function(t2) {
        var e3 = y(t2.h, t2.s, t2.l);
        return s2 && (e3.a = t2.a), u2 ? s2 ? I.HEX(i(i({}, e3), { a: O(255 * e3.a, 2) })) : I.HEX(e3) : s2 ? _.HEXA(e3) : _.HEX(e3);
      });
    case t.RGB:
    case t.RGBA:
      return f2.map(function(t2) {
        var e3 = y(t2.h, t2.s, t2.l);
        return s2 && (e3.a = t2.a), u2 ? I.RGB(e3) : s2 ? _.RGBA(e3) : _.RGB(e3);
      });
    case t.HSL:
    case t.HSLA:
      return f2.map(function(t2) {
        return u2 ? I.HSL(t2) : s2 ? _.HSLA(i(i({}, y(t2.h, t2.s, t2.l)), { a: t2.a })) : _.HSL(y(t2.h, t2.s, t2.l));
      });
  }
};
var J = ((f = { buildHarmony: function(e2, r2, n2) {
  var i2 = U(e2), o2 = Q(e2, i2), u2 = B(o2.r, o2.g, o2.b, o2.a), a2 = typeof e2 == "string" && M(o2, "a") || typeof e2 != "string" && M(e2, "a"), s2 = typeof e2 == "string";
  switch (i2) {
    case t.HEX:
    default:
      return a2 ? this.HEXA(u2, r2, n2, s2) : this.HEX(u2, r2, n2, s2);
    case t.HSL:
      return this.HSL(u2, r2, n2, s2);
    case t.HSLA:
      return this.HSLA(u2, r2, n2, s2);
    case t.RGB:
      return this.RGB(u2, r2, n2, s2);
    case t.RGBA:
      return this.RGBA(u2, r2, n2, s2);
  }
} })[t.HEX] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HEX(y(t3.h, t3.s, t3.l)) : _.HEX(y(t3.h, t3.s, t3.l));
  });
}, f.HEXA = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HEX(i(i({}, y(t3.h, t3.s, t3.l)), { a: 255 * T(t3.a) })) : _.HEXA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f[t.RGB] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.RGB(y(t3.h, t3.s, t3.l)) : _.RGB(y(t3.h, t3.s, t3.l));
  });
}, f[t.RGBA] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.RGB(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) })) : _.RGBA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f[t.HSL] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HSL({ h: t3.h, s: t3.s, l: t3.l }) : _.HSL(y(t3.h, t3.s, t3.l));
  });
}, f[t.HSLA] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HSL(i(i({}, t3), { a: T(t3.a) })) : _.HSLA(i(i({}, y(t3.h, t3.s, t3.l)), { a: T(t3.a) }));
  });
}, f);
var W = ((h2 = { mix: function(t2, e2) {
  var n2, o2, u2, a2, s2, c2, d2, f2, h3, l2, p2, g2, b2, F2, A2, m2 = t2.map(function(t3) {
    var e3 = U(t3);
    return Q(t3, e3);
  }), y2 = e2 === r.SUBTRACTIVE ? m2.map(function(t3) {
    var e3, r2, n3, i2, o3, u3, a3, s3, c3, d3, f3, h4, l3, p3, g3 = (e3 = t3.r, r2 = t3.g, n3 = t3.b, i2 = Math.min(e3, r2, n3), o3 = Math.min(255 - e3, 255 - r2, 255 - n3), u3 = e3 - i2, a3 = r2 - i2, s3 = n3 - i2, c3 = Math.min(u3, a3), d3 = u3 - c3, f3 = (a3 + c3) / 2, h4 = (s3 + a3 - c3) / 2, l3 = Math.max(d3, f3, h4) / Math.max(u3, a3, s3), p3 = isNaN(l3) || l3 === 1 / 0 || l3 <= 0 ? 1 : l3, { r: d3 / p3 + o3, y: f3 / p3 + o3, b: h4 / p3 + o3 });
    return M(t3, "a") && (g3.a = t3.a), g3;
  }) : null;
  function E2(t3) {
    var n3 = e2 === r.ADDITIVE ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, y: 0, b: 0, a: 0 };
    return t3.reduce(function(t4, n4) {
      var o3 = M(n4, "a") ? n4.a : 1, u3 = { r: Math.min(t4.r + n4.r * o3, 255), b: Math.min(t4.b + n4.b * o3, 255), a: 1 - (1 - o3) * (1 - t4.a) }, a3 = "g" in t4 ? t4.g : t4.y, s3 = "g" in n4 ? n4.g : n4.y;
      return i(i({}, u3), e2 === r.ADDITIVE ? { g: Math.min(a3 + s3 * o3, 255) } : { y: Math.min(a3 + s3 * o3, 255) });
    }, n3);
  }
  if (e2 === r.ADDITIVE)
    n2 = E2(m2);
  else {
    var H2 = E2(y2);
    o2 = H2.r, u2 = H2.y, a2 = H2.b, s2 = Math.min(o2, u2, a2), c2 = Math.min(255 - o2, 255 - u2, 255 - a2), d2 = o2 - s2, f2 = u2 - s2, h3 = a2 - s2, l2 = Math.min(f2, h3), p2 = d2 + f2 - l2, g2 = f2 + 2 * l2, b2 = 2 * (h3 - l2), F2 = Math.max(p2, g2, b2) / Math.max(d2, f2, h3), A2 = isNaN(F2) || F2 === 1 / 0 || F2 <= 0 ? 1 : F2, (n2 = { r: p2 / A2 + c2, g: g2 / A2 + c2, b: b2 / A2 + c2 }).a = H2.a;
  }
  return { r: O(n2.r, 2), g: O(n2.g, 2), b: O(n2.b, 2), a: X(n2.a, 0, 1) };
} })[t.HEX] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.HEX(n2) : _.HEX(n2);
}, h2.HEXA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return n2.a = r2 ? 255 * T(n2.a) : T(n2.a), r2 ? I.HEX(n2) : _.HEXA(n2);
}, h2[t.RGB] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.RGB(n2) : _.RGB(n2);
}, h2[t.RGBA] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return r2 ? I.RGB(n2) : _.RGBA(n2);
}, h2[t.HSL] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), i2 = B(n2.r, n2.g, n2.b);
  return delete n2.a, delete i2.a, r2 ? I.HSL(i2) : _.HSL(n2);
}, h2[t.HSLA] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), i2 = B(n2.r, n2.g, n2.b, n2.a);
  return r2 ? I.HSL(i2) : _.HSLA(n2);
}, h2);
var Z = function(t2, e2) {
  return typeof t2 == "string" && e2 || typeof t2 == "object" && !e2;
};
var tt = function(t2, e2, r2, n2, i2) {
  var o2 = n2(Q(t2, e2));
  return r2 ? i2(o2) : o2;
};
var et = function(t2, e2, r2, n2, i2, o2) {
  r2 < 1 && (r2 = 5);
  var u2 = function(t3, e3, r3) {
    var n3 = r3 - 1, i3 = (e3.r - t3.r) / n3, o3 = (e3.g - t3.g) / n3, u3 = (e3.b - t3.b) / n3, a2 = T(t3.a), s2 = (T(e3.a) - a2) / n3;
    return Array(r3).fill(null).map(function(r4, c2) {
      return c2 === 0 ? t3 : c2 === n3 ? e3 : { r: O(t3.r + i3 * c2), g: O(t3.g + o3 * c2), b: O(t3.b + u3 * c2), a: O(a2 + s2 * c2, 2) };
    });
  }(Q(t2), Q(e2), r2);
  return u2.map(function(t3) {
    var e3 = i2(t3);
    return n2 ? o2(e3) : e3;
  });
};
var rt = function() {
  function n2(t2) {
    this.rgb = Q(t2), this.updateHSL(), this.updateCMYK();
  }
  return n2.prototype.updateRGB = function() {
    this.rgb = i(i({}, y(this.hsl.h, this.hsl.s, this.hsl.l)), { a: this.hsl.a });
  }, n2.prototype.updateRGBFromCMYK = function() {
    this.rgb = i(i({}, E(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k)), { a: this.rgb.a });
  }, n2.prototype.updateHSL = function() {
    this.hsl = B(this.rgb.r, this.rgb.g, this.rgb.b, this.rgb.a);
  }, n2.prototype.updateCMYK = function() {
    this.cmyk = H(this.rgb.r, this.rgb.g, this.rgb.b);
  }, n2.prototype.updateRGBAndCMYK = function() {
    return this.updateRGB(), this.updateCMYK(), this;
  }, n2.prototype.updateHSLAndCMYK = function() {
    return this.updateHSL(), this.updateCMYK(), this;
  }, n2.prototype.updateRGBAndHSL = function() {
    return this.updateRGBFromCMYK(), this.updateHSL(), this;
  }, n2.prototype.setH = function(t2) {
    return this.hsl.h = j(t2), this.updateRGBAndCMYK();
  }, n2.prototype.setS = function(t2) {
    return this.hsl.s = X(t2, 0, 100), this.updateRGBAndCMYK();
  }, n2.prototype.setL = function(t2) {
    return this.hsl.l = X(t2, 0, 100), this.updateRGBAndCMYK();
  }, n2.prototype.setR = function(t2) {
    return this.rgb.r = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setG = function(t2) {
    return this.rgb.g = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setB = function(t2) {
    return this.rgb.b = X(t2, 0, 255), this.updateHSLAndCMYK();
  }, n2.prototype.setA = function(t2) {
    return this.hsl.a = this.rgb.a = X(t2, 0, 1), this;
  }, n2.prototype.setC = function(t2) {
    return this.cmyk.c = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setM = function(t2) {
    return this.cmyk.m = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setY = function(t2) {
    return this.cmyk.y = X(t2, 0, 100), this.updateRGBAndHSL();
  }, n2.prototype.setK = function(t2) {
    return this.cmyk.k = X(t2, 0, 100), this.updateRGBAndHSL();
  }, Object.defineProperty(n2.prototype, "H", { get: function() {
    return O(this.hsl.h);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "S", { get: function() {
    return O(this.hsl.s);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "L", { get: function() {
    return O(this.hsl.l);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "R", { get: function() {
    return O(this.rgb.r);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "G", { get: function() {
    return O(this.rgb.g);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "B", { get: function() {
    return O(this.rgb.b);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "A", { get: function() {
    return O(this.hsl.a, 2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "C", { get: function() {
    return O(this.cmyk.c);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "M", { get: function() {
    return O(this.cmyk.m);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "Y", { get: function() {
    return O(this.cmyk.y);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "K", { get: function() {
    return O(this.cmyk.k);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXObject", { get: function() {
    return _.HEX(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXAObject", { get: function() {
    return _.HEXA(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBObject", { get: function() {
    return { r: this.R, g: this.G, b: this.B };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBAObject", { get: function() {
    return i(i({}, this.RGBObject), { a: this.A });
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLObject", { get: function() {
    return { h: this.H, s: this.S, l: this.L };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLAObject", { get: function() {
    return i(i({}, this.HSLObject), { a: this.A });
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "CMYKObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K };
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEX", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b };
    return I.HEX(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HEXA", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b, a: 255 * this.A };
    return I.HEX(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGB", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b };
    return I.RGB(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "RGBA", { get: function() {
    var t2 = this.rgb, e2 = { r: t2.r, g: t2.g, b: t2.b, a: this.A };
    return I.RGB(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSL", { get: function() {
    var t2 = this.hsl, e2 = { h: t2.h, s: t2.s, l: t2.l };
    return I.HSL(e2);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "HSLA", { get: function() {
    return I.HSL(this.hsl);
  }, enumerable: false, configurable: true }), Object.defineProperty(n2.prototype, "CMYK", { get: function() {
    return I.CMYK(this.cmyk);
  }, enumerable: false, configurable: true }), n2.toHEX = function(t2, e2) {
    e2 === void 0 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.HEX, I.HEX);
  }, n2.toHEXA = function(t2, e2) {
    e2 === void 0 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.HEXA, I.HEX);
  }, n2.toRGB = function(t2, e2) {
    e2 === void 0 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.RGB, I.RGB);
  }, n2.toRGBA = function(t2, e2) {
    e2 === void 0 && (e2 = true);
    var r2 = U(t2);
    return tt(t2, r2, e2, _.RGBA, I.RGB);
  }, n2.toHSL = function(e2, r2) {
    r2 === void 0 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.HSL && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.HSL, I.HSL);
  }, n2.toHSLA = function(e2, r2) {
    r2 === void 0 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.HSLA && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.HSLA, I.HSL);
  }, n2.toCMYK = function(e2, r2) {
    r2 === void 0 && (r2 = true);
    var n3 = U(e2);
    return n3 === t.CMYK && Z(e2, r2) ? e2 : tt(e2, n3, r2, _.CMYK, I.CMYK);
  }, n2.getBlendHEX = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.HEX, I.HEX);
  }, n2.getBlendHEXA = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.HEXA, I.HEX);
  }, n2.getBlendRGB = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.RGB, I.RGB);
  }, n2.getBlendRGBA = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.RGBA, I.RGB);
  }, n2.getBlendHSL = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.HSL, I.HSL);
  }, n2.getBlendHSLA = function(t2, e2, r2, n3) {
    return r2 === void 0 && (r2 = 5), n3 === void 0 && (n3 = true), et(t2, e2, r2, n3, _.HSLA, I.HSL);
  }, n2.getMixHEX = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.HEX(t2, e2, n3);
  }, n2.getMixHEXA = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.HEXA(t2, e2, n3);
  }, n2.getMixRGB = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.RGB(t2, e2, n3);
  }, n2.getMixRGBA = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.RGBA(t2, e2, n3);
  }, n2.getMixHSL = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.HSL(t2, e2, n3);
  }, n2.getMixHSLA = function(t2, e2, n3) {
    return e2 === void 0 && (e2 = r.ADDITIVE), n3 === void 0 && (n3 = true), W.HSLA(t2, e2, n3);
  }, n2.getShades = function(t2, e2) {
    return z(t2, e2, true);
  }, n2.getTints = function(t2, e2) {
    return z(t2, e2, false);
  }, n2.getHarmony = function(t2, n3, i2) {
    switch (n3 === void 0 && (n3 = e.COMPLEMENTARY), i2 === void 0 && (i2 = r.ADDITIVE), n3) {
      case e.ANALOGOUS:
        return J.buildHarmony(t2, P, i2);
      case e.SPLIT_COMPLEMENTARY:
        return J.buildHarmony(t2, K, i2);
      case e.TRIADIC:
        return J.buildHarmony(t2, x, i2);
      case e.TETRADIC:
        return J.buildHarmony(t2, N, i2);
      case e.SQUARE:
        return J.buildHarmony(t2, V, i2);
      default:
        return J.buildHarmony(t2, w, i2);
    }
  }, n2;
}();

// node_modules/vuestic-ui/dist/es/src/services/color-config/color-functions.js
var colorToRgba = (color, opacity) => {
  return new rt(color).setA(opacity).RGBA;
};
var getColorLightness = (color) => {
  const { R: R2, G: G2, B: B2 } = new rt(color);
  return Math.sqrt(R2 * R2 * 0.241 + G2 * G2 * 0.691 + B2 * B2 * 0.068);
};
var getBoxShadowColor = (color) => {
  return new rt(color).setA(0.4).RGBA;
};
var getBoxShadowColorFromBg = (background) => {
  return new rt(background).setA(0.4).RGBA;
};
var getHoverColor = (color) => {
  return new rt(color).setA(0.2).RGBA;
};
var getFocusColor = (color) => {
  return new rt(color).setA(0.3).RGBA;
};
var shiftHSLAColor = (color, offset) => {
  const result = new rt(color);
  if (offset.h) {
    result.setH(result.H + offset.h);
  }
  if (offset.s) {
    result.setS(result.S + offset.s);
  }
  if (offset.l) {
    result.setL(result.L + offset.l);
  }
  if (offset.a) {
    result.setA(result.A + offset.a);
  }
  return result.HSLA;
};
var setHSLAColor = (color, newColor) => {
  const result = new rt(color);
  if (newColor.h !== void 0) {
    result.setH(newColor.h);
  }
  if (newColor.s !== void 0) {
    result.setS(newColor.s);
  }
  if (newColor.l !== void 0) {
    result.setL(newColor.l);
  }
  if (newColor.a !== void 0) {
    result.setA(newColor.a);
  }
  return result.HSLA;
};
var shiftGradientColor = (color) => {
  const newColor = rt.toHSLA(color, false);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
var getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  const colorRight = rt.toHSLA(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;
};
var getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {
  const mask = colorToRgba(maskColor, maskOpacity);
  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
var isColor = (strColor) => {
  const cssColorRegex = /^#([\da-f]{3}){1,2}$|^#([\da-f]{4}){1,2}$|(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*,?\s*\)?)(,\s*(0?\.\d+)?|1)?\)/;
  return cssColorRegex.test(strColor.toLocaleLowerCase());
};
var isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
var applyColors = (color1, color2) => {
  const c1 = new rt(color1);
  const c2 = new rt(color2);
  const weight = c2.A;
  if (weight === 1) {
    return c2.RGBA;
  }
  if (weight === 0) {
    return c1.RGBA;
  }
  c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));
  c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));
  c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));
  return c1.RGBA;
};

// node_modules/vuestic-ui/dist/es/src/services/utils.js
var sleep = (ms = 0) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};
var warn = (...attrs) => {
  return false;
};
var hasOwnProperty2 = (object, key) => {
  return Object.prototype.hasOwnProperty.call(object, key);
};
var getNestedValue = (option, propsArray) => {
  if (propsArray.length === 0) {
    return option;
  }
  const nestedItem = option[propsArray[0]];
  if (!isObject_1(nestedItem)) {
    if (propsArray.length === 1) {
      return nestedItem;
    }
    return void 0;
  }
  return getNestedValue(nestedItem, propsArray.slice(1));
};
var getValueByPath = (option, prop) => {
  if (prop in option) {
    return option[prop];
  }
  prop = prop.replace(/^\./, "");
  return getNestedValue(option, prop.split("."));
};
var getValueByKey = (option, prop) => {
  if (!option || typeof option !== "object" || Array.isArray(option)) {
    return void 0;
  }
  if (!prop) {
    return option;
  }
  if (typeof prop === "string") {
    return getValueByPath(option, prop);
  }
  if (typeof prop === "function") {
    return prop(option);
  }
  return option;
};
var getRandomString = (stringLength = 4) => {
  return Math.random().toString(36).substring(2, stringLength + 2);
};
var generateUniqueId = () => {
  return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}`;
};
var isParsableMeasure = (value) => {
  if (typeof value === "string") {
    return !isNaN(+value) || value.endsWith("px") || value.endsWith("rem");
  }
  return typeof value === "number";
};
var isParsablePositiveMeasure = (value) => {
  return isParsableMeasure(value) && parseInt(value) >= 0;
};
var checkSlotChildrenDeep = (v2, initial = true) => {
  var _a;
  if (!v2 || initial && (!isFunction_1(v2) || !((_a = v2()) == null ? void 0 : _a.length))) {
    return false;
  }
  const slotData = initial ? v2() : v2;
  if (Array.isArray(slotData)) {
    return slotData.some((el) => {
      return Array.isArray(el.children) ? checkSlotChildrenDeep(el.children, false) : el.children || el.props;
    });
  }
  return !!slotData.children;
};

// node_modules/vuestic-ui/dist/es/src/services/cache/plugin/index.js
var createAppCachePlugin = (app2) => {
  const cache = {
    colorContrast: {}
  };
  return cache;
};
var VaAppCachePluginKey = Symbol("VaAppCachePlugin");
var CachePlugin = defineVuesticPlugin(() => ({
  install(app2) {
    const cache = createAppCachePlugin();
    app2.provide(VaAppCachePluginKey, cache);
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/cache/useCache.js
var useCache = () => {
  return inject2(VaAppCachePluginKey, {
    colorContrast: {}
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useReactiveComputed.js
init_vue_runtime_esm_bundler();
var useReactiveComputed = (obj) => {
  const objectRef = computed(obj);
  const proxy = new Proxy({}, {
    get(target, p2, receiver) {
      return unref(Reflect.get(objectRef.value, p2, receiver));
    },
    set(target, p2, value) {
      if (isRef(objectRef.value[p2]) && !isRef(value)) {
        objectRef.value[p2].value = value;
      } else {
        objectRef.value[p2] = value;
      }
      return true;
    },
    deleteProperty(target, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(target, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
};

// node_modules/vuestic-ui/dist/es/src/composables/useColors.js
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
var useColors = () => {
  const gc = useGlobalConfigSafe();
  if (!gc) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { setGlobalConfig, globalConfig } = gc;
  const colors = useReactiveComputed({
    get: () => globalConfig.value.colors.variables,
    set: (v2) => {
      setColors(v2);
    }
  });
  const setColors = (colors2) => {
    globalConfig.value.colors.variables = __spreadValues(__spreadValues({}, globalConfig.value.colors.variables), colors2);
  };
  const getColors = () => {
    return colors;
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = getColors().primary;
    }
    const colors2 = getColors();
    if (!prop) {
      prop = getColor(defaultColor);
    }
    const normalizedColor = normalizeColorName(prop);
    if (colors2[normalizedColor]) {
      return preferVariables ? `var(${cssVariableName(prop)})` : colors2[normalizedColor];
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    return getColor(defaultColor);
  };
  const getComputedColor = (color) => {
    return computed(() => getColor(color));
  };
  const colorsToCSSVariable = (colors2, prefix2 = "va") => {
    return Object.keys(colors2).filter((key) => colors2[key] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix2}-${colorName}`] = getColor(colors2[colorName], void 0, true);
      return acc;
    }, {});
  };
  const cache = useCache();
  const getColorLightnessFromCache = (color) => {
    if (typeof color !== "string") {
      return getColorLightness(color);
    }
    if (!cache.colorContrast[color]) {
      cache.colorContrast[color] = getColorLightness(color);
    }
    return cache.colorContrast[color];
  };
  const computedDarkColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > globalConfig.value.colors.threshold ? "textInverted" : "textPrimary";
  });
  const computedLightColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > globalConfig.value.colors.threshold ? "textPrimary" : "textInverted";
  });
  const getTextColor = (color, darkColor, lightColor) => {
    darkColor = darkColor || computedDarkColor.value;
    lightColor = lightColor || computedLightColor.value;
    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;
  };
  const currentPresetName = computed(() => globalConfig.value.colors.currentPresetName);
  const presets = computed(() => globalConfig.value.colors.presets);
  const applyPreset = (presetName) => {
    globalConfig.value.colors.currentPresetName = presetName;
    if (!globalConfig.value.colors.presets[presetName]) {
      return warn(`Preset ${presetName} does not exist`);
    }
    globalConfig.value.colors.variables = __spreadValues({}, globalConfig.value.colors.presets[presetName]);
  };
  return {
    colors,
    currentPresetName,
    presets,
    applyPreset,
    setColors,
    getColors,
    getColor,
    getComputedColor,
    getBoxShadowColor,
    getBoxShadowColorFromBg,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable,
    colorToRgba,
    getStateMaskGradientBackground
  };
};

// node_modules/vuestic-ui/dist/es/src/services/color-config/plugin/create-color-config-plugin.js
var setCSSVariable = (name, value, root2) => {
  root2.style.setProperty(cssVariableName(name), value);
};
var createColorConfigPlugin = (app2) => {
  const { colors, getTextColor: getTextColor2, getColor } = useColors();
  const renderCSSVariables = (colors2) => {
    if (!colors2) {
      return;
    }
    const colorNames = Object.keys(colors2);
    return colorNames.map((key) => `${cssVariableName(key)}: ${colors2[key]}`).join(";");
  };
  const updateColors = (newValue) => {
    if (!newValue) {
      return;
    }
    if (isServer()) {
      return;
    }
    const root2 = document.documentElement;
    const colorNames = Object.keys(newValue);
    colorNames.forEach((key) => {
      setCSSVariable(key, newValue[key], root2);
    });
    colorNames.forEach((key) => {
      setCSSVariable(`on-${key}`, getColor(getTextColor2(newValue[key])), root2);
    });
  };
  updateColors(colors);
  watch(colors, (newValue) => {
    updateColors(newValue);
  }, { immediate: true, deep: true });
  return {
    renderCSSVariables,
    updateColors
  };
};

// node_modules/vuestic-ui/dist/es/src/services/color-config/plugin/index.js
var ColorConfigPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    defineGlobalProperty(app2, "$vaColorConfig", createColorConfigPlugin());
  }
}));

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/plugin/create-service.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useClientOnly.js
init_vue_runtime_esm_bundler();
var useClientOnly = (cb) => {
  if (isServer()) {
    const result = ref(null);
    onMounted(() => {
      result.value = cb();
    });
    return result;
  }
  return ref(cb());
};

// node_modules/vuestic-ui/dist/es/src/composables/useDocument.js
var useDocument = () => useClientOnly(() => document);

// node_modules/vuestic-ui/dist/es/src/composables/useWindowSize.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useEvent.js
init_vue_runtime_esm_bundler();
var useEvent = (event, listener, target) => {
  const source = target && typeof target !== "boolean" ? target : useClientOnly(() => window);
  const capture = typeof target === "boolean" ? target : false;
  watch(source, (newValue, oldValue) => {
    var _a, _b;
    if (!Array.isArray(event)) {
      (_a = unref(newValue)) == null ? void 0 : _a.addEventListener(event, listener, capture);
      (_b = unref(oldValue)) == null ? void 0 : _b.removeEventListener(event, listener, capture);
    } else {
      event.forEach((e2) => {
        var _a2, _b2;
        (_a2 = unref(newValue)) == null ? void 0 : _a2.addEventListener(e2, listener, capture);
        (_b2 = unref(oldValue)) == null ? void 0 : _b2.removeEventListener(e2, listener, capture);
      });
    }
  }, { immediate: true });
};

// node_modules/vuestic-ui/dist/es/src/composables/useWindowSize.js
function useWindowSize() {
  const windowSizes = reactive({
    width: void 0,
    height: void 0
  });
  const setCurrentWindowSizes = () => {
    windowSizes.width = window == null ? void 0 : window.innerWidth;
    windowSizes.height = window == null ? void 0 : window.innerHeight;
  };
  const isMounted = computed(isClient);
  watch(isMounted, (newValue) => {
    if (!newValue) {
      return;
    }
    setCurrentWindowSizes();
  }, { immediate: true });
  useEvent("resize", setCurrentWindowSizes, true);
  return { windowSizes };
}

// node_modules/vuestic-ui/dist/es/src/services/dom-functions.js
var addOrUpdateStyleElement = (id, getStyles) => {
  if (!id) {
    throw new Error("Style id is required");
  }
  if (isServer()) {
    return;
  }
  let stylesElement = document.getElementById(id);
  if (stylesElement) {
    stylesElement.innerHTML = getStyles();
  } else {
    stylesElement = document.createElement("style");
    stylesElement.setAttribute("type", "text/css");
    stylesElement.setAttribute("id", id);
    stylesElement.innerHTML = getStyles();
    document.head.append(stylesElement);
  }
};

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/plugin/create-service.js
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var createBreakpointConfigPlugin = (app2) => {
  var _a;
  const globalConfig = (_a = getGlobalProperty(app2, "$vaConfig")) == null ? void 0 : _a.globalConfig;
  if (!globalConfig) {
    return {};
  }
  const breakpointConfig = computed(() => {
    const breakpoint = globalConfig.value.breakpoint;
    return breakpoint != null ? breakpoint : {};
  });
  if (!breakpointConfig.value.enabled) {
    return {};
  }
  if (!breakpointConfig.value.thresholds || !Object.values(breakpointConfig.value.thresholds).length) {
    return {};
  }
  const { windowSizes } = useWindowSize();
  const isMounted = computed(isClient);
  const currentBreakpoint = computed(() => {
    if (!isMounted.value || !windowSizes.width) {
      return;
    }
    return Object.entries(breakpointConfig.value.thresholds).reduce((acc, [key, value]) => {
      if (windowSizes.width >= value) {
        acc = key;
      }
      return acc;
    }, "xs");
  });
  const screenClasses = computed(() => Object.keys(breakpointConfig.value.thresholds).reduce((acc, threshold) => {
    acc[threshold] = `va-screen-${threshold}`;
    return acc;
  }, {}));
  const generateHelpersMediaCss = () => {
    let result2 = "";
    Object.values(breakpointConfig.value.thresholds).forEach((thresholdValue, index) => {
      result2 += `@media screen and (min-width: ${thresholdValue}px) {`;
      result2 += `:root { --va-media-ratio: ${(index + 1) * 0.2} }`;
      result2 += "}\n";
    });
    return result2;
  };
  const uniqueId2 = computed(generateUniqueId);
  addOrUpdateStyleElement(`va-helpers-media-${uniqueId2.value}`, generateHelpersMediaCss);
  const getDocument = useDocument();
  watch(currentBreakpoint, (newValue) => {
    if (!newValue || !breakpointConfig.value.bodyClass || !getDocument.value) {
      return;
    }
    getDocument.value.body.classList.forEach((className) => {
      if (Object.values(screenClasses.value).includes(className)) {
        getDocument.value.body.classList.remove(className);
      }
    });
    getDocument.value.body.classList.add(screenClasses.value[newValue]);
  }, { immediate: true });
  const breakpointHelpers = computed(() => {
    const isXs = currentBreakpoint.value === "xs";
    const isSm = currentBreakpoint.value === "sm";
    const isMd = currentBreakpoint.value === "md";
    const isLg = currentBreakpoint.value === "lg";
    const isXl = currentBreakpoint.value === "xl";
    return {
      xs: isXs,
      sm: isSm,
      md: isMd,
      lg: isLg,
      xl: isXl,
      smUp: isSm || isMd || isLg || isXl,
      mdUp: isMd || isLg || isXl,
      lgUp: isLg || isXl,
      smDown: isXs || isSm,
      mdDown: isXs || isSm || isMd,
      lgDown: isXs || isSm || isMd || isLg
    };
  });
  const result = computed(() => __spreadValues2({
    width: windowSizes.width,
    height: windowSizes.height,
    current: currentBreakpoint.value,
    thresholds: breakpointConfig.value.thresholds
  }, breakpointHelpers.value));
  return new Proxy({}, {
    ownKeys: () => Reflect.ownKeys(result.value),
    getOwnPropertyDescriptor: (_2, key) => Reflect.getOwnPropertyDescriptor(result.value, key),
    get: (_2, key, receiver) => Reflect.get(result.value, key, receiver)
  });
};

// node_modules/vuestic-ui/dist/es/src/services/breakpoint/plugin/index.js
var BreakpointConfigPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    const breakpointConfig = createBreakpointConfigPlugin(app2);
    app2.provide(vaBreakpointSymbol, breakpointConfig);
    defineGlobalProperty(app2, "$vaBreakpoint", breakpointConfig);
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-toast/toast.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createProxyComponent.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-config/VaConfig.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useComponentPreset.js
var useComponentPresetProp = {
  preset: {
    type: String,
    default: void 0
  }
};

// node_modules/vuestic-ui/dist/es/src/components/va-config/VaConfig.js
var __defProp3 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp3.call(b2, prop))
      __defNormalProp3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b2)) {
      if (__propIsEnum3.call(b2, prop))
        __defNormalProp3(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var LocalConfigKey = Symbol("LocalConfigKey");
var CONFIGS_DEFAULT = computed(() => []);
function useLocalConfig() {
  return inject(LocalConfigKey, CONFIGS_DEFAULT);
}
var VaConfig = defineComponent({
  name: "VaConfig",
  props: __spreadProps(__spreadValues3({}, useComponentPresetProp), {
    components: { type: Object, default: () => ({}) }
  }),
  setup(props) {
    const { components } = toRefs(props);
    const prevChain = useLocalConfig();
    const nextChain = computed(() => [...prevChain.value, components.value]);
    provide(LocalConfigKey, nextChain);
    return {};
  },
  render() {
    return this.$slots.default ? this.$slots.default() : null;
  }
});

// node_modules/vuestic-ui/dist/es/src/services/component-config/component-config.js
init_vue_runtime_esm_bundler();
var __defProp4 = Object.defineProperty;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp4.call(b2, prop))
      __defNormalProp4(a2, prop, b2[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b2)) {
      if (__propIsEnum4.call(b2, prop))
        __defNormalProp4(a2, prop, b2[prop]);
    }
  return a2;
};
var useComponentConfigProps = (component, originalProps) => {
  const localConfig = useLocalConfig();
  const { globalConfig } = useGlobalConfig();
  const instancePreset = computed(() => originalProps.preset);
  const getPresetProps = (presetName) => {
    var _a, _b, _c;
    return (_c = (_b = (_a = globalConfig.value.components) == null ? void 0 : _a.presets) == null ? void 0 : _b[component.name]) == null ? void 0 : _c[presetName];
  };
  return computed(() => {
    var _a, _b;
    const globalConfigProps = __spreadValues4(__spreadValues4({}, (_a = globalConfig.value.components) == null ? void 0 : _a.all), (_b = globalConfig.value.components) == null ? void 0 : _b[component.name]);
    const localConfigProps = localConfig.value.reduce((finalConfig, config) => config[component.name] ? __spreadValues4(__spreadValues4({}, finalConfig), config[component.name]) : finalConfig, {});
    const presetName = instancePreset.value || localConfigProps.preset || globalConfigProps.preset;
    const presetProps = presetName && getPresetProps(presetName);
    return __spreadValues4(__spreadValues4(__spreadValues4({}, globalConfigProps), localConfigProps), presetProps);
  });
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/createProxyComponent.js
var toCamelCase = (str) => str.replace(/-([a-z])/g, (g2) => g2[1].toUpperCase());
var findCamelCased = (obj, key) => {
  const found = Object.keys(obj).find((k2) => toCamelCase(k2) === key);
  return found && obj[found];
};
var createPropsWithCustomConfig = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  return new Proxy(instanceProps, {
    get: (target, key) => {
      var _a;
      if (typeof key !== "string") {
        return target[key];
      }
      const incomingProps = instance.vnode.props || {};
      const originalProp = target[key];
      const propFromConfig = (_a = propsFromConfig.value) == null ? void 0 : _a[key];
      const incomingProp = findCamelCased(incomingProps, key);
      if (incomingProp !== void 0) {
        return originalProp;
      }
      if (propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};
var patchInstanceProps = (instance, props) => {
  instance.props = props;
};
var createProxyComponent = (component) => {
  const customSetup = (originalProps, ctx) => {
    var _a;
    const instance = getCurrentInstance();
    const propsFromConfig = useComponentConfigProps(component, originalProps);
    const props = createPropsWithCustomConfig(instance, propsFromConfig);
    patchInstanceProps(instance, props);
    return (_a = component.setup) == null ? void 0 : _a.call(component, shallowReadonly(props), ctx);
  };
  return new Proxy(component, {
    get(target, key) {
      if (key === "setup") {
        return customSetup;
      }
      return target[key];
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/services/config-transport/withConfigTransport.js
var CLASS_COMPONENT_KEY = "__c";
var patchClassComponent = (component) => {
  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
  return component;
};
var withConfigTransport = (component) => {
  if ("setup" in component) {
    return createProxyComponent(component);
  } else if (CLASS_COMPONENT_KEY in component) {
    return patchClassComponent(component);
  } else {
    component.setup = () => ({});
    return createProxyComponent(component);
  }
};

// node_modules/vuestic-ui/dist/es/src/components/va-toast/VaToast.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useTextColor.js
init_vue_runtime_esm_bundler();
var useTextColor = (componentColor, isTransparent2 = false) => {
  const { props } = getCurrentInstance();
  const { getColor, getTextColor } = useColors();
  const textColorComputed = computed(() => {
    if (props.textColor) {
      return getColor(props.textColor);
    }
    const componentColorHex = getColor(unref(componentColor) || props.color);
    return unref(isTransparent2) ? componentColorHex : getColor(getTextColor(componentColorHex));
  });
  return { textColorComputed };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTimer.js
var useTimer = () => {
  let timer;
  const start = (...args) => {
    timer = window.setTimeout(...args);
    return timer;
  };
  const clear = () => timer && window.clearTimeout(timer);
  return {
    start,
    clear
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useTranslation.js
init_vue_runtime_esm_bundler();
var applyI18nTemplate = (key, values) => {
  if (!values) {
    return key;
  }
  Object.keys(values).forEach((valueKey) => {
    key = key.replace(`{${valueKey}}`, String(values[valueKey]));
  });
  return key;
};
var useTranslation = () => {
  const { globalConfig, mergeGlobalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  return {
    tp: (key) => {
      if (!key) {
        return void 0;
      }
      if (key.startsWith("$t:")) {
        return config.value[key.slice(3)] || key;
      }
      return key;
    },
    t(key, values) {
      const translated = config.value[key];
      if (!translated) {
        return key;
      }
      return applyI18nTemplate(translated, values) || key;
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-icon/VaIcon.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/services/icon-config/utils/regex.js
var isMatchRegex = (str, regex) => {
  return regex.test(str);
};
var regexGroupsValues = (str, regex) => {
  if (typeof regex !== "string" && regex.global) {
    return [...str.matchAll(regex)].map((g2) => g2.slice(1));
  }
  const match = str.match(regex) || [];
  if (!match) {
    return [];
  }
  if (match.length > 1) {
    return match.slice(1);
  }
  return match;
};

// node_modules/vuestic-ui/dist/es/src/services/icon-config/utils/dynamic-segment.js
var __defProp5 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp5.call(b2, prop))
      __defNormalProp5(a2, prop, b2[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b2)) {
      if (__propIsEnum5.call(b2, prop))
        __defNormalProp5(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
var dynamicSegmentRegex = /{[^}]*}/g;
var dynamicSegmentStringToRegex = (template) => {
  return template.replace(dynamicSegmentRegex, "(.*)");
};
var dynamicSegmentsNames = (template) => {
  return (template.match(dynamicSegmentRegex) || []).map((g2) => g2.replace(/{|}/g, ""));
};
var dynamicSegmentsValues = (str, template) => {
  return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
var dynamicSegments = (str, template) => {
  const params = dynamicSegmentsNames(template);
  const values = dynamicSegmentsValues(str, template);
  return params.reduce((acc, paramValue, i2) => __spreadProps2(__spreadValues5({}, acc), { [paramValue]: values[i2] }), {});
};
var strictMatch = (str, regex) => {
  return (str.match(regex) || [])[0] === str;
};
var isMatchDynamicSegments = (str, template) => {
  const templateRegex = dynamicSegmentStringToRegex(template);
  return strictMatch(str, new RegExp(templateRegex));
};

// node_modules/vuestic-ui/dist/es/src/services/icon-config/types.js
var isIconConfigurationString = (config) => {
  return typeof config.name === "string";
};
var isIconConfigurationRegex = (config) => {
  return config.name instanceof RegExp;
};

// node_modules/vuestic-ui/dist/es/src/services/icon-config/icon-helpers.js
var isMatchConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return isMatchDynamicSegments(iconName, iconConfiguration.name);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return isMatchRegex(iconName, iconConfiguration.name);
  }
  return false;
};
var resolveIconConfigurationString = (iconName, iconConfiguration) => {
  const args = dynamicSegments(iconName, iconConfiguration.name);
  return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
var resolveIconConfigurationRegex = (iconName, iconConfig) => {
  if (iconConfig.name.global) {
    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
  }
  const args = regexGroupsValues(iconName, iconConfig.name);
  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
var resolveIconConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return resolveIconConfigurationString(iconName, iconConfiguration);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return resolveIconConfigurationRegex(iconName, iconConfiguration);
  }
  throw Error("Unknown icon config");
};
var findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  const matchedConfig = globalIconConfig.find((config) => {
    if (namesToIgnore.includes(config.name.toString())) {
      return false;
    }
    return isMatchConfiguration(iconName, config);
  });
  if (!matchedConfig) {
    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
  }
  return matchedConfig;
};
var findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  if (!iconName) {
    return;
  }
  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
  const resolvedIconConfiguration = merge_1(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
  return merge_1(findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore), resolvedIconConfiguration);
};
var iconPropsFromIconConfiguration = (iconConfiguration) => {
  const junkKeys = ["name", "to", "resolve", "resolveFromRegex"];
  const configuration = iconConfiguration;
  junkKeys.forEach((key) => {
    delete configuration[key];
  });
  return configuration;
};
var getIconConfiguration = (name, iconConfig) => {
  const configuration = findIconConfiguration(name, iconConfig);
  if (configuration === void 0) {
    return {};
  }
  return iconPropsFromIconConfiguration(configuration);
};

// node_modules/vuestic-ui/dist/es/src/services/icon-config/icon-config-hooks.js
var useIcons = (props) => {
  const { getGlobalConfig } = useGlobalConfig();
  const getIconConfig = () => {
    return getGlobalConfig().icons || [];
  };
  return {
    getIcon: (name) => getIconConfiguration(name, getIconConfig())
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useSize.js
init_vue_runtime_esm_bundler();
var sizesConfig = {
  defaultSize: 48,
  sizes: {
    small: 32,
    medium: 48,
    large: 64
  }
};
var fontSizesConfig = {
  defaultSize: 1,
  sizes: {
    small: 0.75,
    medium: 1,
    large: 1.25
  }
};
var useSizeProps = {
  size: {
    type: [String, Number],
    default: "",
    validator: (size) => {
      return typeof size === "string" || typeof size === "number";
    }
  },
  sizesConfig: {
    type: Object,
    default: () => sizesConfig
  },
  fontSizesConfig: {
    type: Object,
    default: () => fontSizesConfig
  }
};
var fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
var convertToRem = (px) => px / 16 - 0.5;
var useSize = (props, componentName2 = ((_a) => (_a = getCurrentInstance()) == null ? void 0 : _a.type.name)()) => {
  const { getGlobalConfig } = useGlobalConfig();
  const sizesConfigGlobal = computed(() => {
    var _a2, _b;
    return componentName2 ? (_b = (_a2 = getGlobalConfig().components) == null ? void 0 : _a2[componentName2]) == null ? void 0 : _b.sizesConfig : void 0;
  });
  const sizeComputed = computed(() => {
    var _a2, _b, _c;
    const { defaultSize, sizes } = props.sizesConfig;
    const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) == null ? void 0 : _a2.defaultSize;
    if (!props.size) {
      return `${defaultSizeGlobal || defaultSize}px`;
    }
    if (typeof props.size === "string") {
      const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) == null ? void 0 : _b.sizes) == null ? void 0 : _c[props.size];
      const sizeFromProps = sizes[props.size];
      if (sizeFromGlobalConfig) {
        return `${sizeFromGlobalConfig}px`;
      }
      if (sizeFromProps) {
        return `${sizeFromProps}px`;
      }
      return props.size;
    }
    return `${props.size}px`;
  });
  const fontSizeInRem = computed(() => {
    const { defaultSize, sizes } = props.fontSizesConfig;
    if (!props.size) {
      return defaultSize;
    }
    if (typeof props.size === "string") {
      if (props.size in sizes) {
        return sizes[props.size];
      }
      const fontSizeParsed = props.size.match(fontRegex);
      if (!fontSizeParsed || !fontSizeParsed.groups) {
        throw new Error("Size prop should be either valid string or number");
      }
      const { extension, fontSize } = fontSizeParsed.groups;
      return extension === "rem" ? +fontSize : convertToRem(+fontSize);
    }
    return convertToRem(props.size);
  });
  const fontSizeComputed = computed(() => `${fontSizeInRem.value}rem`);
  return {
    sizeComputed,
    fontSizeComputed,
    fontSizeInRem
  };
};

// node_modules/vuestic-ui/dist/es/plugin-vue_export-helper.js
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

// node_modules/vuestic-ui/dist/es/src/components/va-icon/VaIcon.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-icon/VaIcon.css";
var __defProp6 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp6.call(b2, prop))
      __defNormalProp6(a2, prop, b2[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b2)) {
      if (__propIsEnum6.call(b2, prop))
        __defNormalProp6(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps3 = (a2, b2) => __defProps3(a2, __getOwnPropDescs3(b2));
var _sfc_main = defineComponent({
  name: "VaIcon",
  props: __spreadProps3(__spreadValues6(__spreadValues6({}, useSizeProps), useComponentPresetProp), {
    name: { type: String, default: "" },
    tag: { type: String },
    component: { type: Object },
    color: { type: String },
    rotation: { type: [String, Number] },
    spin: { type: [String, Boolean] },
    flip: {
      type: String,
      default: "off",
      validator: (value) => ["off", "horizontal", "vertical", "both"].includes(value)
    }
  }),
  setup(props, { attrs }) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const { getIcon } = useIcons();
    const iconConfig = computed(() => getIcon(props.name));
    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || "i");
    const computedAttrs = computed(() => __spreadValues6(__spreadValues6({}, iconConfig.value.attrs), omit_1(attrs, ["class"])));
    const getSpinClass = (spin) => {
      if (spin === void 0 || spin === false) {
        return;
      }
      return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
    };
    const computedClass = computed(() => {
      var _a;
      return [
        iconConfig.value.class,
        getSpinClass((_a = props.spin) != null ? _a : iconConfig.value.spin)
      ];
    });
    const transformStyle = computed(() => {
      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : "";
      const flipY = props.flip === "vertical" || props.flip === "both" ? -1 : 1;
      const flipX = props.flip === "horizontal" || props.flip === "both" ? -1 : 1;
      const scale = props.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
      return `${scale} ${rotation}`.trim();
    });
    const computedStyle = computed(() => ({
      transform: transformStyle.value,
      cursor: attrs.onClick ? "pointer" : null,
      color: props.color ? getColor(props.color, void 0, true) : iconConfig.value.color,
      fontSize: sizeComputed.value,
      height: sizeComputed.value,
      lineHeight: sizeComputed.value
    }));
    const tabindexComputed = computed(() => {
      var _a;
      return (_a = attrs.tabindex) != null ? _a : -1;
    });
    const ariaHiddenComputed = computed(() => attrs.role !== "button" || tabindexComputed.value < 0);
    return {
      iconConfig,
      computedTag,
      computedAttrs,
      computedClass,
      computedStyle,
      ariaHiddenComputed
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.computedTag), mergeProps({
    class: ["va-icon", _ctx.computedClass],
    style: _ctx.computedStyle,
    "aria-hidden": _ctx.ariaHiddenComputed,
    notranslate: ""
  }, _ctx.computedAttrs), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        _ctx.iconConfig.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.iconConfig.content), 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ]),
    _: 3
  }, 16, ["class", "style", "aria-hidden"]);
}
var VaIcon = _export_sfc(_sfc_main, [["render", _sfc_render]]);

// node_modules/vuestic-ui/dist/es/src/components/va-toast/VaToast.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-toast/VaToast.css";
var __defProp7 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp7.call(b2, prop))
      __defNormalProp7(a2, prop, b2[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b2)) {
      if (__propIsEnum7.call(b2, prop))
        __defNormalProp7(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps4 = (a2, b2) => __defProps4(a2, __getOwnPropDescs4(b2));
var VaToastRenderer = defineComponent({
  name: "VaToastRenderer",
  props: {
    render: { type: Function, required: true }
  },
  setup: (props) => () => props.render()
});
var _sfc_main2 = defineComponent({
  name: "VaToast",
  components: { VaIcon, VaToastRenderer },
  emits: ["on-click", "on-close"],
  props: __spreadProps4(__spreadValues7({}, useComponentPresetProp), {
    title: { type: String, default: "" },
    offsetY: { type: Number, default: 16 },
    offsetX: { type: Number, default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: Number, default: 5e3 },
    color: { type: String, default: "" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-left", "bottom-right", "bottom-left"].includes(value)
    },
    render: { type: Function }
  }),
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const visible = ref(false);
    const positionX = computed(() => {
      return props.position.includes("right") ? "right" : "left";
    });
    const positionY = computed(() => {
      return props.position.includes("top") ? "top" : "bottom";
    });
    const toastClasses = computed(() => [
      props.customClass,
      props.multiLine ? "va-toast--multiline" : ""
    ]);
    const toastStyles = computed(() => ({
      [positionY.value]: `${props.offsetY}px`,
      [positionX.value]: `${props.offsetX}px`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    const computedMessage = computed(() => typeof props.message === "function" ? props.message() : props.message);
    const destroyElement = () => {
      var _a, _b;
      (_a = rootElement.value) == null ? void 0 : _a.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) == null ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props.onClick === "function") {
        props.onClick();
      } else {
        emit("on-click");
      }
    };
    const onToastClose = () => {
      var _a;
      visible.value = false;
      (_a = rootElement.value) == null ? void 0 : _a.addEventListener("transitionend", destroyElement);
      if (typeof props.onClose === "function") {
        props.onClose();
      } else {
        emit("on-close");
      }
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (props.duration > 0) {
        timer.start(() => visible.value && onToastClose(), props.duration);
      }
    };
    onMounted(() => {
      visible.value = true;
      startTimer();
    });
    return __spreadProps4(__spreadValues7({}, useTranslation()), {
      visible,
      toastClasses,
      toastStyles,
      computedMessage,
      onToastClick,
      onToastClose,
      startTimer,
      clearTimer
    });
  }
});
var _hoisted_1 = ["role"];
var _hoisted_2 = { class: "va-toast__group" };
var _hoisted_3 = ["textContent"];
var _hoisted_4 = { class: "va-toast__content" };
var _hoisted_5 = ["innerHTML"];
var _hoisted_6 = ["textContent"];
var _hoisted_7 = {
  key: 1,
  class: "va-toast__content"
};
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaToastRenderer = resolveComponent("VaToastRenderer");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(Transition, { name: "va-toast-fade" }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        ref: "rootElement",
        role: _ctx.$props.closeable ? "alertdialog" : "alert",
        class: normalizeClass(["va-toast", _ctx.toastClasses]),
        style: normalizeStyle(_ctx.toastStyles),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args)),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onToastClick && _ctx.onToastClick(...args))
      }, [
        createBaseVNode("div", _hoisted_2, [
          _ctx.$props.title ? (openBlock(), createElementBlock("h2", {
            key: 0,
            class: "va-toast__title",
            textContent: toDisplayString(_ctx.$props.title)
          }, null, 8, _hoisted_3)) : createCommentVNode("", true),
          withDirectives(createBaseVNode("div", _hoisted_4, [
            _ctx.$props.dangerouslyUseHtmlString ? (openBlock(), createElementBlock("div", {
              key: 0,
              innerHTML: _ctx.computedMessage
            }, null, 8, _hoisted_5)) : (openBlock(), createElementBlock("p", {
              key: 1,
              textContent: toDisplayString(_ctx.computedMessage)
            }, null, 8, _hoisted_6))
          ], 512), [
            [vShow, _ctx.$props.message]
          ]),
          _ctx.$props.render ? (openBlock(), createElementBlock("div", _hoisted_7, [
            createVNode(_component_VaToastRenderer, {
              render: _ctx.$props.render
            }, null, 8, ["render"])
          ])) : createCommentVNode("", true),
          _ctx.$props.closeable ? (openBlock(), createBlock(_component_va_icon, {
            key: 2,
            class: "va-toast__close-icon",
            role: "button",
            "aria-label": _ctx.t("closeToast"),
            tabindex: "0",
            size: "small",
            name: _ctx.$props.icon,
            onClick: withModifiers(_ctx.onToastClose, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.onToastClose, ["stop"]), ["enter"])
          }, null, 8, ["aria-label", "name", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ])
      ], 46, _hoisted_1), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1
  });
}
var _VaToast = _export_sfc(_sfc_main2, [["render", _sfc_render2]]);

// node_modules/vuestic-ui/dist/es/src/components/va-toast/index.js
var VaToast = withConfigTransport(_VaToast);

// node_modules/vuestic-ui/dist/es/src/components/va-toast/toast.js
var __defProp8 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp8.call(b2, prop))
      __defNormalProp8(a2, prop, b2[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b2)) {
      if (__propIsEnum8.call(b2, prop))
        __defNormalProp8(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps5 = (a2, b2) => __defProps5(a2, __getOwnPropDescs5(b2));
var GAP = 5;
var seed = 1;
getGlobal().vaToastInstances = [];
var getTranslateValue = (item, position) => {
  if (item.el) {
    const direction = position.includes("bottom") ? -1 : 1;
    return (item.el.offsetHeight + GAP) * direction;
  }
  return 0;
};
var getNewTranslateValue = (transformY, redundantHeight, position) => {
  const direction = position.includes("bottom") ? -1 : 1;
  return parseInt(transformY, 10) - (redundantHeight + GAP) * direction;
};
var getNodeProps = (vNode) => {
  var _a;
  return ((_a = vNode.component) == null ? void 0 : _a.props) || {};
};
var closeNotification = (targetInstance, destroyElementFn) => {
  var _a;
  if (!targetInstance) {
    return;
  }
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
  if (targetInstanceIndex < 0) {
    return;
  }
  const nodeProps = getNodeProps(targetInstance);
  const {
    offsetX: targetOffsetX,
    offsetY: targetOffsetY,
    position: targetPosition
  } = nodeProps;
  const redundantHeight = (_a = targetInstance.el) == null ? void 0 : _a.offsetHeight;
  destroyElementFn();
  getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
    if (instance === targetInstance) {
      return acc;
    }
    if (instance.component) {
      const { offsetX, offsetY, position } = getNodeProps(instance);
      const isNextInstance = index > targetInstanceIndex && targetOffsetX === offsetX && targetOffsetY === offsetY && targetPosition === position;
      if (isNextInstance && instance.el && redundantHeight) {
        const [_2, transformY] = instance.el.style.transform.match(/[\d-]+(?=px)/g);
        const transformYNew = getNewTranslateValue(transformY, redundantHeight, position);
        instance.el.style.transform = `translate(0, ${transformYNew}px)`;
      }
    }
    return [...acc, instance];
  }, []);
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
  }
};
var destroy = (el, node) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount = (component, {
  props,
  children,
  element,
  appContext
} = {}) => {
  let el = element;
  let vNode;
  const onClose = () => {
    closeNotification(vNode, () => destroy(el));
    if (props == null ? void 0 : props.onClose) {
      props.onClose();
    }
  };
  vNode = createVNode(component, __spreadProps5(__spreadValues8({}, props), { onClose }), children);
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  } else if (typeof document !== "undefined") {
    render(vNode, el = document.createElement("div"));
  }
  return { vNode, el };
};
var closeAllNotifications = (appContext) => {
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  getGlobal().vaToastInstances.forEach((instance) => {
    if (appContext && instance.appContext !== appContext) {
      return;
    }
    getNodeProps(instance).onClose();
  });
};
var closeById = (id) => {
  const targetInstance = getGlobal().vaToastInstances.find((instance) => {
    var _a;
    return ((_a = instance.el) == null ? void 0 : _a.id) === id;
  });
  if (targetInstance) {
    const nodeProps = getNodeProps(targetInstance);
    nodeProps.onClose();
  }
};
var getToastOptions = (options) => {
  if (typeof options === "string") {
    return {
      message: options
    };
  }
  return options;
};
var createToastInstance = (customProps, appContext) => {
  const { vNode, el } = mount(VaToast, { appContext, props: getToastOptions(customProps) });
  const nodeProps = getNodeProps(vNode);
  if (el && vNode.el && nodeProps) {
    document.body.appendChild(el.childNodes[0]);
    const { offsetX, offsetY, position } = nodeProps;
    vNode.el.style.display = "flex";
    vNode.el.id = "notification_" + seed;
    let transformY = 0;
    getGlobal().vaToastInstances.filter((item) => {
      const {
        offsetX: itemOffsetX,
        offsetY: itemOffsetY,
        position: itemPosition
      } = getNodeProps(item);
      return itemOffsetX === offsetX && itemOffsetY === offsetY && position === itemPosition;
    }).forEach((item) => {
      transformY += getTranslateValue(item, position);
    });
    vNode.el.style.transform = `translate(0, ${transformY}px)`;
    seed += 1;
    getGlobal().vaToastInstances.push(vNode);
    return vNode.el.id;
  }
  return null;
};

// node_modules/vuestic-ui/dist/es/src/components/va-toast/plugin/index.js
var createVaToastPlugin = (app2) => ({
  init(options) {
    return createToastInstance(options, app2 == null ? void 0 : app2._context);
  },
  close(id) {
    closeById(id);
  },
  closeAll(allApps = false) {
    closeAllNotifications(allApps ? void 0 : app2 == null ? void 0 : app2._context);
  }
});
var VaToastPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    defineGlobalProperty(app2, "$vaToast", createVaToastPlugin(app2));
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/plugin/index.js
var vaDropdownPlugin = {
  closeDropdown() {
    let vm = this;
    while (vm = vm.$parent) {
      const name = vm.$options.name;
      if (name === "VaDropdown") {
        vm.hide();
        break;
      }
    }
  }
};
var VaDropdownPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    defineGlobalProperty(app2, "$closeDropdown", vaDropdownPlugin.closeDropdown);
    defineGlobalProperty(app2, "$vaDropdown", vaDropdownPlugin);
  }
}));

// node_modules/vuestic-ui/dist/es/src/components/va-modal/VaModal.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useModalLevel.js
init_vue_runtime_esm_bundler();
var modalsStack = shallowReactive([]);
var useModalLevel = () => {
  const modalId = uniqueId_1();
  const modalLevel = computed(() => modalsStack.findIndex(({ id }) => id === modalId));
  const registerModal = () => {
    if (modalLevel.value !== -1) {
      return;
    }
    modalsStack.push({
      id: modalId
    });
  };
  const unregisterModal = () => {
    if (modalLevel.value === -1) {
      return;
    }
    modalsStack.splice(modalLevel.value, 1);
  };
  const isTopLevelModal = computed(() => modalLevel.value !== -1 && modalLevel.value === modalsStack.length - 1);
  const isLowestLevelModal = computed(() => modalLevel.value === 0);
  const isMoreThenOneModalOpen = computed(() => modalsStack.length > 1);
  return {
    modalId,
    modalLevel,
    registerModal,
    unregisterModal,
    isTopLevelModal,
    isLowestLevelModal,
    isMoreThenOneModalOpen
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useStateful.js
init_vue_runtime_esm_bundler();
var useStatefulProps = {
  stateful: { type: Boolean, default: false },
  modelValue: { type: void 0 }
};
var createStatefulProps = (modelValueType, statefulDefault = false) => {
  return {
    stateful: { type: Boolean, default: statefulDefault },
    modelValue: { type: modelValueType }
  };
};
var useStatefulEmits = ["update:modelValue"];
var useStateful = (props, emit, key = "modelValue", options = {}) => {
  const { defaultValue, eventName } = options;
  const event = eventName || `update:${key.toString()}`;
  const valueState = ref(defaultValue === void 0 ? props[key] : defaultValue);
  let unwatchModelValue;
  const watchModelValue = () => {
    unwatchModelValue = watch(() => props[key], (modelValue) => {
      valueState.value = modelValue;
    });
  };
  watch(() => props.stateful, (stateful) => {
    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();
  }, { immediate: true });
  const valueComputed = computed({
    get: () => {
      if (props.stateful) {
        return valueState.value;
      }
      return props[key];
    },
    set: (value) => {
      if (props.stateful) {
        valueState.value = value;
      }
      emit(event, value);
    }
  });
  return { valueComputed };
};

// node_modules/vuestic-ui/dist/es/src/composables/useWindow.js
var useWindow = () => useClientOnly(() => window);

// node_modules/vuestic-ui/dist/es/src/composables/useTrapFocus.js
var FOCUSABLE_ELEMENTS_SELECTOR = ":where(a, button, input, textarea, select):not([disabled]), *[tabindex]";
var trapInEl = null;
var useTrapFocus = () => {
  const document2 = useDocument();
  const window3 = useWindow();
  let focusableElements = [];
  let firstFocusableElement = null;
  let lastFocusableElement = null;
  let isFocusTrapped = false;
  const focusFirstElement = () => {
    firstFocusableElement == null ? void 0 : firstFocusableElement.focus();
  };
  const focusLastElement = () => {
    lastFocusableElement == null ? void 0 : lastFocusableElement.focus();
  };
  const onKeydown = (evt) => {
    var _a, _b;
    const isTabPressed = evt.code === "Tab";
    const isShiftPressed = evt.shiftKey;
    if (!isTabPressed) {
      return;
    }
    if (!isFocusTrapped) {
      isFocusTrapped = true;
      evt.preventDefault();
      isShiftPressed ? focusLastElement() : focusFirstElement();
      return;
    }
    if (((_a = document2.value) == null ? void 0 : _a.activeElement) === lastFocusableElement && !isShiftPressed) {
      evt.preventDefault();
      focusFirstElement();
      return;
    }
    if (((_b = document2.value) == null ? void 0 : _b.activeElement) === firstFocusableElement && isShiftPressed) {
      evt.preventDefault();
      focusLastElement();
    }
  };
  const trapFocusIn = (el) => {
    trapInEl = el;
    freeFocus();
    trapFocus();
  };
  const trapFocus = () => {
    var _a;
    if (!trapInEl) {
      return;
    }
    focusableElements = Array.from(trapInEl.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR));
    firstFocusableElement = focusableElements[0];
    lastFocusableElement = focusableElements[focusableElements.length - 1];
    (_a = window3.value) == null ? void 0 : _a.addEventListener("keydown", onKeydown);
  };
  const freeFocus = () => {
    var _a;
    focusableElements = [];
    firstFocusableElement = null;
    lastFocusableElement = null;
    isFocusTrapped = false;
    (_a = window3.value) == null ? void 0 : _a.removeEventListener("keydown", onKeydown);
  };
  return {
    trapFocus,
    freeFocus,
    trapFocusIn
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/VaButton.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useBem.js
init_vue_runtime_esm_bundler();
var useBem = (prefix2, modifiers) => {
  const modifiersList = computed(() => isFunction_1(modifiers) ? modifiers() : unref(modifiers));
  const computedBemClassesObject = computed(() => {
    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {
      if (value) {
        classesObj[`${prefix2}--${kebabCase_1(modifierName)}`] = true;
      }
      return classesObj;
    }, {});
  });
  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));
  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(" "));
  return new Proxy({}, {
    ownKeys() {
      return Reflect.ownKeys(computedBemClassesObject.value);
    },
    getOwnPropertyDescriptor(_2, key) {
      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);
    },
    get(_2, key, receiver) {
      switch (key) {
        case "asArray":
          return computedBemClassesArray;
        case "asString":
          return computedBemClassesString;
        case "asObject":
          return computedBemClassesObject;
        default:
          return Reflect.get(computedBemClassesObject.value, key, receiver);
      }
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocus.js
init_vue_runtime_esm_bundler();
var useFocusEmits = ["focus", "blur"];
function useFocus(el, emit) {
  const isFocused = ref(false);
  const onFocus = (e2) => {
    isFocused.value = true;
    emit == null ? void 0 : emit("focus", e2);
  };
  const onBlur = (e2) => {
    isFocused.value = false;
    emit == null ? void 0 : emit("blur", e2);
  };
  const focus = () => {
    var _a;
    (_a = el == null ? void 0 : el.value) == null ? void 0 : _a.focus();
  };
  const blur = () => {
    var _a;
    (_a = el == null ? void 0 : el.value) == null ? void 0 : _a.blur();
  };
  let element;
  onMounted(() => {
    var _a, _b;
    element = (_b = (_a = el == null ? void 0 : el.value) == null ? void 0 : _a.$el) != null ? _b : el == null ? void 0 : el.value;
    if (element) {
      element.addEventListener("focus", onFocus);
      element.addEventListener("blur", onBlur);
    }
  });
  onBeforeUnmount(() => {
    if (element) {
      element.removeEventListener("focus", onFocus);
      element.removeEventListener("blur", onBlur);
    }
  });
  return {
    isFocused,
    onFocus,
    onBlur,
    focus,
    blur
  };
}

// node_modules/vuestic-ui/dist/es/src/composables/useHover.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useHTMLElement.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useTemplateRef.js
init_vue_runtime_esm_bundler();
var useTemplateRef = (key) => {
  const vm = getCurrentInstance();
  const el = shallowRef();
  const updateEl = () => {
    var _a;
    el.value = (_a = vm.proxy) == null ? void 0 : _a.$refs[key];
  };
  onMounted(updateEl);
  onUpdated(updateEl);
  onBeforeUnmount(updateEl);
  return el;
};

// node_modules/vuestic-ui/dist/es/src/composables/useHTMLElement.js
var extractHTMLElement = (el) => el && "$el" in el ? el.$el : el;
var useHTMLElement = (key) => {
  if (isRef(key)) {
    return computed({
      get() {
        return extractHTMLElement(key.value);
      },
      set(value) {
        key.value = value;
      }
    });
  }
  if (key) {
    const el2 = useTemplateRef(key);
    return computed({
      get() {
        return extractHTMLElement(el2.value);
      },
      set(value) {
        el2.value = value;
      }
    });
  }
  const el = shallowRef();
  return computed({
    set(value) {
      el.value = extractHTMLElement(value);
    },
    get() {
      return el.value;
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useHover.js
function useHover(el, disabled) {
  const isHovered = ref(false);
  const onMouseEnter = () => {
    isHovered.value = true;
  };
  const onMouseLeave = () => {
    isHovered.value = false;
  };
  disabled && watch(disabled, (v2) => {
    if (v2) {
      isHovered.value = false;
    }
  });
  onMounted(() => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    const getTarget = useHTMLElement(el);
    useEvent("mouseenter", onMouseEnter, getTarget);
    useEvent("mouseleave", onMouseLeave, getTarget);
  });
  return { isHovered, onMouseEnter, onMouseLeave };
}

// node_modules/vuestic-ui/dist/es/src/composables/useHoverStyle.js
var useHoverStyleProps = {
  hoverBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  hoverOpacity: { type: Number, default: 0.15 },
  hoverMaskColor: { type: String, default: "textInverted" }
};

// node_modules/vuestic-ui/dist/es/src/composables/useLoading.js
var useLoadingProps = {
  loading: { type: Boolean, default: false }
};

// node_modules/vuestic-ui/dist/es/src/composables/usePressed.js
init_vue_runtime_esm_bundler();
function usePressed(el) {
  const isPressed = ref(false);
  const onMouseDown = () => {
    isPressed.value = true;
  };
  const onMouseUp = () => {
    isPressed.value = false;
  };
  onMounted(() => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    const getTarget = useHTMLElement(el);
    useEvent("mousedown", onMouseDown, getTarget);
    useEvent(["mouseup", "mouseleave"], onMouseUp, getTarget);
  });
  return { isPressed, onMouseDown, onMouseUp };
}

// node_modules/vuestic-ui/dist/es/src/composables/usePressedStyle.js
var usePressedStyleProps = {
  pressedBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  pressedOpacity: { type: Number, default: 0.13 },
  pressedMaskColor: { type: String, default: "textPrimary" }
};

// node_modules/vuestic-ui/dist/es/src/composables/useRouterLink.js
init_vue_runtime_esm_bundler();
var useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: "" },
  replace: { type: Boolean, default: false },
  append: { type: Boolean, default: false },
  exact: { type: Boolean, default: false },
  activeClass: { type: String, default: "" },
  exactActiveClass: { type: String, default: "" },
  href: { type: String, default: "" },
  target: { type: String, default: "" },
  disabled: { type: Boolean, default: false }
};
var useRouterLink = (props) => {
  const globalProperties = computed(() => {
    var _a;
    return (_a = getCurrentInstance()) == null ? void 0 : _a.appContext.config.globalProperties;
  });
  computed(() => {
    var _a;
    return !!((_a = globalProperties.value) == null ? void 0 : _a.$nuxt);
  });
  const vueRouter = computed(() => {
    var _a;
    return (_a = globalProperties.value) == null ? void 0 : _a.$router;
  });
  const vueRoute = computed(() => {
    var _a;
    return (_a = globalProperties.value) == null ? void 0 : _a.$route;
  });
  const tagComputed = computed(() => {
    if (props.disabled) {
      return props.tag;
    }
    if (props.href && !props.to) {
      return "a";
    }
    if (props.to) {
      return "router-link";
    }
    return props.tag || "div";
  });
  const isLinkTag = computed(() => ["a", "router-link", "nuxt-link"].includes(tagComputed.value));
  const linkAttributesComputed = computed(() => {
    if (!isLinkTag.value) {
      return {};
    }
    return tagComputed.value === "a" ? {
      target: props.target,
      href: hrefComputed.value
    } : {
      target: props.target,
      to: props.to,
      replace: props.replace,
      append: props.append,
      activeClass: props.activeClass,
      exact: props.exact,
      exactActiveClass: props.exactActiveClass
    };
  });
  const isActiveRouterLink = computed(() => {
    if (!vueRouter.value || !props.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed(() => {
    var _a;
    return props.href || (props.to ? (_a = vueRouter.value) == null ? void 0 : _a.resolve(props.to, vueRoute.value).href : "");
  });
  return {
    isLinkTag,
    tagComputed,
    hrefComputed,
    isActiveRouterLink,
    linkAttributesComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonBackground.js
init_vue_runtime_esm_bundler();
var useButtonBackground = (colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonBackground` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
  const backgroundColor = computed(() => {
    if (props.plain) {
      return "transparent";
    }
    return props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
  });
  const hoveredBgState = computed(() => !props.plain && isHovered.value);
  const pressedBgState = computed(() => !props.plain && isPressed.value);
  const backgroundColorOpacity = computed(() => {
    if (pressedBgState.value && props.pressedBehavior === "opacity") {
      return props.pressedOpacity;
    }
    if (hoveredBgState.value && props.hoverBehavior === "opacity") {
      return props.hoverOpacity;
    }
    return props.backgroundOpacity;
  });
  const hoveredMaskState = computed(() => hoveredBgState.value && props.hoverBehavior === "mask");
  const pressedMaskState = computed(() => pressedBgState.value && props.pressedBehavior === "mask");
  const backgroundMaskOpacity = computed(() => {
    if (pressedMaskState.value) {
      return props.pressedOpacity;
    }
    if (hoveredMaskState.value) {
      return props.hoverOpacity;
    }
    return 0;
  });
  const backgroundMaskColor = computed(() => {
    if (pressedMaskState.value) {
      return getColor(props.pressedMaskColor);
    }
    if (hoveredMaskState.value) {
      return getColor(props.hoverMaskColor);
    }
    return "transparent";
  });
  return {
    backgroundColor,
    backgroundColorOpacity,
    backgroundMaskOpacity,
    backgroundMaskColor
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonAttributes.js
init_vue_runtime_esm_bundler();
var __defProp9 = Object.defineProperty;
var __getOwnPropSymbols9 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues9 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp9.call(b2, prop))
      __defNormalProp9(a2, prop, b2[prop]);
  if (__getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(b2)) {
      if (__propIsEnum9.call(b2, prop))
        __defNormalProp9(a2, prop, b2[prop]);
    }
  return a2;
};
var useButtonAttributes = (props) => {
  const { linkAttributesComputed, isLinkTag } = useRouterLink(props);
  const typeComputed = computed(() => isLinkTag.value ? void 0 : props.type);
  const buttonAttributesComputed = computed(() => {
    const disabledAttributes = {
      "aria-disabled": !!props.disabled,
      disabled: !!props.disabled
    };
    if (isLinkTag.value) {
      return disabledAttributes;
    }
    return __spreadValues9({
      type: typeComputed.value,
      tabindex: props.loading || props.disabled ? -1 : 0
    }, disabledAttributes);
  });
  return computed(() => __spreadValues9(__spreadValues9({}, linkAttributesComputed.value), buttonAttributesComputed.value));
};

// node_modules/vuestic-ui/dist/es/src/components/va-button/hooks/useButtonTextColor.js
init_vue_runtime_esm_bundler();
var __defProp10 = Object.defineProperty;
var __getOwnPropSymbols10 = Object.getOwnPropertySymbols;
var __hasOwnProp10 = Object.prototype.hasOwnProperty;
var __propIsEnum10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues10 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp10.call(b2, prop))
      __defNormalProp10(a2, prop, b2[prop]);
  if (__getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(b2)) {
      if (__propIsEnum10.call(b2, prop))
        __defNormalProp10(a2, prop, b2[prop]);
    }
  return a2;
};
var useButtonTextColor = (textColorComputed, colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonTextColor` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, colorToRgba: colorToRgba2, getStateMaskGradientBackground: getStateMaskGradientBackground2 } = useColors();
  const plainColorStyles = computed(() => ({
    background: "transparent",
    color: "transparent",
    "-webkit-background-clip": "text",
    "background-clip": "text",
    opacity: getPlainTextOpacity.value
  }));
  const getStateColor = (maskColor, stateOpacity, stateBehavior) => {
    const maskStateColor = getColor(maskColor);
    const res = stateBehavior === "opacity" ? { color: colorToRgba2(textColorComputed.value, stateOpacity) } : { background: getStateMaskGradientBackground2(colorComputed.value, maskStateColor, stateOpacity) };
    return __spreadValues10(__spreadValues10({}, plainColorStyles.value), res);
  };
  const hoverTextColorComputed = computed(() => {
    return getStateColor(props.hoverMaskColor, props.hoverOpacity, props.hoverBehavior);
  });
  const pressedTextColorComputed = computed(() => {
    return getStateColor(props.pressedMaskColor, props.pressedOpacity, props.pressedBehavior);
  });
  const getPlainTextOpacity = computed(() => {
    if (props.disabled) {
      return void 0;
    }
    if (props.textOpacity === 1 || isHovered.value && !isPressed.value) {
      return 1;
    }
    return isPressed.value ? 0.9 : props.textOpacity;
  });
  return computed(() => {
    const defaultColorStyles = {
      color: textColorComputed.value,
      background: "transparent"
    };
    props.plain && Object.assign(defaultColorStyles, plainColorStyles.value, { background: textColorComputed.value });
    if (!props.plain) {
      return defaultColorStyles;
    }
    if (isPressed.value) {
      return pressedTextColorComputed.value;
    }
    if (isHovered.value) {
      return hoverTextColorComputed.value;
    }
    return defaultColorStyles;
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-icon/index.js
var VaIcon2 = withConfigTransport(VaIcon);

// node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/VaProgressCircle.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/VaProgressCircle.css";
var __defProp11 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols11 = Object.getOwnPropertySymbols;
var __hasOwnProp11 = Object.prototype.hasOwnProperty;
var __propIsEnum11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues11 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp11.call(b2, prop))
      __defNormalProp11(a2, prop, b2[prop]);
  if (__getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(b2)) {
      if (__propIsEnum11.call(b2, prop))
        __defNormalProp11(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps6 = (a2, b2) => __defProps6(a2, __getOwnPropDescs6(b2));
var _sfc_main3 = defineComponent({
  name: "VaProgressCircle",
  props: __spreadProps6(__spreadValues11(__spreadValues11({}, useSizeProps), useComponentPresetProp), {
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    thickness: { type: Number, default: 0.06 },
    color: { type: String, default: "primary" }
  }),
  setup(props) {
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const cappedThickness = computed(() => clamp_1(props.thickness, 0, 1) / 2 * 100);
    const radius = computed(() => 20 - 20 * cappedThickness.value / 100);
    const dasharray = computed(() => 2 * Math.PI * radius.value);
    const dashoffset = computed(() => dasharray.value * (1 - clamp_1(props.modelValue, 0, 100) / 100));
    const colorComputed = computed(() => getColor(props.color, void 0, true));
    const { t: t2 } = useTranslation();
    return {
      infoStyle: computed(() => ({ color: colorComputed.value })),
      rootStyle: computed(() => ({
        width: sizeComputed.value,
        height: sizeComputed.value
      })),
      rootClass: computed(() => ({
        "va-progress-circle--indeterminate": props.indeterminate
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        ariaLabel: t2("progressState"),
        ariaValuenow: !props.indeterminate ? props.modelValue : void 0
      })),
      colorComputed,
      radius,
      dasharray,
      dashoffset,
      cappedThickness
    };
  }
});
var _hoisted_12 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
var _hoisted_22 = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-circle", _ctx.rootClass],
    style: _ctx.rootStyle
  }, _ctx.ariaAttributesComputed), [
    (openBlock(), createElementBlock("svg", _hoisted_12, [
      createBaseVNode("circle", {
        class: "va-progress-circle__overlay",
        cx: "50%",
        cy: "50%",
        r: _ctx.radius,
        fill: "none",
        stroke: _ctx.colorComputed,
        "stroke-width": _ctx.cappedThickness + "%",
        "stroke-dasharray": _ctx.dasharray,
        "stroke-dashoffset": _ctx.dashoffset
      }, null, 8, _hoisted_22)
    ])),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
      key: 0,
      style: normalizeStyle(_ctx.infoStyle),
      class: "va-progress-circle__info"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)) : createCommentVNode("", true)
  ], 16);
}
var _VaProgressCircle = _export_sfc(_sfc_main3, [["render", _sfc_render3]]);

// node_modules/vuestic-ui/dist/es/src/components/va-progress-circle/index.js
var VaProgressCircle = withConfigTransport(_VaProgressCircle);

// node_modules/vuestic-ui/dist/es/src/components/va-button/VaButton.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-button/VaButton.css";
var __defProp12 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols12 = Object.getOwnPropertySymbols;
var __hasOwnProp12 = Object.prototype.hasOwnProperty;
var __propIsEnum12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp12 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues12 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp12.call(b2, prop))
      __defNormalProp12(a2, prop, b2[prop]);
  if (__getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(b2)) {
      if (__propIsEnum12.call(b2, prop))
        __defNormalProp12(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps7 = (a2, b2) => __defProps7(a2, __getOwnPropDescs7(b2));
var __default__ = defineComponent({
  name: "VaButton",
  components: { VaIcon: VaIcon2, VaProgressCircle },
  props: __spreadProps7(__spreadValues12(__spreadValues12(__spreadValues12(__spreadValues12(__spreadValues12(__spreadValues12({}, useComponentPresetProp), useSizeProps), useHoverStyleProps), usePressedStyleProps), useLoadingProps), useRouterLinkProps), {
    tag: { type: String, default: "button" },
    type: { type: String, default: "button" },
    block: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    textOpacity: { type: Number, default: 1 },
    backgroundOpacity: { type: Number, default: 1 },
    borderColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    plain: { type: Boolean, default: false },
    round: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (v2) => ["small", "medium", "large"].includes(v2)
    },
    icon: { type: String, default: "" },
    iconRight: { type: String, default: "" },
    iconColor: { type: String, default: "" }
  }),
  setup(props, { slots }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { sizeComputed } = useSize(props);
    const loaderSizeComputed = computed(() => {
      const size = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size ? `${+size[1] / 2}${size[2]}` : sizeComputed.value;
    });
    const { tagComputed } = useRouterLink(props);
    const attributesComputed = useButtonAttributes(props);
    const { disabled } = toRefs(props);
    const button = shallowRef();
    const { focus, blur } = useFocus(button);
    const { isHovered } = useHover(button, disabled);
    const { isPressed } = usePressed(button);
    const iconColorComputed = computed(() => props.iconColor ? getColor(props.iconColor) : textColorComputed.value);
    const iconAttributesComputed = computed(() => ({
      size: props.size,
      color: iconColorComputed.value
    }));
    const wrapperClassComputed = computed(() => ({ "va-button__content--loading": props.loading }));
    const isSlotContentPassed = computed(() => checkSlotChildrenDeep(slots.default));
    const isOneIcon = computed(() => !!(props.iconRight && !props.icon || !props.iconRight && props.icon));
    const isOnlyIcon = computed(() => !isSlotContentPassed.value && isOneIcon.value);
    const computedClass = useBem("va-button", () => __spreadProps7(__spreadValues12({}, pick_1(props, ["disabled", "block", "loading", "round", "plain"])), {
      small: props.size === "small",
      normal: !props.size || props.size === "medium",
      large: props.size === "large",
      opacity: props.textOpacity < 1,
      bordered: !!props.borderColor,
      iconOnly: isOnlyIcon.value,
      leftIcon: !isOnlyIcon.value && !!props.icon && !props.iconRight,
      rightIcon: !isOnlyIcon.value && !props.icon && !!props.iconRight
    }));
    const isTransparentBg = computed(() => props.plain || props.backgroundOpacity < 0.5);
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBg);
    const {
      backgroundColor,
      backgroundColorOpacity,
      backgroundMaskOpacity,
      backgroundMaskColor
    } = useButtonBackground(colorComputed, isPressed, isHovered);
    const contentColorComputed = useButtonTextColor(textColorComputed, colorComputed, isPressed, isHovered);
    const computedStyle = computed(() => __spreadValues12({
      borderColor: props.borderColor ? getColor(props.borderColor) : "transparent"
    }, contentColorComputed.value));
    const publicMethods = { focus, blur };
    return __spreadValues12({
      button,
      tagComputed,
      computedClass,
      computedStyle,
      textColorComputed,
      loaderSizeComputed,
      attributesComputed,
      wrapperClassComputed,
      iconAttributesComputed,
      backgroundColor,
      backgroundMaskColor,
      backgroundMaskOpacity,
      backgroundColorOpacity
    }, publicMethods);
  }
});
var __injectCSSVars__ = () => {
  useCssVars((_ctx) => ({
    "37b94640": _ctx.backgroundColor,
    "b15611ea": _ctx.backgroundColorOpacity,
    "86485a58": _ctx.backgroundMaskColor,
    "7111833c": _ctx.backgroundMaskOpacity
  }));
};
var __setup__ = __default__.setup;
__default__.setup = __setup__ ? (props, ctx) => {
  __injectCSSVars__();
  return __setup__(props, ctx);
} : __injectCSSVars__;
var _sfc_main4 = __default__;
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "button",
    class: ["va-button", _ctx.computedClass],
    style: _ctx.computedStyle
  }, _ctx.attributesComputed), {
    default: withCtx(() => [
      createBaseVNode("span", {
        class: normalizeClass(["va-button__content", _ctx.wrapperClassComputed])
      }, [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
          key: 0,
          class: "va-button__left-icon",
          name: _ctx.icon
        }, _ctx.iconAttributesComputed), null, 16, ["name"])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default"),
        _ctx.iconRight ? (openBlock(), createBlock(_component_va_icon, mergeProps({
          key: 1,
          class: "va-button__right-icon",
          name: _ctx.iconRight
        }, _ctx.iconAttributesComputed), null, 16, ["name"])) : createCommentVNode("", true)
      ], 2),
      _ctx.loading ? renderSlot(_ctx.$slots, "loading", normalizeProps(mergeProps({ key: 0 }, {
        size: _ctx.loaderSizeComputed,
        color: _ctx.textColorComputed
      })), () => [
        createVNode(_component_va_progress_circle, {
          class: "va-button__loader",
          size: _ctx.loaderSizeComputed,
          color: _ctx.textColorComputed,
          thickness: 0.15,
          indeterminate: ""
        }, null, 8, ["size", "color", "thickness"])
      ]) : createCommentVNode("", true)
    ]),
    _: 3
  }, 16, ["class", "style"]);
}
var VaButton = _export_sfc(_sfc_main4, [["render", _sfc_render4]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button/index.js
var VaButton2 = withConfigTransport(VaButton);

// node_modules/vuestic-ui/dist/es/src/components/va-modal/VaModal.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-modal/VaModal.css";
var __defProp13 = Object.defineProperty;
var __defProps8 = Object.defineProperties;
var __getOwnPropDescs8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols13 = Object.getOwnPropertySymbols;
var __hasOwnProp13 = Object.prototype.hasOwnProperty;
var __propIsEnum13 = Object.prototype.propertyIsEnumerable;
var __defNormalProp13 = (obj, key, value) => key in obj ? __defProp13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues13 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp13.call(b2, prop))
      __defNormalProp13(a2, prop, b2[prop]);
  if (__getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(b2)) {
      if (__propIsEnum13.call(b2, prop))
        __defNormalProp13(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps8 = (a2, b2) => __defProps8(a2, __getOwnPropDescs8(b2));
var ModalElement = defineComponent({
  name: "ModalElement",
  inheritAttrs: false,
  props: __spreadProps8(__spreadValues13({}, useComponentPresetProp), {
    isTransition: { type: Boolean, default: true }
  }),
  setup: (props, { slots, attrs }) => () => {
    var _a;
    return props.isTransition ? h(Transition, __spreadValues13({}, attrs), slots) : (_a = slots.default) == null ? void 0 : _a.call(slots, attrs);
  }
});
var _sfc_main5 = defineComponent({
  name: "VaModal",
  inheritAttrs: false,
  components: { VaButton: VaButton2, VaIcon: VaIcon2, ModalElement },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  props: __spreadProps8(__spreadValues13({}, useStatefulProps), {
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: { type: String, default: "$t:ok" },
    cancelText: { type: String, default: "$t:cancel" },
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String], default: void 0 },
    backgroundColor: { type: String, default: "background-secondary" },
    noPadding: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const modalDialog = shallowRef();
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const {
      registerModal,
      unregisterModal,
      isTopLevelModal,
      isLowestLevelModal
    } = useModalLevel();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "backgroundColor"));
    const { valueComputed } = useStateful(props, emit);
    const computedClass = computed(() => ({
      "va-modal--fullscreen": props.fullscreen,
      "va-modal--mobile-fullscreen": props.mobileFullscreen,
      "va-modal--fixed-layout": props.fixedLayout,
      "va-modal--no-padding": props.noPadding,
      [`va-modal--size-${props.size}`]: props.size !== "medium"
    }));
    const computedModalContainerStyle = computed(() => ({ "z-index": props.zIndex }));
    const computedDialogStyle = computed(() => ({
      maxWidth: props.maxWidth,
      maxHeight: props.maxHeight,
      color: textColorComputed.value,
      background: getColor(props.backgroundColor)
    }));
    const computedOverlayStyles = computed(() => {
      if (!props.overlay || !isLowestLevelModal.value) {
        return;
      }
      return {
        "background-color": `rgba(0, 0, 0, ${props.overlayOpacity})`,
        "z-index": props.zIndex && Number(props.zIndex) - 1
      };
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide = () => {
      valueComputed.value = false;
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      hide();
      emit("cancel");
    };
    const ok = () => {
      hide();
      emit("ok");
    };
    const trapFocusInModal = () => {
      nextTick(() => {
        if (modalDialog.value) {
          trapFocusIn(modalDialog.value);
        }
      });
    };
    const onOutsideClick = () => {
      if (props.noOutsideDismiss || props.noDismiss) {
        return;
      }
      emit("click-outside");
      cancel();
    };
    const onBeforeEnterTransition = (el) => emit("before-open", el);
    const onAfterEnterTransition = (el) => emit("open", el);
    const onBeforeLeaveTransition = (el) => emit("before-close", el);
    const onAfterLeaveTransition = (el) => emit("close", el);
    const listenKeyUp = (e2) => {
      const hideModal = () => {
        if (e2.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isTopLevelModal.value) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    const window3 = useWindow();
    const document2 = useDocument();
    watchEffect(() => {
      var _a, _b;
      if (valueComputed.value) {
        (_a = window3.value) == null ? void 0 : _a.addEventListener("keyup", listenKeyUp);
      } else {
        (_b = window3.value) == null ? void 0 : _b.removeEventListener("keyup", listenKeyUp);
      }
    });
    watchEffect(() => {
      var _a, _b;
      if (props.blur) {
        if (valueComputed.value) {
          (_a = document2.value) == null ? void 0 : _a.body.classList.add("va-modal-overlay-background--blurred");
        } else {
          (_b = document2.value) == null ? void 0 : _b.body.classList.remove("va-modal-overlay-background--blurred");
        }
      }
    });
    watch(valueComputed, (newValueComputed) => {
      if (newValueComputed) {
        registerModal();
        return;
      }
      if (isLowestLevelModal.value) {
        freeFocus();
      }
      unregisterModal();
    });
    watch(isTopLevelModal, (newIsTopLevelModal) => {
      if (newIsTopLevelModal) {
        trapFocusInModal();
      }
    });
    onMounted(() => {
      if (valueComputed.value) {
        registerModal();
      }
    });
    const publicMethods = __spreadProps8(__spreadValues13({}, useTranslation()), {
      show,
      hide,
      toggle,
      cancel,
      ok,
      onOutsideClick,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    });
    return __spreadValues13({
      getColor,
      rootElement,
      modalDialog,
      valueComputed,
      computedClass,
      computedDialogStyle,
      computedModalContainerStyle,
      computedOverlayStyles
    }, publicMethods);
  }
});
var _hoisted_13 = ["aria-labelledby"];
var _hoisted_23 = {
  key: 0,
  class: "va-modal__anchor"
};
var _hoisted_32 = {
  key: 0,
  class: "va-modal"
};
var _hoisted_42 = { key: 0 };
var _hoisted_52 = {
  key: 1,
  class: "va-modal__header"
};
var _hoisted_62 = {
  key: 2,
  class: "va-modal__message"
};
var _hoisted_72 = {
  key: 3,
  class: "va-modal__message"
};
var _hoisted_8 = {
  key: 4,
  class: "va-modal__footer"
};
var _hoisted_9 = {
  key: 5,
  class: "va-modal__footer"
};
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_button = resolveComponent("va-button");
  const _component_modal_element = resolveComponent("modal-element");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: normalizeClass(["va-modal-entry", _ctx.$props.anchorClass]),
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": _ctx.title
  }, [
    _ctx.$slots.anchor ? (openBlock(), createElementBlock("div", _hoisted_23, [
      renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ show: _ctx.show, hide: _ctx.hide, toggle: _ctx.toggle })))
    ])) : createCommentVNode("", true),
    (openBlock(), createBlock(Teleport, {
      to: _ctx.attachElement,
      disabled: _ctx.$props.disableAttachment
    }, [
      createVNode(_component_modal_element, mergeProps({
        name: "va-modal",
        isTransition: !_ctx.$props.withoutTransitions,
        appear: "",
        duration: 300
      }, _ctx.$attrs, {
        onBeforeEnter: _ctx.onBeforeEnterTransition,
        onAfterEnter: _ctx.onAfterEnterTransition,
        onBeforeLeave: _ctx.onBeforeLeaveTransition,
        onAfterLeave: _ctx.onAfterLeaveTransition
      }), {
        default: withCtx(() => [
          _ctx.valueComputed ? (openBlock(), createElementBlock("div", _hoisted_32, [
            _ctx.$props.overlay ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-modal__overlay",
              style: normalizeStyle(_ctx.computedOverlayStyles),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onOutsideClick && _ctx.onOutsideClick(...args))
            }, null, 4)) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: "va-modal__container",
              style: normalizeStyle(_ctx.computedModalContainerStyle)
            }, [
              createBaseVNode("div", {
                ref: "modalDialog",
                class: normalizeClass(["va-modal__dialog", _ctx.computedClass]),
                style: normalizeStyle(_ctx.computedDialogStyle)
              }, [
                _ctx.$props.fullscreen ? (openBlock(), createBlock(_component_va_icon, {
                  key: 0,
                  name: "va-close",
                  class: "va-modal__close",
                  role: "button",
                  "aria-label": _ctx.t("close"),
                  tabindex: "0",
                  onClick: _ctx.cancel,
                  onKeydown: [
                    withKeys(_ctx.cancel, ["space"]),
                    withKeys(_ctx.cancel, ["enter"])
                  ]
                }, null, 8, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: "va-modal__inner",
                  style: normalizeStyle({ maxWidth: _ctx.$props.maxWidth, maxHeight: _ctx.$props.maxHeight })
                }, [
                  _ctx.$slots.content ? (openBlock(), createElementBlock("div", _hoisted_42, [
                    renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ cancel: _ctx.cancel, ok: _ctx.ok })))
                  ])) : createCommentVNode("", true),
                  !_ctx.$slots.content ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    _ctx.title ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: "va-modal__title",
                      style: normalizeStyle({ color: _ctx.getColor("primary") })
                    }, toDisplayString(_ctx.$props.title), 5)) : createCommentVNode("", true),
                    _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_52, [
                      renderSlot(_ctx.$slots, "header")
                    ])) : createCommentVNode("", true),
                    _ctx.$props.message ? (openBlock(), createElementBlock("div", _hoisted_62, toDisplayString(_ctx.$props.message), 1)) : createCommentVNode("", true),
                    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_72, [
                      renderSlot(_ctx.$slots, "default")
                    ])) : createCommentVNode("", true),
                    (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? (openBlock(), createElementBlock("div", _hoisted_8, [
                      _ctx.$props.cancelText ? (openBlock(), createBlock(_component_va_button, {
                        key: 0,
                        preset: "secondary",
                        color: "secondary",
                        class: "mr-3",
                        onClick: _ctx.cancel
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.tp(_ctx.$props.cancelText)), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])) : createCommentVNode("", true),
                      createVNode(_component_va_button, { onClick: _ctx.ok }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(_ctx.tp(_ctx.$props.okText)), 1)
                        ]),
                        _: 1
                      }, 8, ["onClick"])
                    ])) : createCommentVNode("", true),
                    _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_9, [
                      renderSlot(_ctx.$slots, "footer")
                    ])) : createCommentVNode("", true)
                  ], 64)) : createCommentVNode("", true)
                ], 4)
              ], 6)
            ], 4)
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["isTransition", "onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])
    ], 8, ["to", "disabled"]))
  ], 10, _hoisted_13);
}
var _VaModal = _export_sfc(_sfc_main5, [["render", _sfc_render5]]);
var VaModal = withConfigTransport(_VaModal);

// node_modules/vuestic-ui/dist/es/src/components/va-modal/modal.js
init_vue_runtime_esm_bundler();
var __defProp14 = Object.defineProperty;
var __defProps9 = Object.defineProperties;
var __getOwnPropDescs9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols14 = Object.getOwnPropertySymbols;
var __hasOwnProp14 = Object.prototype.hasOwnProperty;
var __propIsEnum14 = Object.prototype.propertyIsEnumerable;
var __defNormalProp14 = (obj, key, value) => key in obj ? __defProp14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues14 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp14.call(b2, prop))
      __defNormalProp14(a2, prop, b2[prop]);
  if (__getOwnPropSymbols14)
    for (var prop of __getOwnPropSymbols14(b2)) {
      if (__propIsEnum14.call(b2, prop))
        __defNormalProp14(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps9 = (a2, b2) => __defProps9(a2, __getOwnPropDescs9(b2));
var getNodeProps2 = (vNode) => {
  var _a;
  return ((_a = vNode.component) == null ? void 0 : _a.props) || {};
};
var destroy2 = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
var mount2 = (component, { props, appContext } = {}) => {
  var _a;
  const el = document == null ? void 0 : document.createElement("div");
  let vNode;
  const onClose = (event) => {
    var _a2;
    (_a2 = props == null ? void 0 : props.onClose) == null ? void 0 : _a2.call(props, event);
    destroy2(el);
  };
  const onUpdateModelValue = (value) => {
    var _a2;
    (_a2 = props == null ? void 0 : props["onUpdate:modelValue"]) == null ? void 0 : _a2.call(props, value);
    if ((props == null ? void 0 : props.withoutTransitions) && !value) {
      nextTick(() => {
        destroy2(el);
      });
    }
  };
  vNode = h(component, __spreadProps9(__spreadValues14({}, props), {
    stateful: (_a = props == null ? void 0 : props.stateful) != null ? _a : true,
    modelValue: true,
    onClose,
    "onUpdate:modelValue": onUpdateModelValue
  }));
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
var getModalOptions = (options) => typeof options === "string" ? { message: options } : options;
var createModalInstance = (customProps, appContext) => {
  const { vNode, el } = mount2(VaModal, { appContext, props: getModalOptions(customProps) });
  if (el && vNode.el && getNodeProps2(vNode)) {
    document.body.appendChild(el.childNodes[0]);
  }
  return vNode;
};

// node_modules/vuestic-ui/dist/es/src/components/va-modal/plugin/index.js
var createVaModalPlugin = (app2) => ({
  init(options) {
    return createModalInstance(options, app2 == null ? void 0 : app2._context);
  }
});
var VaModalPlugin = defineVuesticPlugin(() => ({
  install(app2) {
    defineGlobalProperty(app2, "$vaModal", createVaModalPlugin(app2));
  }
}));

// node_modules/vuestic-ui/dist/es/src/vuestic-plugin/utils/use-plugin.js
var isPluginFabric = (plugin) => typeof plugin === "function";
var usePlugin = (app2, plugin, ...options) => {
  if (isPluginFabric(plugin)) {
    app2.use(plugin(...options));
  } else {
    app2.use(plugin);
  }
};

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/VaAccordion.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/hooks/useAccordion.js
init_vue_runtime_esm_bundler();
var AccordionServiceKey = Symbol("AccordionService");
var useAccordion = (props, state) => {
  let items2 = [];
  const onItemMounted = (item) => {
    items2.push(item);
  };
  const onItemUnmounted = (item) => {
    items2 = items2.filter((i2) => i2 !== item);
  };
  const onItemChanged = (changedItem) => {
    state.value = items2.map((item) => {
      if (item === changedItem) {
        return item.state.value;
      }
      if (!props.multiple) {
        item.state.value = false;
      }
      return item.state.value;
    });
  };
  provide(AccordionServiceKey, {
    isInsideAccordion: true,
    onItemMounted,
    onItemUnmounted,
    onItemChanged,
    props: computed(() => props)
  });
  const updateItemStates = () => {
    items2.forEach((item, index) => {
      item.state.value = state.value[index];
    });
  };
  onMounted(updateItemStates);
  watch(state, updateItemStates);
  return { items: items2 };
};
var useAccordionItem = (state) => {
  const accordion = inject(AccordionServiceKey, {
    props: ref({ inset: void 0, popout: void 0 }),
    onItemChanged: () => void 0,
    onItemMounted: () => void 0,
    onItemUnmounted: () => void 0
  });
  const item = { state };
  onMounted(() => accordion.onItemMounted(item));
  onBeforeUnmount(() => accordion.onItemUnmounted(item));
  return {
    accordionProps: accordion.props,
    toggle: () => {
      state.value = !state.value;
      accordion.onItemChanged(item);
    }
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/VaAccordion.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-accordion/VaAccordion.css";
var __defProp15 = Object.defineProperty;
var __defProps10 = Object.defineProperties;
var __getOwnPropDescs10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols15 = Object.getOwnPropertySymbols;
var __hasOwnProp15 = Object.prototype.hasOwnProperty;
var __propIsEnum15 = Object.prototype.propertyIsEnumerable;
var __defNormalProp15 = (obj, key, value) => key in obj ? __defProp15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues15 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp15.call(b2, prop))
      __defNormalProp15(a2, prop, b2[prop]);
  if (__getOwnPropSymbols15)
    for (var prop of __getOwnPropSymbols15(b2)) {
      if (__propIsEnum15.call(b2, prop))
        __defNormalProp15(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps10 = (a2, b2) => __defProps10(a2, __getOwnPropDescs10(b2));
var _sfc_main6 = defineComponent({
  name: "VaAccordion",
  emits: useStatefulEmits,
  props: __spreadProps10(__spreadValues15(__spreadValues15({}, useStatefulProps), useComponentPresetProp), {
    modelValue: { type: Array, default: () => [] },
    multiple: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    popout: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: [] });
    const { items: items2 } = useAccordion(props, valueComputed);
    return { collapses: items2, value: valueComputed };
  }
});
var _hoisted_14 = { class: "va-accordion" };
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_14, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaAccordion = _export_sfc(_sfc_main6, [["render", _sfc_render6]]);

// node_modules/vuestic-ui/dist/es/src/components/va-accordion/index.js
var VaAccordion = withConfigTransport(_VaAccordion);

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix-utils.js
var __defProp16 = Object.defineProperty;
var __defProps11 = Object.defineProperties;
var __getOwnPropDescs11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols16 = Object.getOwnPropertySymbols;
var __hasOwnProp16 = Object.prototype.hasOwnProperty;
var __propIsEnum16 = Object.prototype.propertyIsEnumerable;
var __defNormalProp16 = (obj, key, value) => key in obj ? __defProp16(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues16 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp16.call(b2, prop))
      __defNormalProp16(a2, prop, b2[prop]);
  if (__getOwnPropSymbols16)
    for (var prop of __getOwnPropSymbols16(b2)) {
      if (__propIsEnum16.call(b2, prop))
        __defNormalProp16(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps11 = (a2, b2) => __defProps11(a2, __getOwnPropDescs11(b2));
function getWindowHeight() {
  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({
  coordinates,
  offsetTop,
  offsetBottom,
  target
}) {
  let isTopAffixed = false;
  let isBottomAffixed = false;
  const windowHeight = getWindowHeight();
  if (offsetTop != null && windowHeight) {
    if (target === window) {
      isTopAffixed = coordinates.top <= offsetTop;
    } else {
      const { top } = target.getBoundingClientRect();
      isTopAffixed = coordinates.top - top <= offsetTop;
    }
  }
  if (offsetBottom != null && windowHeight) {
    if (target === window) {
      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
    } else {
      const { bottom } = target.getBoundingClientRect();
      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
    }
  }
  return {
    isTopAffixed,
    isBottomAffixed
  };
}
function checkAffixedStateChange(currentState, nextState) {
  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
  if (!element) {
    return;
  }
  const isInitialCall = !eventName;
  const coordinates = element.getBoundingClientRect();
  const options = {
    offsetBottom,
    offsetTop,
    target
  };
  const nextState = isInitialCall && initialPosition ? computeAffixedState(__spreadValues16({ coordinates: initialPosition }, options)) : computeAffixedState(__spreadValues16({ coordinates }, options));
  const prevState = getState();
  if (checkAffixedStateChange(prevState, nextState)) {
    setState(__spreadProps11(__spreadValues16({}, nextState), { width: coordinates.width }));
  } else if (prevState.width !== coordinates.width) {
    setState(__spreadProps11(__spreadValues16({}, prevState), { width: coordinates.width }));
  }
}
function useCaptureDefault(eventName) {
  return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, {
  handler,
  useCapture = useCaptureDefault,
  wait = 50
}) {
  const clearHandlersArray = events.map((eventName) => {
    const _handler = throttle_1((event) => handler(eventName, event), wait);
    window.addEventListener(eventName, _handler, useCapture(eventName));
    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
  });
  return () => clearHandlersArray.forEach((clear) => clear());
}

// node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-affix/VaAffix.css";
var __defProp17 = Object.defineProperty;
var __defProps12 = Object.defineProperties;
var __getOwnPropDescs12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols17 = Object.getOwnPropertySymbols;
var __hasOwnProp17 = Object.prototype.hasOwnProperty;
var __propIsEnum17 = Object.prototype.propertyIsEnumerable;
var __defNormalProp17 = (obj, key, value) => key in obj ? __defProp17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues17 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp17.call(b2, prop))
      __defNormalProp17(a2, prop, b2[prop]);
  if (__getOwnPropSymbols17)
    for (var prop of __getOwnPropSymbols17(b2)) {
      if (__propIsEnum17.call(b2, prop))
        __defNormalProp17(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps12 = (a2, b2) => __defProps12(a2, __getOwnPropDescs12(b2));
var _sfc_main7 = defineComponent({
  name: "VaAffix",
  emits: ["change"],
  props: __spreadProps12(__spreadValues17({}, useComponentPresetProp), {
    offsetTop: { type: Number, default: void 0 },
    offsetBottom: { type: Number, default: void 0 },
    target: { type: [Object, Function], default: getWindow }
  }),
  setup(props, { emit }) {
    const element = shallowRef();
    const getTargetElement2 = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit("change", isAffixed);
    };
    const calculateTop = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetTop === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + props.offsetTop;
      }
      return props.offsetTop;
    };
    const calculateBottom = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (props.offsetBottom === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight;
      }
      return props.offsetBottom;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = __spreadProps12(__spreadValues17({}, props), {
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement2(),
        setState,
        getState
      });
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement2();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop_1;
    onMounted(() => {
      var _a;
      initialPosition.value = (_a = element.value) == null ? void 0 : _a.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return {
      computedClass,
      computedStyle,
      isAffixed,
      element
    };
  }
});
var _hoisted_15 = {
  ref: "element",
  class: "va-affix"
};
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_15, [
    createBaseVNode("div", {
      style: normalizeStyle({ visibility: _ctx.isAffixed ? "hidden" : "inherit" })
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4),
    _ctx.isAffixed ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.computedClass),
      style: normalizeStyle(_ctx.computedStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6)) : createCommentVNode("", true)
  ], 512);
}
var _VaAffix = _export_sfc(_sfc_main7, [["render", _sfc_render7]]);

// node_modules/vuestic-ui/dist/es/src/components/va-affix/index.js
var VaAffix = withConfigTransport(_VaAffix);

// node_modules/vuestic-ui/dist/es/src/components/va-alert/VaAlert.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-alert/useAlertStyles.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useElementBackground/useDomChangesObserver.js
init_vue_runtime_esm_bundler();
var observer;
var callbacks = [];
var createMutationObserver = () => {
  const runCallbacks = (mutations) => {
    for (let i2 = 0; i2 < callbacks.length; i2++) {
      if (mutations.some((m2) => m2.target.contains(callbacks[i2].el.value || null))) {
        callbacks[i2].cb();
      }
    }
  };
  if (!observer) {
    observer = new MutationObserver((mutations) => {
      runCallbacks(mutations);
    });
    observer.observe(document.documentElement, {
      attributeFilter: ["style", "class"],
      subtree: true,
      attributes: true
    });
  }
};
var destroyMutationObserver = () => {
  if (!observer) {
    return;
  }
  if (callbacks.length > 0) {
    return;
  }
  observer.disconnect();
  observer = null;
};
var useDomChangesObserver = (cb, el) => {
  onMounted(() => {
    createMutationObserver();
    callbacks.push({ cb, el });
  });
  onBeforeUnmount(() => {
    callbacks = callbacks.filter((c2) => c2.cb !== cb);
    destroyMutationObserver();
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useElementBackground/utils.js
var window2 = getWindow();
var getElementBackground = (element) => {
  return window2 == null ? void 0 : window2.getComputedStyle(element).backgroundColor;
};

// node_modules/vuestic-ui/dist/es/src/composables/useElementBackground/useElementBackground.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useEl.js
init_vue_runtime_esm_bundler();
var useEl = () => {
  const el = ref();
  const { proxy } = getCurrentInstance();
  onMounted(() => {
    el.value = proxy == null ? void 0 : proxy.$el;
  });
  onBeforeUnmount(() => {
    el.value = void 0;
  });
  return el;
};

// node_modules/vuestic-ui/dist/es/src/composables/useElementBackground/useElementBackground.js
var isTransparent = (color) => color === "rgba(0, 0, 0, 0)";
var recursiveGetBackground = (element) => {
  if (!element) {
    return "#fff";
  }
  if (element.nodeType !== Node.ELEMENT_NODE) {
    return recursiveGetBackground(element.parentElement);
  }
  const bg = getElementBackground(element);
  if (!bg) {
    return recursiveGetBackground(element.parentElement);
  }
  if (isTransparent(bg)) {
    const parentBg = recursiveGetBackground(element.parentElement);
    return parentBg;
  }
  return applyColors(recursiveGetBackground(element.parentElement), bg);
};
var useElementBackground = (element) => {
  const el = element || useEl();
  const { getColor } = useColors();
  const background = ref(getColor("background-primary"));
  const updateBackground = () => {
    requestAnimationFrame(() => {
      const bg = recursiveGetBackground(el.value);
      background.value = bg;
    });
  };
  useDomChangesObserver(updateBackground, el);
  onMounted(updateBackground);
  return {
    background
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-alert/useAlertStyles.js
var useAlertStyles = (props) => {
  const { getColor, getTextColor, getBoxShadowColorFromBg: getBoxShadowColorFromBg2 } = useColors();
  const { background } = useElementBackground();
  const isTransparentBackground = computed(() => Boolean(props.outline || props.border));
  const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
  const colorComputed = computed(() => getColor(props.color));
  const alertStyle = computed(() => {
    let background2 = colorComputed.value;
    let boxShadow = "none";
    if (props.outline) {
      background2 = "transparent";
    }
    if (props.border) {
      background2 = "var(--va-background-primary)";
      boxShadow = "var(--va-alert-box-shadow)";
    }
    return {
      border: props.outline ? `1px solid ${colorComputed.value}` : "",
      padding: props.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
      backgroundColor: background2,
      boxShadow
    };
  });
  const contentStyle = computed(() => {
    return {
      alignItems: props.center ? "center" : "",
      color: props.border || props.outline ? getColor(getTextColor(background.value), void 0, true) : textColorComputed.value
    };
  });
  const titleStyle = computed(() => {
    return { color: textColorComputed.value };
  });
  const borderStyle = computed(() => ({
    backgroundColor: props.borderColor ? getColor(props.borderColor) : colorComputed.value
  }));
  return {
    alertStyle,
    contentStyle,
    titleStyle,
    borderStyle
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-alert/VaAlert.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-alert/VaAlert.css";
var __defProp18 = Object.defineProperty;
var __defProps13 = Object.defineProperties;
var __getOwnPropDescs13 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols18 = Object.getOwnPropertySymbols;
var __hasOwnProp18 = Object.prototype.hasOwnProperty;
var __propIsEnum18 = Object.prototype.propertyIsEnumerable;
var __defNormalProp18 = (obj, key, value) => key in obj ? __defProp18(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues18 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp18.call(b2, prop))
      __defNormalProp18(a2, prop, b2[prop]);
  if (__getOwnPropSymbols18)
    for (var prop of __getOwnPropSymbols18(b2)) {
      if (__propIsEnum18.call(b2, prop))
        __defNormalProp18(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps13 = (a2, b2) => __defProps13(a2, __getOwnPropDescs13(b2));
var _sfc_main8 = defineComponent({
  name: "VaAlert",
  components: { VaIcon: VaIcon2 },
  emits: useStatefulEmits,
  props: __spreadProps13(__spreadValues18(__spreadValues18({}, useStatefulProps), useComponentPresetProp), {
    modelValue: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    title: { type: String, default: "" },
    description: { type: String, default: "" },
    icon: { type: String, default: "" },
    closeText: { type: String, default: "" },
    closeable: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    border: {
      type: String,
      default: "",
      validator: (value) => ["top", "right", "bottom", "left", ""].includes(value)
    }
  }),
  setup(props, { slots, emit }) {
    const alertStyles = useAlertStyles(props);
    const { valueComputed } = useStateful(props, emit);
    const hide = () => {
      valueComputed.value = false;
    };
    const hasIcon = computed(() => props.icon || slots.icon);
    const hasTitle = computed(() => props.title || slots.title);
    const borderClass = computed(() => `va-alert__border--${props.border}`);
    const closeIcon = computed(() => props.closeText || "close");
    const uniqueId2 = computed(generateUniqueId);
    const titleIdComputed = computed(() => `aria-title-${uniqueId2.value}`);
    const descriptionIdComputed = computed(() => `aria-description-${uniqueId2.value}`);
    return __spreadProps13(__spreadValues18(__spreadValues18({}, useTranslation()), alertStyles), {
      valueComputed,
      hasIcon,
      hasTitle,
      borderClass,
      closeIcon,
      hide,
      titleIdComputed,
      descriptionIdComputed
    });
  }
});
var _hoisted_16 = ["role", "aria-labelledby", "aria-describedby"];
var _hoisted_24 = ["id"];
var _hoisted_33 = ["id"];
var _hoisted_43 = {
  key: 1,
  class: "va-alert__close"
};
var _hoisted_53 = ["aria-label"];
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(Transition, {
    key: 0,
    name: "fade"
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-alert",
        style: normalizeStyle(_ctx.alertStyle),
        role: _ctx.closeable ? "alertdialog" : "alert",
        "aria-labelledby": _ctx.titleIdComputed,
        "aria-describedby": _ctx.descriptionIdComputed
      }, [
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.borderStyle),
          class: normalizeClass([_ctx.borderClass, "va-alert__border"])
        }, null, 6),
        _ctx.hasIcon ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__icon",
          "aria-hidden": "true"
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, { name: _ctx.icon }, null, 8, ["name"])
          ])
        ], 4)) : createCommentVNode("", true),
        createBaseVNode("div", {
          style: normalizeStyle(_ctx.contentStyle),
          class: "va-alert__content"
        }, [
          _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
            key: 0,
            style: normalizeStyle(_ctx.titleStyle),
            class: "va-alert__title",
            id: _ctx.titleIdComputed
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 12, _hoisted_24)) : createCommentVNode("", true),
          createBaseVNode("span", { id: _ctx.descriptionIdComputed }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.description), 1)
            ])
          ], 8, _hoisted_33)
        ], 4),
        _ctx.closeable ? (openBlock(), createElementBlock("div", _hoisted_43, [
          createBaseVNode("div", {
            role: "button",
            class: "va-alert__close--closeable",
            tabindex: "0",
            "aria-label": _ctx.closeText || _ctx.t("closeAlert"),
            style: normalizeStyle(_ctx.contentStyle),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.hide && _ctx.hide(...args)),
            onKeydown: [
              _cache[1] || (_cache[1] = withKeys((...args) => _ctx.hide && _ctx.hide(...args), ["space"])),
              _cache[2] || (_cache[2] = withKeys((...args) => _ctx.hide && _ctx.hide(...args), ["enter"]))
            ]
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              !_ctx.closeText ? (openBlock(), createBlock(_component_va_icon, {
                key: 0,
                name: _ctx.closeIcon,
                size: "small"
              }, null, 8, ["name"])) : createCommentVNode("", true),
              createTextVNode(" " + toDisplayString(_ctx.closeText), 1)
            ])
          ], 44, _hoisted_53)
        ])) : createCommentVNode("", true)
      ], 12, _hoisted_16)
    ]),
    _: 3
  })) : createCommentVNode("", true);
}
var _VaAlert = _export_sfc(_sfc_main8, [["render", _sfc_render8]]);

// node_modules/vuestic-ui/dist/es/src/components/va-alert/index.js
var VaAlert = withConfigTransport(_VaAlert);

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/VaAppBar.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useFixedBar.js
init_vue_runtime_esm_bundler();
var useFixedBarProps = {
  hideOnScroll: { type: Boolean, default: false },
  fixed: { type: Boolean, default: false },
  bottom: { type: Boolean, default: false }
};
function useFixedBar(props, isScrolledDown) {
  const isHiddenComputed = computed(() => isScrolledDown.value ? !!props.hideOnScroll : false);
  const transformComputed = computed(() => {
    if (!props.bottom && !isHiddenComputed.value) {
      return;
    }
    if (props.bottom && isHiddenComputed.value) {
      return "translateY(100%)";
    }
    if (props.bottom) {
      return props.fixed ? "translateY(-100%)" : "translateY(0)";
    }
    return "translateY(-100%)";
  });
  const positionComputed = computed(() => {
    if (props.fixed) {
      return "fixed";
    }
    return isHiddenComputed.value ? "absolute" : void 0;
  });
  const fixedBarStyleComputed = computed(() => {
    const result = {
      top: props.bottom && (isHiddenComputed.value || props.fixed) ? "100%" : void 0,
      transform: props.hideOnScroll || props.fixed ? transformComputed.value : void 0
    };
    positionComputed.value && Object.assign(result, { position: positionComputed.value });
    return result;
  });
  return { fixedBarStyleComputed };
}

// node_modules/vuestic-ui/dist/es/src/composables/useScroll.js
init_vue_runtime_esm_bundler();
function getTargetElement(target) {
  if (!target) {
    throw new Error("No target was provided for `useScroll` hook!");
  }
  return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(fixed, target) {
  const scrollRoot = shallowRef();
  let targetElement;
  const isScrolledDown = ref(false);
  const prevScrollPosition = ref(0);
  const onScroll = (e2) => {
    const target2 = e2.target;
    const scrollValue = e2.target instanceof Window ? target2.scrollY : target2.scrollTop;
    isScrolledDown.value = prevScrollPosition.value < scrollValue;
    prevScrollPosition.value = scrollValue;
  };
  onMounted(() => {
    targetElement = fixed ? window : getTargetElement(target || scrollRoot.value);
    targetElement == null ? void 0 : targetElement.addEventListener("scroll", onScroll, fixed);
  });
  onBeforeUnmount(() => {
    targetElement == null ? void 0 : targetElement.removeEventListener("scroll", onScroll);
  });
  return { scrollRoot, isScrolledDown };
}

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/VaAppBar.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-app-bar/VaAppBar.css";
var __defProp19 = Object.defineProperty;
var __defProps14 = Object.defineProperties;
var __getOwnPropDescs14 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols19 = Object.getOwnPropertySymbols;
var __hasOwnProp19 = Object.prototype.hasOwnProperty;
var __propIsEnum19 = Object.prototype.propertyIsEnumerable;
var __defNormalProp19 = (obj, key, value) => key in obj ? __defProp19(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues19 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp19.call(b2, prop))
      __defNormalProp19(a2, prop, b2[prop]);
  if (__getOwnPropSymbols19)
    for (var prop of __getOwnPropSymbols19(b2)) {
      if (__propIsEnum19.call(b2, prop))
        __defNormalProp19(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps14 = (a2, b2) => __defProps14(a2, __getOwnPropDescs14(b2));
var _sfc_main9 = defineComponent({
  name: "VaAppBar",
  props: __spreadProps14(__spreadValues19(__spreadValues19({}, useFixedBarProps), useComponentPresetProp), {
    gradient: { type: Boolean, default: false },
    target: { type: [Object, String], default: "" },
    shadowOnScroll: { type: Boolean, default: false },
    shadowColor: { type: String, default: "" },
    color: { type: String, default: void 0 }
  }),
  setup(props) {
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed, props.target);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, getGradientBackground: getGradientBackground2, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const showShadowComputed = computed(() => isScrolledDown.value ? !!props.shadowOnScroll : false);
    const shadowColorComputed = computed(() => getColor(props.shadowColor, colorComputed.value));
    const computedShadow = computed(() => {
      const shadow = getBoxShadowColor2(props.shadowColor ? shadowColorComputed.value : colorComputed.value);
      return showShadowComputed.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
    });
    const computedStyle = computed(() => __spreadProps14(__spreadValues19({}, fixedBarStyleComputed.value), {
      background: props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value,
      boxShadow: computedShadow.value
    }));
    return { scrollRoot, computedStyle };
  }
});
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    ref: "scrollRoot",
    role: "toolbar",
    class: "va-app-bar",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaAppBar = _export_sfc(_sfc_main9, [["render", _sfc_render9]]);

// node_modules/vuestic-ui/dist/es/src/components/va-app-bar/index.js
var VaAppBar = withConfigTransport(_VaAppBar);

// node_modules/vuestic-ui/dist/es/src/components/va-avatar/VaAvatar.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-avatar/VaAvatar.css";
var __defProp20 = Object.defineProperty;
var __defProps15 = Object.defineProperties;
var __getOwnPropDescs15 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols20 = Object.getOwnPropertySymbols;
var __hasOwnProp20 = Object.prototype.hasOwnProperty;
var __propIsEnum20 = Object.prototype.propertyIsEnumerable;
var __defNormalProp20 = (obj, key, value) => key in obj ? __defProp20(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues20 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp20.call(b2, prop))
      __defNormalProp20(a2, prop, b2[prop]);
  if (__getOwnPropSymbols20)
    for (var prop of __getOwnPropSymbols20(b2)) {
      if (__propIsEnum20.call(b2, prop))
        __defNormalProp20(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps15 = (a2, b2) => __defProps15(a2, __getOwnPropDescs15(b2));
var _sfc_main10 = defineComponent({
  name: "VaAvatar",
  components: { VaIcon: VaIcon2, VaProgressCircle },
  props: __spreadProps15(__spreadValues20(__spreadValues20(__spreadValues20({}, useLoadingProps), useSizeProps), useComponentPresetProp), {
    color: { type: String, default: "info" },
    textColor: { type: String },
    square: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    src: { type: String, default: null },
    alt: { type: String, default: "" },
    fontSize: { type: String, default: "" }
  }),
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatar");
    const { textColorComputed } = useTextColor();
    const computedStyle = computed(() => ({
      color: textColorComputed.value,
      backgroundColor: props.loading ? "transparent" : colorComputed.value,
      borderRadius: props.square ? 0 : "",
      fontSize: props.fontSize || fontSizeComputed.value,
      width: sizeComputed.value,
      minWidth: sizeComputed.value,
      height: sizeComputed.value
    }));
    return {
      sizeComputed,
      computedStyle,
      colorComputed
    };
  }
});
var _hoisted_17 = ["aria-hidden"];
var _hoisted_25 = ["src", "alt"];
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: "va-avatar",
    style: normalizeStyle(_ctx.computedStyle),
    "aria-hidden": !_ctx.$props.src,
    "aria-live": "polite"
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
        key: 0,
        size: _ctx.sizeComputed,
        color: _ctx.colorComputed,
        indeterminate: ""
      }, null, 8, ["size", "color"])) : _ctx.$props.src ? (openBlock(), createElementBlock("img", {
        key: 1,
        src: _ctx.$props.src,
        alt: _ctx.$props.alt
      }, null, 8, _hoisted_25)) : _ctx.$props.icon ? (openBlock(), createBlock(_component_va_icon, {
        key: 2,
        name: _ctx.$props.icon
      }, null, 8, ["name"])) : createCommentVNode("", true)
    ])
  ], 12, _hoisted_17);
}
var _VaAvatar = _export_sfc(_sfc_main10, [["render", _sfc_render10]]);

// node_modules/vuestic-ui/dist/es/src/components/va-avatar/index.js
var VaAvatar = withConfigTransport(_VaAvatar);

// node_modules/vuestic-ui/dist/es/src/components/va-backtop/VaBacktop.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-backtop/VaBacktop.css";
var __defProp21 = Object.defineProperty;
var __defProps16 = Object.defineProperties;
var __getOwnPropDescs16 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols21 = Object.getOwnPropertySymbols;
var __hasOwnProp21 = Object.prototype.hasOwnProperty;
var __propIsEnum21 = Object.prototype.propertyIsEnumerable;
var __defNormalProp21 = (obj, key, value) => key in obj ? __defProp21(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues21 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp21.call(b2, prop))
      __defNormalProp21(a2, prop, b2[prop]);
  if (__getOwnPropSymbols21)
    for (var prop of __getOwnPropSymbols21(b2)) {
      if (__propIsEnum21.call(b2, prop))
        __defNormalProp21(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps16 = (a2, b2) => __defProps16(a2, __getOwnPropDescs16(b2));
var _sfc_main11 = defineComponent({
  name: "VaBacktop",
  components: { VaButton: VaButton2 },
  props: __spreadProps16(__spreadValues21({}, useComponentPresetProp), {
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: Number, default: 300 },
    speed: { type: Number, default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    }
  }),
  setup(props) {
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const getTargetElement2 = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        const target = document.querySelector(props.target);
        if (!target) {
          warn(`Target element [${props.target}] is not found, falling back to window.`);
          return window;
        }
        return target;
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - props.speed);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const server = isServer();
    const visible = computed(() => {
      if (server) {
        return false;
      }
      return targetScrollValue.value > props.visibilityHeight;
    });
    if (!server) {
      onMounted(() => {
        targetElement = getTargetElement2();
        targetElement.addEventListener("scroll", handleScroll, true);
      });
      onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    }
    return __spreadValues21({
      computedStyle,
      visible,
      scrollToTop
    }, useTranslation());
  }
});
var _hoisted_18 = ["aria-label"];
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.visible ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-backtop",
    role: "button",
    "aria-label": _ctx.t("backToTop"),
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args)),
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.scrollToTop && _ctx.scrollToTop(...args), ["stop"]), ["enter"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_va_button, {
        "aria-hidden": "true",
        icon: "va-arrow-up",
        color: _ctx.color
      }, null, 8, ["color"])
    ])
  ], 44, _hoisted_18)) : createCommentVNode("", true);
}
var _VaBacktop = _export_sfc(_sfc_main11, [["render", _sfc_render11]]);

// node_modules/vuestic-ui/dist/es/src/components/va-backtop/index.js
var VaBacktop = withConfigTransport(_VaBacktop);

// node_modules/vuestic-ui/dist/es/src/components/va-badge/VaBadge.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-badge/VaBadge.css";
var __defProp22 = Object.defineProperty;
var __defProps17 = Object.defineProperties;
var __getOwnPropDescs17 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols22 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues22 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp22.call(b2, prop))
      __defNormalProp22(a2, prop, b2[prop]);
  if (__getOwnPropSymbols22)
    for (var prop of __getOwnPropSymbols22(b2)) {
      if (__propIsEnum22.call(b2, prop))
        __defNormalProp22(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps17 = (a2, b2) => __defProps17(a2, __getOwnPropDescs17(b2));
var _sfc_main12 = defineComponent({
  name: "VaBadge",
  props: __spreadProps17(__spreadValues22({}, useComponentPresetProp), {
    color: { type: String, default: "danger" },
    textColor: { type: String },
    text: { type: [String, Number], default: "" },
    overlap: { type: Boolean, default: false },
    multiLine: { type: Boolean, default: false },
    visibleEmpty: { type: Boolean, default: false },
    dot: { type: Boolean, default: false },
    transparent: { type: Boolean, default: false },
    left: { type: Boolean, default: false },
    bottom: { type: Boolean, default: false }
  }),
  setup(props, { slots }) {
    const isEmpty = computed(() => !(props.text || props.visibleEmpty || props.dot || slots.text));
    const isFloating = computed(() => slots.default || props.dot);
    const badgeClass = computed(() => ({
      "va-badge--visible-empty": props.visibleEmpty,
      "va-badge--empty": isEmpty.value,
      "va-badge--dot": props.dot,
      "va-badge--multiLine": props.multiLine,
      "va-badge--floating": isFloating.value,
      "va-badge--left": props.left,
      "va-badge--bottom": props.bottom,
      "va-badge--overlap": props.overlap
    }));
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const colorComputed = computed(() => getColor(props.color));
    const badgeStyle = computed(() => ({
      color: textColorComputed.value,
      borderColor: colorComputed.value,
      backgroundColor: colorComputed.value,
      opacity: props.transparent ? 0.5 : 1
    }));
    return { badgeClass, badgeStyle };
  }
});
var _hoisted_19 = { class: "va-badge__text" };
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-badge", _ctx.badgeClass]),
    role: "alert"
  }, [
    createBaseVNode("span", {
      class: "va-badge__text-wrapper",
      style: normalizeStyle(_ctx.badgeStyle)
    }, [
      createBaseVNode("span", _hoisted_19, [
        renderSlot(_ctx.$slots, "text", {}, () => [
          createTextVNode(toDisplayString(_ctx.text), 1)
        ])
      ])
    ], 4),
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaBadge = _export_sfc(_sfc_main12, [["render", _sfc_render12]]);

// node_modules/vuestic-ui/dist/es/src/components/va-badge/index.js
var VaBadge = withConfigTransport(_VaBadge);

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbs.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useAlign.js
init_vue_runtime_esm_bundler();
var useAlignProps = {
  align: {
    type: String,
    default: "left"
  },
  vertical: {
    type: Boolean,
    default: false
  }
};
var horizontalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  between: "space-between",
  around: "space-around"
};
var verticalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  stretch: "stretch"
};
var justify = (align, vertical) => {
  return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
var items = (align, vertical) => {
  return vertical ? verticalMap[align] : "center";
};
function useAlign(props) {
  const alignComputed = computed(() => {
    return {
      display: "flex",
      flexDirection: props.vertical ? "column" : "row",
      justifyContent: justify(props.align, props.vertical),
      alignItems: items(props.align, props.vertical)
    };
  });
  return {
    alignComputed
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbs.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbs.css";
var __defProp23 = Object.defineProperty;
var __defProps18 = Object.defineProperties;
var __getOwnPropDescs18 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols23 = Object.getOwnPropertySymbols;
var __hasOwnProp23 = Object.prototype.hasOwnProperty;
var __propIsEnum23 = Object.prototype.propertyIsEnumerable;
var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues23 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp23.call(b2, prop))
      __defNormalProp23(a2, prop, b2[prop]);
  if (__getOwnPropSymbols23)
    for (var prop of __getOwnPropSymbols23(b2)) {
      if (__propIsEnum23.call(b2, prop))
        __defNormalProp23(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps18 = (a2, b2) => __defProps18(a2, __getOwnPropDescs18(b2));
var _sfc_main13 = defineComponent({
  name: "VaBreadcrumbs",
  props: __spreadProps18(__spreadValues23(__spreadValues23({}, useAlignProps), useComponentPresetProp), {
    separator: { type: String, default: "/" },
    color: { type: String, default: "secondary" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null }
  }),
  setup(props, { slots }) {
    const { alignComputed } = useAlign(props);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed(() => {
      return props.separatorColor ? getColor(props.separatorColor) : getColor(props.color);
    });
    const computedThemesActiveColor = computed(() => {
      return props.activeColor ? getColor(props.activeColor) : getColor(props.color);
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a, _b;
          return !!((_b = (_a = node2 == null ? void 0 : node2.type) == null ? void 0 : _a.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = slots.separator ? slots.separator() : [props.separator];
      return h("span", {
        ariaHidden: true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child == null ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty2(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref(true);
    const getChildren = () => {
      var _a;
      const childNodes = ((_a = slots == null ? void 0 : slots.default()) == null ? void 0 : _a.reduce(childNodeFilter, [])) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child == null ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty2(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h("span", {
        class: "va-breadcrumbs__item",
        ariaCurrent: isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
        style: {
          color: !isLastIndexChildNodes(index) && !isDisabledChild(child) ? computedThemesActiveColor.value : null
        }
      }, [child]);
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    const { t: t2 } = useTranslation();
    return () => h("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      ariaLabel: isAllChildLinks.value ? t2("breadcrumbs") : void 0
    }, getChildren());
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/VaBreadcrumbsItem/VaBreadcrumbsItem.css";
var __defProp24 = Object.defineProperty;
var __defProps19 = Object.defineProperties;
var __getOwnPropDescs19 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols24 = Object.getOwnPropertySymbols;
var __hasOwnProp24 = Object.prototype.hasOwnProperty;
var __propIsEnum24 = Object.prototype.propertyIsEnumerable;
var __defNormalProp24 = (obj, key, value) => key in obj ? __defProp24(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues24 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp24.call(b2, prop))
      __defNormalProp24(a2, prop, b2[prop]);
  if (__getOwnPropSymbols24)
    for (var prop of __getOwnPropSymbols24(b2)) {
      if (__propIsEnum24.call(b2, prop))
        __defNormalProp24(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps19 = (a2, b2) => __defProps19(a2, __getOwnPropDescs19(b2));
var _sfc_main14 = defineComponent({
  name: "VaBreadcrumbsItem",
  props: __spreadProps19(__spreadValues24({}, useRouterLinkProps), {
    disabled: { type: Boolean, default: false },
    label: { type: String, default: "" }
  }),
  setup: (props) => {
    const { tagComputed, hrefComputed, isLinkTag } = useRouterLink(props);
    const classComputed = computed(() => ({
      "va-breadcrumb-item--link": isLinkTag.value
    }));
    return { tagComputed, hrefComputed, classComputed };
  }
});
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-breadcrumb-item", _ctx.classComputed]),
    "active-class": _ctx.$props.activeClass,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to,
    target: _ctx.$props.target,
    replace: _ctx.$props.replace,
    append: _ctx.$props.append,
    exact: _ctx.$props.exact,
    "exact-active-class": _ctx.$props.exactActiveClass
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ]),
    _: 3
  }, 8, ["class", "active-class", "href", "to", "target", "replace", "append", "exact", "exact-active-class"]);
}
var _VaBreadcrumbsItem = _export_sfc(_sfc_main14, [["render", _sfc_render13]]);

// node_modules/vuestic-ui/dist/es/src/components/va-breadcrumbs/index.js
var VaBreadcrumbsItem = withConfigTransport(_VaBreadcrumbsItem);
var VaBreadcrumbs = withConfigTransport(_sfc_main13);

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/VaButtonDropdown.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/utils/child-props.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/utils/resolve-component-props.js
var __defProp25 = Object.defineProperty;
var __defProps20 = Object.defineProperties;
var __getOwnPropDescs20 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols25 = Object.getOwnPropertySymbols;
var __hasOwnProp25 = Object.prototype.hasOwnProperty;
var __propIsEnum25 = Object.prototype.propertyIsEnumerable;
var __defNormalProp25 = (obj, key, value) => key in obj ? __defProp25(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues25 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp25.call(b2, prop))
      __defNormalProp25(a2, prop, b2[prop]);
  if (__getOwnPropSymbols25)
    for (var prop of __getOwnPropSymbols25(b2)) {
      if (__propIsEnum25.call(b2, prop))
        __defNormalProp25(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps20 = (a2, b2) => __defProps20(a2, __getOwnPropDescs20(b2));
function normalizeProps2(props) {
  switch (true) {
    case Array.isArray(props):
      return props.reduce((acc, prop) => __spreadProps20(__spreadValues25({}, acc), { [prop]: null }), {});
    case (typeof props === "object" && props !== null):
      return props;
    default:
      return {};
  }
}
function mergeProps2(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps2(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m2) => mergeProps2(to, m2, optionsType));
  const props = normalizeProps2(from[optionsType]);
  for (const key in props) {
    to[key] = props[key];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return __spreadValues25(__spreadValues25({}, component.__vccOpts), component.__b);
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  var _a, _b;
  const mixins = (_a = options.mixins) != null ? _a : [];
  const extendsOptions = (_b = options.extends) != null ? _b : [];
  const result = {};
  mergeProps2(result, extendsOptions, optionsType);
  for (let i2 = 0; i2 < mixins.length; i2++) {
    mergeProps2(result, mixins[i2], optionsType);
  }
  Object.assign(result, normalizeProps2(options[optionsType]));
  return result;
}
var getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};

// node_modules/vuestic-ui/dist/es/src/utils/child-props.js
var filterComponentProps = (propsValues, childProps) => {
  return computed(() => {
    return Object.keys(childProps).reduce((acc, propName) => {
      acc[propName] = propsValues[propName];
      return acc;
    }, {});
  });
};
function extractComponentProps(component, ignoreProps) {
  const props = getComponentProps(component);
  if (ignoreProps) {
    return Object.keys(props).reduce((acc, propName) => {
      if (ignoreProps.includes(propName)) {
        return acc;
      }
      if (props[propName] === void 0) {
        return acc;
      }
      acc[propName] = typeof props[propName] === "string" ? {} : props[propName];
      return acc;
    }, {});
  }
  return props;
}
function extractComponentEmits(component) {
  return [...new Set(component.emits)];
}

// node_modules/vuestic-ui/dist/es/src/composables/useDropdown.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/utils/map-object.js
var mapObject = (o2, cb) => {
  const copy = {};
  Object.keys(o2).forEach((key) => {
    copy[key] = cb(o2[key], key);
  });
  return copy;
};

// node_modules/vuestic-ui/dist/es/src/composables/useDomRect.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useRequestAnimationFrame.js
init_vue_runtime_esm_bundler();
var useRequestAnimationFrame = (cb) => {
  let animationFrameRequest = -1;
  const observe = () => {
    animationFrameRequest = requestAnimationFrame(observe);
    cb();
  };
  onMounted(() => {
    observe();
  });
  onBeforeUnmount(() => {
    cancelAnimationFrame(animationFrameRequest);
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useDomRect.js
var keys2 = ["x", "y", "width", "height", "top", "left", "right", "bottom"];
var isDomRectEqual = (a2, b2) => {
  for (let i2 = 0; i2 < keys2.length; i2++) {
    if (a2[keys2[i2]] !== b2[keys2[i2]]) {
      return false;
    }
  }
  return true;
};
var useDomRect = (target) => {
  const domRect = ref(null);
  let prev = {};
  useRequestAnimationFrame(() => {
    if (!target.value) {
      return;
    }
    const rect = target.value.getBoundingClientRect();
    if (!isDomRectEqual(rect, prev)) {
      domRect.value = rect;
    }
    prev = rect;
  });
  watch(target, (newVal) => {
    if (newVal) {
      domRect.value = newVal.getBoundingClientRect();
    } else {
      domRect.value = null;
    }
  });
  return {
    domRect
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useDropdown.js
var __defProp26 = Object.defineProperty;
var __getOwnPropSymbols26 = Object.getOwnPropertySymbols;
var __hasOwnProp26 = Object.prototype.hasOwnProperty;
var __propIsEnum26 = Object.prototype.propertyIsEnumerable;
var __defNormalProp26 = (obj, key, value) => key in obj ? __defProp26(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues26 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp26.call(b2, prop))
      __defNormalProp26(a2, prop, b2[prop]);
  if (__getOwnPropSymbols26)
    for (var prop of __getOwnPropSymbols26(b2)) {
      if (__propIsEnum26.call(b2, prop))
        __defNormalProp26(a2, prop, b2[prop]);
    }
  return a2;
};
var placementsPositions = ["top", "bottom", "left", "right"].reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ["auto"]);
var coordsToCss = ({ x: x2, y: y2 }) => ({ left: `${x2}px`, top: `${y2}px` });
var parsePlacement = (placement) => {
  let [position, align] = placement.split("-");
  if (position === "auto") {
    position = "bottom";
  }
  return { position, align: align || "center" };
};
var parseOffset = (offset) => {
  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 };
};
var calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {
  if (align === "start") {
    return anchorStart;
  }
  if (align === "end") {
    return anchorStart + anchorSize - contentSize;
  }
  return anchorStart + (anchorSize - contentSize) / 2;
};
var calculateContentCoords = (placement, anchor, content) => {
  const { position, align } = parsePlacement(placement);
  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);
  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);
  switch (position) {
    case "top":
      return { x: alignmentX, y: anchor.top - content.height };
    case "left":
      return { y: alignmentY, x: anchor.left - content.width };
    case "right":
      return { y: alignmentY, x: anchor.right };
    case "bottom":
    default:
      return { x: alignmentX, y: anchor.bottom };
  }
};
var calculateOffsetCoords = (placement, offset) => {
  const { position } = parsePlacement(placement);
  const { main, cross } = parseOffset(offset);
  switch (position) {
    case "left":
      return { y: cross, x: -main };
    case "right":
      return { y: cross, x: main };
    case "top":
      return { y: -main, x: cross };
    case "bottom":
    default:
      return { y: main, x: cross };
  }
};
var calculateContentOverflow = (coords, content, viewport) => {
  const xMax = viewport.right;
  const yMax = viewport.bottom;
  const xMin = viewport.left;
  const yMin = viewport.top;
  return {
    top: Math.max(yMin - coords.y, 0),
    bottom: Math.max(coords.y + content.height - yMax, 0),
    left: Math.max(xMin - coords.x, 0),
    right: Math.max(coords.x + content.width - xMax, 0)
  };
};
var clamp2 = (min, v2, max) => Math.max(Math.min(v2, max), min);
var calculateClipToEdge = (coords, offsetCoords, content, anchor, viewport) => {
  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport);
  const x2 = coords.x - right + left;
  const y2 = coords.y - bottom + top;
  const { x: offsetX, y: offsetY } = offsetCoords;
  return {
    x: clamp2(anchor.left + offsetX - content.width, x2, anchor.right + offsetX),
    y: clamp2(anchor.top + offsetY - content.height, y2, anchor.bottom + offsetY)
  };
};
var getAutoPlacement = (placement, coords, content, viewport) => {
  const { position, align } = parsePlacement(placement);
  const overflow = calculateContentOverflow(coords, content, viewport);
  const newPlacements = {
    top: ["bottom", align].join("-"),
    bottom: ["top", align].join("-"),
    right: ["left", align].join("-"),
    left: ["right", align].join("-")
  };
  return overflow[position] ? newPlacements[position] : placement;
};
var findFirstRelativeParent = (el) => {
  while (el) {
    const positionValue = window.getComputedStyle(el).getPropertyValue("position") || el.style.position;
    if (positionValue === "relative") {
      return el;
    }
    el = el.parentElement;
  }
  return document.body;
};
var useDropdown = (anchorRef, contentRef, options) => {
  const documentRef = useClientOnly(() => document);
  const rootRef = computed(() => {
    if (!documentRef.value) {
      return void 0;
    }
    const { root: root2 } = unref(options);
    if (root2) {
      let el;
      if (typeof root2 === "string") {
        el = documentRef.value.querySelector(root2);
      } else {
        el = root2;
      }
      if (!el) {
        return documentRef.value.body;
      }
      return findFirstRelativeParent(el);
    }
    return documentRef.value.body;
  });
  const { domRect: anchorDomRect } = useDomRect(anchorRef);
  const { domRect: contentDomRect } = useDomRect(contentRef);
  const css = {
    width: "max-content",
    position: "absolute"
  };
  watchPostEffect(() => {
    var _a, _b;
    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {
      return;
    }
    const { placement, offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options);
    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value);
    let offsetCoords = { x: 0, y: 0 };
    if (offset) {
      offsetCoords = calculateOffsetCoords(placement, offset);
      coords = mapObject(coords, (c2, key) => c2 + offsetCoords[key]);
    }
    const rootRect = rootRef.value.getBoundingClientRect();
    const viewportRect = (_b = (_a = unref(options).viewport) == null ? void 0 : _a.getBoundingClientRect()) != null ? _b : rootRect;
    if (autoPlacement) {
      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, viewportRect);
      if (newPlacement !== placement) {
        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value);
        if (offset) {
          offsetCoords = calculateOffsetCoords(newPlacement, offset);
          coords = mapObject(coords, (c2, key) => c2 + offsetCoords[key]);
        }
      }
    }
    if (stickToEdges) {
      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect);
    }
    coords.x -= rootRect.x;
    coords.y -= rootRect.y;
    if (contentRef.value) {
      let widthCss = {};
      if (keepAnchorWidth) {
        const { width } = anchorDomRect.value;
        widthCss = { width: `${width}px`, maxWidth: `${width}px` };
      }
      Object.assign(contentRef.value.style, __spreadValues26(__spreadValues26(__spreadValues26({}, css), coordsToCss(coords)), widthCss));
    }
  });
  return {
    anchorDomRect,
    contentDomRect
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useEmitProxy.js
var __defProp27 = Object.defineProperty;
var __defProps21 = Object.defineProperties;
var __getOwnPropDescs21 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols27 = Object.getOwnPropertySymbols;
var __hasOwnProp27 = Object.prototype.hasOwnProperty;
var __propIsEnum27 = Object.prototype.propertyIsEnumerable;
var __defNormalProp27 = (obj, key, value) => key in obj ? __defProp27(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues27 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp27.call(b2, prop))
      __defNormalProp27(a2, prop, b2[prop]);
  if (__getOwnPropSymbols27)
    for (var prop of __getOwnPropSymbols27(b2)) {
      if (__propIsEnum27.call(b2, prop))
        __defNormalProp27(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps21 = (a2, b2) => __defProps21(a2, __getOwnPropDescs21(b2));
var getEvent = (event) => typeof event === "object" ? event.listen : event;
var getEmit = (event) => typeof event === "object" ? event.emit : event;
var useEmitProxy = (events) => {
  const createEmits3 = () => events.map(getEmit);
  const eventToListenerName = (event) => {
    const eventName = event.charAt(0).toUpperCase() + event.slice(1);
    return `on${eventName}`;
  };
  const createListeners3 = (emit) => {
    return events.reduce((acc, key) => __spreadProps21(__spreadValues27({}, acc), {
      [eventToListenerName(getEvent(key))]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  const createVOnListeners = (emit) => {
    return events.reduce((acc, key) => __spreadProps21(__spreadValues27({}, acc), {
      [getEvent(key)]: (...args) => emit(getEmit(key), ...args)
    }), {});
  };
  return {
    createListeners: createListeners3,
    createVOnListeners,
    createEmits: createEmits3
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-button-group/VaButtonGroup.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-button-group/VaButtonGroup.css";
var __defProp28 = Object.defineProperty;
var __defProps22 = Object.defineProperties;
var __getOwnPropDescs22 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols28 = Object.getOwnPropertySymbols;
var __hasOwnProp28 = Object.prototype.hasOwnProperty;
var __propIsEnum28 = Object.prototype.propertyIsEnumerable;
var __defNormalProp28 = (obj, key, value) => key in obj ? __defProp28(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues28 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp28.call(b2, prop))
      __defNormalProp28(a2, prop, b2[prop]);
  if (__getOwnPropSymbols28)
    for (var prop of __getOwnPropSymbols28(b2)) {
      if (__propIsEnum28.call(b2, prop))
        __defNormalProp28(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps22 = (a2, b2) => __defProps22(a2, __getOwnPropDescs22(b2));
var VaButtonProps = omit_1(extractComponentProps(VaButton2), ["block"]);
var _sfc_main15 = defineComponent({
  name: "VaButtonGroup",
  components: { VaConfig },
  props: __spreadProps22(__spreadValues28(__spreadValues28({}, VaButtonProps), useComponentPresetProp), {
    grow: {
      type: Boolean,
      default: false
    }
  }),
  setup: (props) => {
    const buttonConfig = computed(() => ({ VaButton: __spreadValues28({}, props) }));
    const computedClass = useBem("va-button-group", () => ({
      square: !props.round,
      grow: props.grow,
      small: props.size === "small",
      large: props.size === "large"
    }));
    return { buttonConfig, computedClass };
  }
});
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-button-group", _ctx.computedClass])
  }, [
    createVNode(_component_va_config, { components: _ctx.buttonConfig }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["components"])
  ], 2);
}
var _VaButtonGroup = _export_sfc(_sfc_main15, [["render", _sfc_render14]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button-group/index.js
var VaButtonGroup = withConfigTransport(_VaButtonGroup);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/VaDropdown.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useClickOutside.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useCaptureEvent.js
init_vue_runtime_esm_bundler();
var __defProp29 = Object.defineProperty;
var __getOwnPropSymbols29 = Object.getOwnPropertySymbols;
var __hasOwnProp29 = Object.prototype.hasOwnProperty;
var __propIsEnum29 = Object.prototype.propertyIsEnumerable;
var __defNormalProp29 = (obj, key, value) => key in obj ? __defProp29(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues29 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp29.call(b2, prop))
      __defNormalProp29(a2, prop, b2[prop]);
  if (__getOwnPropSymbols29)
    for (var prop of __getOwnPropSymbols29(b2)) {
      if (__propIsEnum29.call(b2, prop))
        __defNormalProp29(a2, prop, b2[prop]);
    }
  return a2;
};
var useCaptureEvent = (event, cb, options = {}) => {
  onMounted(() => window.addEventListener(event, cb, __spreadValues29({ capture: true }, options)));
  onBeforeUnmount(() => window.removeEventListener(event, cb, __spreadValues29({ capture: true }, options)));
};

// node_modules/vuestic-ui/dist/es/src/composables/useClickOutside.js
var checkIfElementChild = (parent2, child) => {
  if (!child) {
    return false;
  }
  if (child.parentElement === parent2) {
    return true;
  }
  return parent2.contains(child);
};
var safeArray = (a2) => Array.isArray(a2) ? a2 : [a2];
var useClickOutside = (elements, cb) => {
  useCaptureEvent("click", (event) => {
    const clickTarget = event.target;
    const isClickInside = safeArray(elements).some((element) => unref(element) && checkIfElementChild(unref(element), clickTarget));
    if (!isClickInside) {
      cb(clickTarget);
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useDebounce.js
init_vue_runtime_esm_bundler();
var useDebounceFn = (timeout) => {
  let callback = null;
  const createDebounced = () => {
    return debounce_1(() => {
      callback == null ? void 0 : callback();
      callback = null;
    }, unref(timeout));
  };
  let debounced = createDebounced();
  if (isRef(timeout)) {
    watch(timeout, () => {
      debounced = createDebounced();
    });
  }
  return {
    debounced: (cb) => {
      callback = cb;
      debounced();
    },
    cancel: () => debounced.cancel()
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useHTMLElementSelector.js
init_vue_runtime_esm_bundler();
var useHTMLElementSelector = (key) => {
  return computed(() => {
    if (typeof (key == null ? void 0 : key.value) === "string") {
      return document.querySelector(key.value);
    }
    return extractHTMLElement(key == null ? void 0 : key.value);
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useIsMounted.js
init_vue_runtime_esm_bundler();
var useIsMounted = () => {
  const isMounted = ref(false);
  onMounted(() => {
    isMounted.value = true;
  });
  onBeforeUnmount(() => {
    isMounted.value = false;
  });
  return isMounted;
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useAnchorSelector.js
init_vue_runtime_esm_bundler();
var useAnchorSelector = (props) => {
  const anchorRef = ref();
  const document2 = useDocument();
  const computedAnchorRef = computed({
    set(v2) {
      anchorRef.value = v2;
    },
    get() {
      var _a, _b, _c, _d;
      if (props.anchorSelector) {
        return (_b = (_a = document2.value) == null ? void 0 : _a.querySelector(props.anchorSelector)) != null ? _b : anchorRef.value;
      } else if (props.innerAnchorSelector && anchorRef.value) {
        return (_d = (_c = anchorRef.value) == null ? void 0 : _c.querySelector(props.innerAnchorSelector)) != null ? _d : anchorRef.value;
      }
      return anchorRef.value;
    }
  });
  return {
    anchorRef: computedAnchorRef
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useCursorAnchor.js
init_vue_runtime_esm_bundler();
var __defProp30 = Object.defineProperty;
var __defProps23 = Object.defineProperties;
var __getOwnPropDescs23 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols30 = Object.getOwnPropertySymbols;
var __hasOwnProp30 = Object.prototype.hasOwnProperty;
var __propIsEnum30 = Object.prototype.propertyIsEnumerable;
var __defNormalProp30 = (obj, key, value) => key in obj ? __defProp30(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues30 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp30.call(b2, prop))
      __defNormalProp30(a2, prop, b2[prop]);
  if (__getOwnPropSymbols30)
    for (var prop of __getOwnPropSymbols30(b2)) {
      if (__propIsEnum30.call(b2, prop))
        __defNormalProp30(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps23 = (a2, b2) => __defProps23(a2, __getOwnPropDescs23(b2));
var useCursorAnchor = (anchorRef, noUpdate) => {
  const mouse = reactive({ x: 0, y: 0 });
  useEvent(["mousemove", "mousedown", "mouseup"], (e2) => {
    const { x: x2, y: y2 } = anchorRef.value.getBoundingClientRect();
    mouse.x = e2.clientX - x2;
    mouse.y = e2.clientY - y2;
  }, anchorRef);
  const mouseOffset = {
    x: 0,
    y: 0
  };
  watchEffect(() => {
    if (noUpdate.value) {
      return;
    }
    mouseOffset.x = mouse.x;
    mouseOffset.y = mouse.y;
  });
  return computed(() => {
    if (!anchorRef.value) {
      return void 0;
    }
    const target = anchorRef.value;
    const getBoundingClientRect = () => {
      const rect = target.getBoundingClientRect();
      const x2 = rect.left + mouseOffset.x;
      const y2 = rect.top + mouseOffset.y;
      return __spreadProps23(__spreadValues30({}, rect), {
        x: x2,
        y: y2,
        bottom: y2 + 1,
        right: x2 + 1,
        left: x2,
        top: y2
      });
    };
    return new Proxy(target, {
      get(target2, key) {
        if (key === "getBoundingClientRect") {
          return getBoundingClientRect;
        }
        return target2[key];
      }
    });
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/hooks/useDropdownNavigation.js
var isTyping = (e2) => {
  const target = e2.target;
  if (!(target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
    return false;
  }
  if (target.attributes.getNamedItem("readonly")) {
    return false;
  }
  return true;
};
var openKey = ["ArrowDown", "ArrowUp", "Enter", "Space"];
var useKeyboardNavigation = (anchorRef, isOpened) => {
  useEvent("keydown", (e2) => {
    if (isTyping(e2)) {
      return;
    }
    if (!openKey.includes(e2.key)) {
      return;
    }
    isOpened.value = !isOpened.value;
    e2.preventDefault();
  }, anchorRef);
  useEvent("keydown", (e2) => {
    if (e2.key === "Escape" && isOpened.value) {
      isOpened.value = false;
      e2.preventDefault();
    }
  }, true);
};
var useMouseNavigation = (anchorRef, listeners) => {
  useEvent(["click", "contextmenu", "dblclick"], (e2) => {
    if (isTyping(e2)) {
      return;
    }
    listeners[e2.type](e2);
  }, anchorRef);
  useEvent(["mouseleave", "mouseenter"], (e2) => {
    listeners[e2.type](e2);
  }, anchorRef);
};

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/VaDropdown.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-dropdown/VaDropdown.css";
var __defProp31 = Object.defineProperty;
var __defProps24 = Object.defineProperties;
var __getOwnPropDescs24 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols31 = Object.getOwnPropertySymbols;
var __hasOwnProp31 = Object.prototype.hasOwnProperty;
var __propIsEnum31 = Object.prototype.propertyIsEnumerable;
var __defNormalProp31 = (obj, key, value) => key in obj ? __defProp31(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues31 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp31.call(b2, prop))
      __defNormalProp31(a2, prop, b2[prop]);
  if (__getOwnPropSymbols31)
    for (var prop of __getOwnPropSymbols31(b2)) {
      if (__propIsEnum31.call(b2, prop))
        __defNormalProp31(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps24 = (a2, b2) => __defProps24(a2, __getOwnPropDescs24(b2));
var _sfc_main16 = defineComponent({
  name: "VaDropdown",
  props: __spreadProps24(__spreadValues31(__spreadValues31({}, createStatefulProps(Boolean, true)), useComponentPresetProp), {
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    target: { type: String, default: void 0 },
    preventOverflow: { type: Boolean, default: false },
    keepAnchorWidth: { type: Boolean, default: false },
    isContentHoverable: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: Number, default: 30 },
    hoverOutTimeout: { type: Number, default: 200 },
    offset: { type: [Array, Number], default: 0 },
    stickToEdges: { type: Boolean, default: false },
    autoPlacement: { type: Boolean, default: true },
    cursor: { type: Boolean, default: false },
    trigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "right-click", "hover", "dblclick", "none"].includes(value)
    },
    placement: {
      type: String,
      default: "auto",
      validator: (value) => placementsPositions.includes(value)
    },
    keyboardNavigation: { type: Boolean, default: false }
  }),
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "close", "open"],
  setup(props, { emit }) {
    const contentRef = shallowRef();
    const { valueComputed: statefulVal } = useStateful(props, emit);
    const valueComputed = computed({
      get: () => statefulVal.value && !props.disabled && !props.readonly,
      set(val) {
        statefulVal.value = val;
        if (val) {
          emit("open");
        } else {
          emit("close");
        }
      }
    });
    const computedClass = useBem("va-dropdown", () => pick_1(props, ["disabled"]));
    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, "hoverOverTimeout"));
    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, "hoverOutTimeout"));
    const onMouseEnter = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      debounceHover(() => {
        valueComputed.value = true;
      });
      cancelUnHoverDebounce();
    };
    const onMouseLeave = () => {
      if (props.trigger !== "hover" || props.disabled) {
        return;
      }
      if (props.isContentHoverable) {
        debounceUnHover(() => {
          valueComputed.value = false;
        });
      } else {
        valueComputed.value = false;
      }
      cancelHoverDebounce();
    };
    const emitAndClose = (eventName, close, e2) => {
      emit(eventName, e2);
      if (close && props.trigger !== "none") {
        valueComputed.value = false;
      }
    };
    const elRef = useHTMLElement("anchorRef");
    if (props.keyboardNavigation) {
      useKeyboardNavigation(elRef, valueComputed);
    }
    useMouseNavigation(elRef, {
      click(e2) {
        if (props.trigger !== "click" && kebabCase_1(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-click", props.closeOnAnchorClick, e2);
        } else {
          if (props.trigger !== "click") {
            return;
          }
          valueComputed.value = true;
          emit("anchor-click", e2);
        }
      },
      contextmenu(e2) {
        if (kebabCase_1(props.trigger) !== "right-click" || props.disabled) {
          return;
        }
        e2.preventDefault();
        if (valueComputed.value) {
          emitAndClose("anchor-right-click", props.closeOnAnchorClick, e2);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-right-click", e2);
        }
      },
      dblclick(e2) {
        if (props.trigger !== "dblclick" || props.disabled) {
          return;
        }
        if (valueComputed.value) {
          emitAndClose("anchor-dblclick", props.closeOnAnchorClick, e2);
          if (props.cursor) {
            nextTick(() => {
              valueComputed.value = true;
            });
          }
        } else {
          valueComputed.value = true;
          emit("anchor-dblclick", e2);
        }
      },
      mouseenter: onMouseEnter,
      mouseleave: onMouseLeave
    });
    const { anchorRef: computedAnchorRef } = useAnchorSelector(props);
    useClickOutside([computedAnchorRef, contentRef], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    const cursorAnchor = useCursorAnchor(computedAnchorRef, valueComputed);
    const document2 = useDocument();
    const isPopoverFloating = computed(() => props.preventOverflow || props.cursor);
    const target = useHTMLElementSelector(computed(() => props.target || "body"));
    const targetComputed = computed(() => {
      var _a, _b, _c;
      if (computedAnchorRef.value && !((_b = (_a = target.value) == null ? void 0 : _a.contains) == null ? void 0 : _b.call(_a, computedAnchorRef.value))) {
        return (_c = document2.value) == null ? void 0 : _c.body;
      }
      return target.value;
    });
    const teleportTargetComputed = computed(() => {
      if (!isPopoverFloating.value) {
        return elRef.value;
      }
      return targetComputed.value;
    });
    const teleportDisabled = computed(() => props.disabled || !isPopoverFloating.value);
    useDropdown(computed(() => props.cursor ? cursorAnchor.value : computedAnchorRef.value), contentRef, computed(() => ({
      placement: props.placement,
      keepAnchorWidth: props.keepAnchorWidth,
      offset: props.offset,
      stickToEdges: props.stickToEdges,
      autoPlacement: props.autoPlacement,
      root: teleportTargetComputed.value,
      viewport: targetComputed.value
    })));
    const idComputed = computed(generateUniqueId);
    return __spreadProps24(__spreadValues31({}, useTranslation()), {
      teleportTargetComputed,
      teleportDisabled,
      isMounted: useIsMounted(),
      anchorRef: computedAnchorRef,
      valueComputed,
      contentRef,
      computedClass,
      idComputed,
      emitAndClose,
      onMouseEnter,
      onMouseLeave,
      hide: () => {
        valueComputed.value = false;
      },
      show: () => {
        valueComputed.value = true;
      }
    });
  }
});
var _hoisted_110 = ["aria-label", "aria-disabled", "aria-expanded", "aria-controls"];
var _hoisted_26 = ["id"];
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-dropdown", _ctx.computedClass]),
    ref: "anchorRef",
    role: "button",
    "aria-label": _ctx.t("toggleDropdown"),
    "aria-disabled": _ctx.$props.disabled,
    "aria-expanded": !!_ctx.valueComputed,
    "aria-controls": _ctx.idComputed,
    style: { "position": "relative" }
  }, [
    renderSlot(_ctx.$slots, "anchor", normalizeProps(guardReactiveProps({ value: _ctx.valueComputed, hide: _ctx.hide, show: _ctx.show }))),
    _ctx.isMounted ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: _ctx.teleportTargetComputed,
      disabled: _ctx.teleportDisabled
    }, [
      _ctx.valueComputed ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "contentRef",
        class: "va-dropdown__content-wrapper",
        id: _ctx.idComputed,
        onMouseover: _cache[0] || (_cache[0] = ($event) => _ctx.$props.isContentHoverable && _ctx.onMouseEnter()),
        onMouseout: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.emitAndClose("content-click", _ctx.closeOnContentClick), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.valueComputed, hide: _ctx.hide, show: _ctx.show })))
      ], 40, _hoisted_26)) : createCommentVNode("", true)
    ], 8, ["to", "disabled"])) : createCommentVNode("", true)
  ], 10, _hoisted_110);
}
var _VaDropdown = _export_sfc(_sfc_main16, [["render", _sfc_render15]]);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/index.js
var VaDropdown = withConfigTransport(_VaDropdown);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-dropdown/components/VaDropdownContent/VaDropdownContent.css";
var _sfc_main17 = defineComponent({
  name: "VaDropdownContent",
  props: {
    noPadding: { type: Boolean, default: false },
    background: { type: String, default: "background-secondary" },
    textColor: { type: String }
  },
  setup(props) {
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const computedStyle = computed(() => ({
      background: getColor(props.background, void 0, true),
      color: textColorComputed.value,
      padding: props.noPadding ? 0 : void 0
    }));
    return { computedStyle };
  }
});
function _sfc_render16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-dropdown__content",
    style: normalizeStyle(_ctx.computedStyle),
    role: "listbox"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaDropdownContent = _export_sfc(_sfc_main17, [["render", _sfc_render16]]);

// node_modules/vuestic-ui/dist/es/src/components/va-dropdown/components/VaDropdownContent/index.js
var VaDropdownContent = withConfigTransport(_VaDropdownContent);

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/VaButtonDropdown.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/VaButtonDropdown.css";
var __defProp32 = Object.defineProperty;
var __defProps25 = Object.defineProperties;
var __getOwnPropDescs25 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols32 = Object.getOwnPropertySymbols;
var __hasOwnProp32 = Object.prototype.hasOwnProperty;
var __propIsEnum32 = Object.prototype.propertyIsEnumerable;
var __defNormalProp32 = (obj, key, value) => key in obj ? __defProp32(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues32 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp32.call(b2, prop))
      __defNormalProp32(a2, prop, b2[prop]);
  if (__getOwnPropSymbols32)
    for (var prop of __getOwnPropSymbols32(b2)) {
      if (__propIsEnum32.call(b2, prop))
        __defNormalProp32(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps25 = (a2, b2) => __defProps25(a2, __getOwnPropDescs25(b2));
var { createEmits, createVOnListeners: createListeners } = useEmitProxy(["click"]);
var { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = useEmitProxy([{ listen: "click", emit: "main-button-click" }]);
var VaButtonProps2 = omit_1(extractComponentProps(VaButton2), ["iconRight", "block"]);
var VaDropdownProps = extractComponentProps(VaDropdown);
var _sfc_main18 = defineComponent({
  name: "VaButtonDropdown",
  components: {
    VaButton: VaButton2,
    VaDropdown,
    VaButtonGroup,
    VaDropdownContent
  },
  emits: ["update:modelValue", ...createEmits(), ...createMainButtonEmits()],
  props: __spreadProps25(__spreadValues32(__spreadValues32(__spreadValues32(__spreadValues32({}, useComponentPresetProp), VaButtonProps2), VaDropdownProps), useStatefulProps), {
    modelValue: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    icon: { type: String, default: "va-arrow-down" },
    openedIcon: { type: String, default: "va-arrow-up" },
    hideIcon: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    disableButton: { type: Boolean, default: false },
    disableDropdown: { type: Boolean, default: false },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => placementsPositions.includes(placement)
    },
    offset: { type: [Number, Array], default: 2 },
    keepAnchorWidth: { type: Boolean, default: false },
    closeOnContentClick: { type: Boolean, default: true },
    split: { type: Boolean },
    splitTo: { type: String, default: "" },
    splitHref: { type: String, default: "" },
    loading: { type: Boolean, default: false },
    label: { type: String }
  }),
  setup(props, { emit, slots }) {
    const { valueComputed } = useStateful(props, emit);
    const computedIcon = computed(() => valueComputed.value ? props.openedIcon : props.icon);
    const computedClass = useBem("va-button-dropdown", () => ({
      split: props.split
    }));
    const computedButtonIcons = computed(() => {
      if (props.hideIcon) {
        return {};
      }
      const propName = (props.label || slots.label) && !props.leftIcon ? "icon-right" : "icon";
      return { [propName]: computedIcon.value };
    });
    const buttonPropsFiltered = computed(() => {
      let ignoredProps = ["to", "href", "loading", "icon"];
      const presetProps = [
        "plain",
        "textOpacity",
        "backgroundOpacity",
        "hoverOpacity",
        "hoverBehavior",
        "hoverOpacity",
        "pressedOpacity",
        "pressedBehavior",
        "pressedOpacity"
      ];
      if (props.preset) {
        ignoredProps = [...ignoredProps, ...presetProps];
      }
      const filteredProps = omit_1(VaButtonProps2, ignoredProps);
      return Object.keys(filteredProps);
    });
    const buttonPropsComputed = computed(() => Object.entries(props).filter(([key, _2]) => buttonPropsFiltered.value.includes(key)).reduce((acc, [key, value]) => {
      Object.assign(acc, { [key]: value });
      return acc;
    }, {}));
    const computedMainButtonProps = computed(() => ({
      to: props.splitTo,
      href: props.splitHref,
      loading: props.loading
    }));
    const splitButtonClassComputed = computed(() => ({ "va-button-group__left-icon": props.leftIcon }));
    const hideDropdown = () => {
      valueComputed.value = false;
    };
    return __spreadProps25(__spreadValues32({}, useTranslation()), {
      vaDropdownProps: filterComponentProps(props, VaDropdownProps),
      hideDropdown,
      valueComputed,
      computedIcon,
      computedClass,
      computedButtonIcons,
      buttonPropsComputed,
      computedMainButtonProps,
      splitButtonClassComputed,
      listeners: createListeners(emit),
      mainButtonListeners: createMainButtonListeners(emit)
    });
  }
});
function _sfc_render17(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-button-dropdown", _ctx.computedClass])
  }, [
    !_ctx.$props.split ? (openBlock(), createBlock(_component_va_dropdown, mergeProps({ key: 0 }, _ctx.vaDropdownProps, {
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event),
      disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
    }), {
      anchor: withCtx(() => [
        createVNode(_component_va_button, mergeProps(__spreadValues32(__spreadValues32({}, _ctx.computedButtonIcons), _ctx.buttonPropsComputed), toHandlers(_ctx.listeners), {
          onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["onKeydown"])
      ]),
      default: withCtx(() => [
        createVNode(_component_va_dropdown_content, null, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["modelValue", "disabled"])) : (openBlock(), createBlock(_component_va_button_group, mergeProps({
      key: 1,
      class: _ctx.splitButtonClassComputed
    }, _ctx.buttonPropsComputed), {
      default: withCtx(() => [
        !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 0,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("", true),
        createVNode(_component_va_dropdown, mergeProps({
          modelValue: _ctx.valueComputed,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
        }, _ctx.vaDropdownProps, {
          disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
        }), {
          anchor: withCtx(() => [
            createVNode(_component_va_button, mergeProps({
              "aria-label": _ctx.t("toggleDropdown"),
              disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
              icon: _ctx.computedIcon
            }, toHandlers(_ctx.listeners), {
              onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"])
            }), null, 16, ["aria-label", "disabled", "icon", "onKeydown"])
          ]),
          default: withCtx(() => [
            createVNode(_component_va_dropdown_content, null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["modelValue", "disabled"]),
        _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_button, mergeProps({
          key: 1,
          disabled: _ctx.$props.disabled || _ctx.$props.disableButton
        }, _ctx.computedMainButtonProps, toHandlers(_ctx.mainButtonListeners)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["disabled"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["class"]))
  ], 2);
}
var _VaButtonDropdown = _export_sfc(_sfc_main18, [["render", _sfc_render17]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button-dropdown/index.js
var VaButtonDropdown = withConfigTransport(_VaButtonDropdown);

// node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/VaButtonToggle.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/VaButtonToggle.css";
var __defProp33 = Object.defineProperty;
var __defProps26 = Object.defineProperties;
var __getOwnPropDescs26 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols33 = Object.getOwnPropertySymbols;
var __hasOwnProp33 = Object.prototype.hasOwnProperty;
var __propIsEnum33 = Object.prototype.propertyIsEnumerable;
var __defNormalProp33 = (obj, key, value) => key in obj ? __defProp33(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues33 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp33.call(b2, prop))
      __defNormalProp33(a2, prop, b2[prop]);
  if (__getOwnPropSymbols33)
    for (var prop of __getOwnPropSymbols33(b2)) {
      if (__propIsEnum33.call(b2, prop))
        __defNormalProp33(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps26 = (a2, b2) => __defProps26(a2, __getOwnPropDescs26(b2));
var VaButtonGroupProps = extractComponentProps(VaButtonGroup);
var _sfc_main19 = defineComponent({
  name: "VaButtonToggle",
  components: {
    VaButtonGroup,
    VaButton: VaButton2
  },
  emits: ["update:modelValue"],
  props: __spreadProps26(__spreadValues33(__spreadValues33({}, VaButtonGroupProps), useComponentPresetProp), {
    modelValue: { type: [String, Number], default: "" },
    options: {
      type: Array,
      required: true
    },
    activeButtonTextColor: { type: String },
    toggleColor: { type: String, default: "" }
  }),
  setup(props, { emit }) {
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    VaButtonGroupProps.color;
    const colorComputed = computed(() => getColor(props.color));
    const isToggled = (value) => value === props.modelValue;
    const activeButtonColor = computed(() => {
      if (props.toggleColor) {
        return getColor(props.toggleColor);
      }
      return shiftHSLAColor2(colorComputed.value, { l: props.plain ? -16 : -6 });
    });
    const activeButtonBackgroundOpacityComputed = computed(() => {
      if (!props.preset || props.preset === "default") {
        return {};
      }
      return { backgroundOpacity: props.pressedOpacity };
    });
    const activeButtonPropsComputed = computed(() => __spreadValues33({
      color: activeButtonColor.value,
      textColor: props.activeButtonTextColor
    }, activeButtonBackgroundOpacityComputed.value));
    const getButtonProps = (option = {}) => {
      const iconsProps = { icon: option.icon, iconRight: option.iconRight };
      if (!isToggled(option.value)) {
        return iconsProps;
      }
      return __spreadValues33(__spreadValues33({}, isToggled(option.value) && activeButtonPropsComputed.value), iconsProps);
    };
    const buttonGroupPropsComputed = computed(() => omit_1(props, ["modelValue", "options", "activeButtonTextColor", "toggleColor"]));
    const changeValue = (value) => emit("update:modelValue", value);
    return {
      buttonGroupPropsComputed,
      getButtonProps,
      changeValue,
      isToggled
    };
  }
});
function _sfc_render18(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_button_group = resolveComponent("va-button-group");
  return openBlock(), createBlock(_component_va_button_group, mergeProps({ class: "va-button-toggle" }, _ctx.buttonGroupPropsComputed), {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option) => {
        return openBlock(), createBlock(_component_va_button, mergeProps({
          key: option.value,
          "aria-pressed": _ctx.isToggled(option.value)
        }, _ctx.getButtonProps(option), {
          onClick: ($event) => _ctx.changeValue(option.value)
        }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(option.label), 1)
          ]),
          _: 2
        }, 1040, ["aria-pressed", "onClick"]);
      }), 128))
    ]),
    _: 1
  }, 16);
}
var _VaButtonToggle = _export_sfc(_sfc_main19, [["render", _sfc_render18]]);

// node_modules/vuestic-ui/dist/es/src/components/va-button-toggle/index.js
var VaButtonToggle = withConfigTransport(_VaButtonToggle);

// node_modules/vuestic-ui/dist/es/src/components/va-card/VaCard.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-card/VaCard.css";
var __defProp34 = Object.defineProperty;
var __defProps27 = Object.defineProperties;
var __getOwnPropDescs27 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols34 = Object.getOwnPropertySymbols;
var __hasOwnProp34 = Object.prototype.hasOwnProperty;
var __propIsEnum34 = Object.prototype.propertyIsEnumerable;
var __defNormalProp34 = (obj, key, value) => key in obj ? __defProp34(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues34 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp34.call(b2, prop))
      __defNormalProp34(a2, prop, b2[prop]);
  if (__getOwnPropSymbols34)
    for (var prop of __getOwnPropSymbols34(b2)) {
      if (__propIsEnum34.call(b2, prop))
        __defNormalProp34(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps27 = (a2, b2) => __defProps27(a2, __getOwnPropDescs27(b2));
var _sfc_main20 = defineComponent({
  name: "VaCard",
  emits: ["click"],
  props: __spreadProps27(__spreadValues34(__spreadValues34({}, useRouterLinkProps), useComponentPresetProp), {
    tag: { type: String, default: "div" },
    square: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    bordered: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    target: { type: String, default: "" },
    stripe: { type: Boolean, default: false },
    stripeColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    textColor: { type: String },
    color: { type: String, default: "background-secondary" }
  }),
  setup(props) {
    const { getColor } = useColors();
    const { isLinkTag, tagComputed, hrefComputed } = useRouterLink(props);
    const { textColorComputed } = useTextColor();
    const stripeStyles = computed(() => ({ background: getColor(props.stripeColor) }));
    const cardClasses = computed(() => ({
      "va-card--square": props.square,
      "va-card--outlined": props.outlined,
      "va-card--no-border": !props.bordered,
      "va-card--disabled": props.disabled,
      "va-card--link": isLinkTag.value
    }));
    const cardStyles = computed(() => {
      if (props.gradient && props.color) {
        return {
          background: getGradientBackground(getColor(props.color)),
          color: textColorComputed.value
        };
      }
      return { background: getColor(props.color), color: textColorComputed.value };
    });
    return {
      cardClasses,
      cardStyles,
      stripeStyles,
      tagComputed,
      hrefComputed
    };
  }
});
function _sfc_render19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-card", _ctx.cardClasses]),
    style: normalizeStyle(_ctx.cardStyles),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass
  }, {
    default: withCtx(() => [
      _ctx.stripe ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-card__stripe",
        style: normalizeStyle(_ctx.stripeStyles)
      }, null, 4)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: "va-card__inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
      }, [
        renderSlot(_ctx.$slots, "default")
      ])
    ]),
    _: 3
  }, 8, ["class", "style", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class"]);
}
var _VaCard = _export_sfc(_sfc_main20, [["render", _sfc_render19]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/VaCardContent.js
init_vue_runtime_esm_bundler();
var _sfc_main21 = defineComponent({
  name: "VaCardContent"
});
var _hoisted_111 = { class: "va-card__content" };
function _sfc_render20(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_111, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var VaCardContentBase = _export_sfc(_sfc_main21, [["render", _sfc_render20]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/VaCardTitle.js
init_vue_runtime_esm_bundler();
var __defProp35 = Object.defineProperty;
var __defProps28 = Object.defineProperties;
var __getOwnPropDescs28 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols35 = Object.getOwnPropertySymbols;
var __hasOwnProp35 = Object.prototype.hasOwnProperty;
var __propIsEnum35 = Object.prototype.propertyIsEnumerable;
var __defNormalProp35 = (obj, key, value) => key in obj ? __defProp35(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues35 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp35.call(b2, prop))
      __defNormalProp35(a2, prop, b2[prop]);
  if (__getOwnPropSymbols35)
    for (var prop of __getOwnPropSymbols35(b2)) {
      if (__propIsEnum35.call(b2, prop))
        __defNormalProp35(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps28 = (a2, b2) => __defProps28(a2, __getOwnPropDescs28(b2));
var _sfc_main22 = defineComponent({
  name: "VaCardTitle",
  props: __spreadProps28(__spreadValues35({}, useComponentPresetProp), {
    textColor: { type: String }
  }),
  setup(props) {
    const { getColor } = useColors();
    return {
      titleStyles: computed(() => ({
        color: props.textColor ? getColor(props.textColor) : ""
      }))
    };
  }
});
function _sfc_render21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-card__title",
    style: normalizeStyle(_ctx.titleStyles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var VaCardTitleBase = _export_sfc(_sfc_main22, [["render", _sfc_render21]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/VaCardActions.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-card/VaCardActions.css";
var __defProp36 = Object.defineProperty;
var __getOwnPropSymbols36 = Object.getOwnPropertySymbols;
var __hasOwnProp36 = Object.prototype.hasOwnProperty;
var __propIsEnum36 = Object.prototype.propertyIsEnumerable;
var __defNormalProp36 = (obj, key, value) => key in obj ? __defProp36(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues36 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp36.call(b2, prop))
      __defNormalProp36(a2, prop, b2[prop]);
  if (__getOwnPropSymbols36)
    for (var prop of __getOwnPropSymbols36(b2)) {
      if (__propIsEnum36.call(b2, prop))
        __defNormalProp36(a2, prop, b2[prop]);
    }
  return a2;
};
var _sfc_main23 = defineComponent({
  name: "VaCardActions",
  props: __spreadValues36(__spreadValues36({}, useAlignProps), useComponentPresetProp),
  setup(props) {
    const { alignComputed } = useAlign(props);
    return {
      alignComputed
    };
  }
});
function _sfc_render22(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.vertical ? "va-card__actions_vertical" : "va-card__actions"]),
    style: normalizeStyle(_ctx.alignComputed)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var VaCardActionsBase = _export_sfc(_sfc_main23, [["render", _sfc_render22]]);

// node_modules/vuestic-ui/dist/es/src/components/va-card/index.js
var VaCardContent = withConfigTransport(VaCardContentBase);
var VaCardTitle = withConfigTransport(VaCardTitleBase);
var VaCardActions = withConfigTransport(VaCardActionsBase);
var VaCard = withConfigTransport(_VaCard);

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/VaCarousel.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarousel.js
init_vue_runtime_esm_bundler();
var useCarousel = (props, currentSlide) => {
  const goTo = (index) => {
    currentSlide.value = index;
  };
  const prev = () => {
    if (props.infinite) {
      if (currentSlide.value <= 0) {
        currentSlide.value = props.items.length - 1;
        return;
      }
    }
    currentSlide.value -= 1;
  };
  const next = () => {
    if (props.infinite) {
      if (currentSlide.value >= props.items.length - 1) {
        currentSlide.value = 0;
        return;
      }
    }
    currentSlide.value += 1;
  };
  const doShowPrevButton = computed(() => currentSlide.value > 0 || props.infinite);
  const doShowNextButton = computed(() => currentSlide.value < props.items.length - 1 || props.infinite);
  return {
    doShowPrevButton,
    doShowNextButton,
    goTo,
    prev,
    next
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarouselAnimation.js
init_vue_runtime_esm_bundler();
var __defProp37 = Object.defineProperty;
var __defProps29 = Object.defineProperties;
var __getOwnPropDescs29 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols37 = Object.getOwnPropertySymbols;
var __hasOwnProp37 = Object.prototype.hasOwnProperty;
var __propIsEnum37 = Object.prototype.propertyIsEnumerable;
var __defNormalProp37 = (obj, key, value) => key in obj ? __defProp37(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues37 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp37.call(b2, prop))
      __defNormalProp37(a2, prop, b2[prop]);
  if (__getOwnPropSymbols37)
    for (var prop of __getOwnPropSymbols37(b2)) {
      if (__propIsEnum37.call(b2, prop))
        __defNormalProp37(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps29 = (a2, b2) => __defProps29(a2, __getOwnPropDescs29(b2));
var useCarouselAnimation = (props, currentSlide) => {
  let animationInterval = -1;
  let direction = 1;
  const start = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    animationInterval = setInterval(() => {
      if (props.infinite) {
        currentSlide.value += 1;
        if (currentSlide.value >= props.items.length) {
          currentSlide.value = 0;
        }
      } else {
        if (currentSlide.value <= 0) {
          direction = 1;
        }
        if (currentSlide.value >= props.items.length - 1) {
          direction = -1;
        }
        currentSlide.value += direction;
      }
    }, props.autoscrollInterval);
  };
  let pauseTimeout;
  const pause = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    pauseTimeout = setTimeout(() => {
      start();
      clearTimeout(pauseTimeout);
    }, props.autoscrollPauseDuration);
  };
  const stop = () => {
    clearInterval(animationInterval);
    clearTimeout(pauseTimeout);
  };
  onMounted(() => start());
  onBeforeUnmount(() => stop());
  const withPause = (fn) => {
    return (...args) => {
      pause();
      fn(...args);
    };
  };
  const slidesContainerStyle = ref({
    transition: void 0
  });
  const sliderToBeShown = ref(0);
  const computedSlidesStyle = computed(() => {
    if (props.effect === "fade") {
      return __spreadProps29(__spreadValues37({}, slidesContainerStyle.value), {
        transition: "none"
      });
    }
    if (props.vertical) {
      return __spreadProps29(__spreadValues37({}, slidesContainerStyle.value), {
        transform: `translateY(${sliderToBeShown.value * -100}%)`
      });
    }
    return __spreadProps29(__spreadValues37({}, slidesContainerStyle.value), {
      transform: `translateX(${sliderToBeShown.value * -100}%)`
    });
  });
  const animator = {
    isAnimating: false,
    speed: 0.3,
    order: [],
    move(from, to) {
      const last2 = props.items.length - 1;
      const firstAfterLast = props.items.length;
      if (to === 0 && from === last2) {
        this.order.push({ to: firstAfterLast });
        this.order.push({ to: 0, animate: false });
      } else if (to === last2 && from === 0) {
        this.order.push({ to: firstAfterLast, animate: false });
        this.order.push({ to });
      } else {
        this.order.push({ to });
      }
      if (!this.isAnimating) {
        this.runAnimation();
      }
    },
    runAnimation() {
      this.isAnimating = true;
      const animation = this.order.shift();
      if (!animation) {
        this.isAnimating = false;
        return;
      }
      sliderToBeShown.value = animation == null ? void 0 : animation.to;
      if (animation.animate || animation.animate === void 0) {
        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
        setTimeout(() => {
          this.runAnimation();
        }, this.speed * 1e3);
      } else {
        slidesContainerStyle.value.transition = "none";
        setTimeout(() => {
          this.runAnimation();
        }, 16);
      }
    }
  };
  watch(currentSlide, (newValue, oldValue) => {
    animator.move(oldValue, newValue);
  });
  const slides = computed(() => {
    if (props.effect === "fade") {
      return [props.items[currentSlide.value]];
    }
    if (props.infinite) {
      return [...props.items, props.items[0]];
    }
    return props.items;
  });
  return {
    start,
    pause,
    stop,
    withPause,
    computedSlidesStyle,
    slides
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/hooks/useCarouselColors.js
init_vue_runtime_esm_bundler();
var useCarouselColor = () => {
  const { setHSLAColor: setHSLAColor2, getColor } = useColors();
  return {
    computedColor: computed(() => setHSLAColor2(getColor("background-element"), { a: 0.7 })),
    computedHoverColor: computed(() => setHSLAColor2(getColor("primary"), { a: 0.7 })),
    computedActiveColor: computed(() => getColor("primary"))
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useSwipe.js
init_vue_runtime_esm_bundler();
var mouseEvents = ["mousedown", "mousemove"];
var touchEvents = ["touchstart", "touchmove"];
var commonAllowedDirections = {
  vertical: ["", "all", "vertical"],
  horizontal: ["", "all", "horizontal"]
};
var verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, "up", "down"];
var horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, "left", "right"];
var useSwipeProps = {
  swipable: { type: Boolean, default: false },
  swipeDistance: { type: Number, default: 75 },
  swipeDirection: { type: String, default: "all" }
};
var useSwipe = (props, container, cb) => {
  const swipeStarted = ref(false);
  const swipePath = reactive({
    start: { x: 0, y: 0 },
    end: { x: 0, y: 0 }
  });
  const swipeDuration = reactive({
    start: 0,
    end: 0
  });
  const setState = (e2, type) => {
    let event;
    if (mouseEvents.includes(e2.type)) {
      event = e2;
    }
    if (touchEvents.includes(e2.type)) {
      const touchEvent = e2;
      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
    }
    if (!event) {
      return;
    }
    swipePath[type].x = event.pageX;
    swipePath[type].y = event.pageY;
    swipeDuration[type] = new Date().getTime();
  };
  const onSwipeStart = (e2) => {
    if (!props.swipable || swipeStarted.value) {
      return;
    }
    swipeStarted.value = true;
    setState(e2, "start");
  };
  const onSwipeMove = (e2) => {
    if (!swipeStarted.value) {
      return;
    }
    setState(e2, "end");
  };
  const resetSwipe = () => {
    ["start", "end"].forEach((type) => {
      swipePath[type].x = 0;
      swipePath[type].y = 0;
      swipeDuration[type] = 0;
    });
    swipeStarted.value = false;
  };
  const isSwipeAllowed = reactive({
    vertical: false,
    horizontal: false
  });
  watchEffect(() => {
    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection);
    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection);
  });
  const calcDistance = (axis) => {
    return isSwipeAllowed[axis === "x" ? "horizontal" : "vertical"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;
  };
  const getAcceptableValue = (direction, result) => {
    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : "";
  };
  const swipeState = reactive({ direction: "", duration: 0 });
  watch(swipePath, () => {
    const xDistance = calcDistance("x");
    const yDistance = calcDistance("y");
    if ((xDistance || yDistance) && [xDistance, yDistance].some((el) => Math.abs(el) >= props.swipeDistance)) {
      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {
        const result = xDistance > 0 ? "left" : "right";
        swipeState.direction = getAcceptableValue("horizontal", result);
      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {
        const result = yDistance > 0 ? "down" : "up";
        swipeState.direction = getAcceptableValue("vertical", result);
      }
      swipeState.duration = swipeDuration.end - swipeDuration.start;
      resetSwipe();
    }
  }, { deep: true });
  watch(swipeState, () => cb(swipeState), { deep: true });
  if (props.swipable) {
    useEvent(["touchstart", "mousedown"], onSwipeStart, container);
    useEvent(["touchmove", "mousemove"], onSwipeMove, container);
    useEvent(["touchcancel", "mouseup", "touchend", "mouseleave"], resetSwipe, container);
  }
  return { swipeState };
};

// node_modules/vuestic-ui/dist/es/src/components/va-image/VaImage.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-image/VaImage.css";
var __defProp38 = Object.defineProperty;
var __defProps30 = Object.defineProperties;
var __getOwnPropDescs30 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols38 = Object.getOwnPropertySymbols;
var __hasOwnProp38 = Object.prototype.hasOwnProperty;
var __propIsEnum38 = Object.prototype.propertyIsEnumerable;
var __defNormalProp38 = (obj, key, value) => key in obj ? __defProp38(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues38 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp38.call(b2, prop))
      __defNormalProp38(a2, prop, b2[prop]);
  if (__getOwnPropSymbols38)
    for (var prop of __getOwnPropSymbols38(b2)) {
      if (__propIsEnum38.call(b2, prop))
        __defNormalProp38(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps30 = (a2, b2) => __defProps30(a2, __getOwnPropDescs30(b2));
var _sfc_main24 = defineComponent({
  name: "VaImage",
  emits: ["loaded", "error"],
  props: __spreadProps30(__spreadValues38({}, useComponentPresetProp), {
    ratio: { type: Number, default: 1 },
    contain: { type: Boolean, default: false },
    src: { type: String, required: true },
    alt: { type: String, default: "" },
    draggable: { type: Boolean, default: true }
  }),
  setup(props, { emit }) {
    const loading = ref(false);
    const loadingError = ref(false);
    const imageStyles = computed(() => ({
      objectFit: props.contain ? "contain" : "cover"
    }));
    const paddingStyles = computed(() => ({
      paddingBottom: `${1 / props.ratio * 100}%`
    }));
    const handleLoad = () => {
      loading.value = false;
      emit("loaded", props.src);
    };
    const handleError = (err) => {
      loadingError.value = true;
      loading.value = false;
      emit("error", err);
    };
    watch(() => props.src, () => {
      loading.value = true;
      loadingError.value = false;
    });
    return {
      loading,
      loadingError,
      imageStyles,
      paddingStyles,
      handleLoad,
      handleError
    };
  }
});
var _hoisted_112 = {
  class: "va-image",
  "aria-live": "polite"
};
var _hoisted_27 = {
  key: 0,
  class: "va-image__error"
};
var _hoisted_34 = { class: "va-image__img" };
var _hoisted_44 = ["src", "alt", "draggable"];
var _hoisted_54 = { class: "va-image__overlay" };
var _hoisted_63 = {
  key: 1,
  class: "va-image__loader"
};
function _sfc_render23(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_112, [
    _ctx.loadingError ? (openBlock(), createElementBlock("div", _hoisted_27, [
      renderSlot(_ctx.$slots, "error")
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      style: normalizeStyle(_ctx.paddingStyles)
    }, null, 4),
    withDirectives(createBaseVNode("div", _hoisted_34, [
      createBaseVNode("img", {
        style: normalizeStyle(_ctx.imageStyles),
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        draggable: _ctx.$props.draggable,
        onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args)),
        onLoad: _cache[1] || (_cache[1] = (...args) => _ctx.handleLoad && _ctx.handleLoad(...args))
      }, null, 44, _hoisted_44)
    ], 512), [
      [vShow, !_ctx.loadingError && !_ctx.loading]
    ]),
    createBaseVNode("div", _hoisted_54, [
      renderSlot(_ctx.$slots, "default")
    ]),
    _ctx.loading ? (openBlock(), createElementBlock("div", _hoisted_63, [
      renderSlot(_ctx.$slots, "loader")
    ])) : createCommentVNode("", true)
  ]);
}
var _VaImage = _export_sfc(_sfc_main24, [["render", _sfc_render23]]);

// node_modules/vuestic-ui/dist/es/src/components/va-image/index.js
var VaImage = withConfigTransport(_VaImage);

// node_modules/vuestic-ui/dist/es/src/components/va-hover/VaHover.js
init_vue_runtime_esm_bundler();
var __defProp39 = Object.defineProperty;
var __defProps31 = Object.defineProperties;
var __getOwnPropDescs31 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols39 = Object.getOwnPropertySymbols;
var __hasOwnProp39 = Object.prototype.hasOwnProperty;
var __propIsEnum39 = Object.prototype.propertyIsEnumerable;
var __defNormalProp39 = (obj, key, value) => key in obj ? __defProp39(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues39 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp39.call(b2, prop))
      __defNormalProp39(a2, prop, b2[prop]);
  if (__getOwnPropSymbols39)
    for (var prop of __getOwnPropSymbols39(b2)) {
      if (__propIsEnum39.call(b2, prop))
        __defNormalProp39(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps31 = (a2, b2) => __defProps31(a2, __getOwnPropDescs31(b2));
var _sfc_main25 = defineComponent({
  name: "VaHover",
  props: __spreadProps31(__spreadValues39(__spreadValues39({}, createStatefulProps(Boolean, true)), useComponentPresetProp), {
    disabled: { type: Boolean, default: false },
    modelValue: { type: Boolean, default: false }
  }),
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const onMouseEnter = () => {
      if (!props.disabled) {
        valueComputed.value = true;
      }
    };
    const onMouseLeave = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    return { onMouseEnter, onMouseLeave, valueComputed };
  }
});
function _sfc_render24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-hover",
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ hover: _ctx.valueComputed })))
  ], 32);
}
var _VaHover = _export_sfc(_sfc_main25, [["render", _sfc_render24]]);

// node_modules/vuestic-ui/dist/es/src/components/va-hover/index.js
var VaHover = withConfigTransport(_VaHover);

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/VaCarousel.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-carousel/VaCarousel.css";
var __defProp40 = Object.defineProperty;
var __defProps32 = Object.defineProperties;
var __getOwnPropDescs32 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols40 = Object.getOwnPropertySymbols;
var __hasOwnProp40 = Object.prototype.hasOwnProperty;
var __propIsEnum40 = Object.prototype.propertyIsEnumerable;
var __defNormalProp40 = (obj, key, value) => key in obj ? __defProp40(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues40 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp40.call(b2, prop))
      __defNormalProp40(a2, prop, b2[prop]);
  if (__getOwnPropSymbols40)
    for (var prop of __getOwnPropSymbols40(b2)) {
      if (__propIsEnum40.call(b2, prop))
        __defNormalProp40(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps32 = (a2, b2) => __defProps32(a2, __getOwnPropDescs32(b2));
var VaImageProps = extractComponentProps(VaImage, ["src", "alt"]);
var _sfc_main26 = defineComponent({
  name: "VaCarousel",
  components: { VaImage, VaButton: VaButton2, VaHover },
  props: __spreadProps32(__spreadValues40(__spreadValues40(__spreadValues40(__spreadValues40({}, useSwipeProps), useStatefulProps), useComponentPresetProp), VaImageProps), {
    modelValue: { type: Number, default: 0 },
    items: { type: Array, required: true },
    autoscroll: { type: Boolean, default: false },
    autoscrollInterval: { type: Number, default: 1e3 },
    autoscrollPauseDuration: { type: Number, default: 2e3 },
    infinite: { type: Boolean, default: false },
    fadeKeyframe: { type: String, default: "va-carousel-fade-appear 1s" },
    arrows: { type: Boolean, default: true },
    indicators: { type: Boolean, default: true },
    indicatorTrigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover"].includes(value)
    },
    vertical: { type: Boolean, default: false },
    height: { type: String, default: "300px" },
    effect: {
      type: String,
      default: "transition",
      validator: (value) => ["fade", "transition"].includes(value)
    },
    color: { type: String, default: "primary" },
    ratio: { type: Number }
  }),
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed: currentSlide } = useStateful(props, emit, "modelValue", { defaultValue: 0 });
    const {
      goTo,
      next,
      prev,
      doShowNextButton,
      doShowPrevButton
    } = useCarousel(props, currentSlide);
    const { withPause, computedSlidesStyle, slides } = useCarouselAnimation(props, currentSlide);
    const isObjectSlides = computed(() => {
      return props.items.length && props.items.every((el) => !!el && typeof el === "object" && !!(el == null ? void 0 : el.src));
    });
    const isCurrentSlide = (index) => index === currentSlide.value;
    const slideStyleComputed = computed(() => ({
      animation: props.effect === "fade" ? "fadeKeyframe" : void 0
    }));
    const slidesContainer = shallowRef();
    const onSwipe = (state) => {
      switch (state.direction) {
        case "right":
        case "up":
          doShowPrevButton.value && prev();
          break;
        case "left":
        case "down":
          doShowNextButton.value && next();
      }
    };
    useSwipe(props, slidesContainer, onSwipe);
    return __spreadProps32(__spreadValues40(__spreadValues40({
      vaImageProps: filterComponentProps(props, VaImageProps),
      doShowNextButton,
      doShowPrevButton,
      computedSlidesStyle,
      slideStyleComputed,
      goTo: withPause(goTo),
      prev: withPause(prev),
      next: withPause(next),
      slides,
      isObjectSlides,
      isCurrentSlide
    }, useCarouselColor()), useTranslation()), {
      slidesContainer
    });
  }
});
var _hoisted_113 = ["aria-label"];
var _hoisted_28 = {
  key: 1,
  class: "va-carousel__indicators"
};
var _hoisted_35 = { class: "va-carousel__content" };
var _hoisted_45 = ["aria-hidden", "aria-current", "aria-label"];
function _sfc_render25(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_hover = resolveComponent("va-hover");
  const _component_va_image = resolveComponent("va-image");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-carousel", {
      "va-carousel--vertical": _ctx.$props.vertical,
      [`va-carousel--${_ctx.$props.effect}`]: true
    }]),
    style: normalizeStyle({ height: _ctx.ratio ? "auto" : _ctx.height }),
    role: "region",
    "aria-label": _ctx.t("carousel")
  }, [
    _ctx.$props.arrows ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      _ctx.doShowPrevButton ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-carousel__arrow va-carousel__arrow--left",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.prev && _ctx.prev(...args)),
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.prev && _ctx.prev(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "prev-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "va-arrow-up" : "va-arrow-left",
                "aria-label": _ctx.t("goPreviousSlide")
              }, null, 8, ["color", "icon", "aria-label"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("", true),
      _ctx.doShowNextButton ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-carousel__arrow va-carousel__arrow--right",
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.next && _ctx.next(...args)),
        onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.next && _ctx.next(...args), ["stop"]), ["enter"]))
      }, [
        renderSlot(_ctx.$slots, "next-arrow", {}, () => [
          createVNode(_component_va_hover, { stateful: "" }, {
            default: withCtx(({ hover }) => [
              createVNode(_component_va_button, {
                color: hover ? _ctx.computedHoverColor : _ctx.computedColor,
                icon: _ctx.vertical ? "va-arrow-down" : "va-arrow-right",
                "aria-label": _ctx.t("goNextSlide")
              }, null, 8, ["color", "icon", "aria-label"])
            ]),
            _: 1
          })
        ])
      ], 32)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    _ctx.$props.indicators ? (openBlock(), createElementBlock("div", _hoisted_28, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.items, (item, index) => {
        return openBlock(), createElementBlock("div", mergeProps({
          class: ["va-carousel__indicator", { "va-carousel__indicator--active": index === _ctx.modelValue }],
          key: index
        }, _ctx.indicatorTrigger === "hover" ? { onmouseover: () => _ctx.goTo(index) } : { onclick: () => _ctx.goTo(index) }), [
          renderSlot(_ctx.$slots, "indicator", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
            createVNode(_component_va_hover, { stateful: "" }, {
              default: withCtx(({ hover }) => [
                createVNode(_component_va_button, {
                  "aria-label": _ctx.t(`goSlide`, { index: index + 1 }),
                  round: "",
                  color: _ctx.isCurrentSlide(index) ? _ctx.computedActiveColor : hover ? _ctx.computedHoverColor : _ctx.computedColor
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(index + 1), 1)
                  ]),
                  _: 2
                }, 1032, ["aria-label", "color"])
              ]),
              _: 2
            }, 1024)
          ])
        ], 16);
      }), 128))
    ])) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_35, [
      createBaseVNode("div", {
        ref: "slidesContainer",
        class: "va-carousel__slides",
        style: normalizeStyle(_ctx.computedSlidesStyle),
        role: "list"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.slides, (item, index) => {
          return openBlock(), createElementBlock("div", {
            key: item,
            role: "listitem",
            class: "va-carousel__slide",
            style: normalizeStyle(_ctx.slideStyleComputed),
            "aria-hidden": !_ctx.isCurrentSlide(index),
            "aria-current": _ctx.isCurrentSlide(index),
            "aria-label": _ctx.t("slideOf", { index: index + 1, length: _ctx.slides.length })
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ item, index, goTo: _ctx.goTo, isActive: _ctx.isCurrentSlide(index) })), () => [
              createVNode(_component_va_image, mergeProps(_ctx.vaImageProps, {
                src: _ctx.isObjectSlides ? item.src : item,
                alt: _ctx.isObjectSlides ? item.alt : "",
                draggable: false
              }), null, 16, ["src", "alt"])
            ])
          ], 12, _hoisted_45);
        }), 128))
      ], 4)
    ])
  ], 14, _hoisted_113);
}
var _VaCarousel = _export_sfc(_sfc_main26, [["render", _sfc_render25]]);

// node_modules/vuestic-ui/dist/es/src/components/va-carousel/index.js
var VaCarousel = withConfigTransport(_VaCarousel);

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/VaCheckbox.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useKeyboardOnlyFocus.js
init_vue_runtime_esm_bundler();
function useKeyboardOnlyFocus() {
  const hasKeyboardFocus = ref(false);
  let previouslyClicked = false;
  const keyboardFocusListeners = {
    mousedown: () => {
      previouslyClicked = true;
    },
    focus: () => {
      if (!previouslyClicked) {
        hasKeyboardFocus.value = true;
      }
      previouslyClicked = false;
    },
    blur: () => {
      hasKeyboardFocus.value = false;
      previouslyClicked = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}

// node_modules/vuestic-ui/dist/es/src/composables/useSelectable.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useValidation.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useSyncProp.js
init_vue_runtime_esm_bundler();
function useSyncProp(propName, props, emit, defaultValue) {
  if (defaultValue === void 0) {
    return [
      computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return props[propName];
        }
      })
    ];
  }
  const currentValue = props[propName];
  const statefulValue = ref(currentValue === void 0 ? defaultValue : currentValue);
  watch(() => props[propName], (newVal) => {
    if (newVal === void 0) {
      return;
    }
    statefulValue.value = newVal;
  });
  return [
    computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return props[propName] === void 0 ? statefulValue.value : props[propName];
      }
    })
  ];
}

// node_modules/vuestic-ui/dist/es/src/components/va-form/consts.js
var FormServiceKey = Symbol("FormService");

// node_modules/vuestic-ui/dist/es/src/composables/useValidation.js
var normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString_1(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction_1(rule) ? rule(callArguments) : rule);
};
var useValidationProps = {
  modelValue: { required: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  rules: { type: Array, default: () => [] },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false }
};
var useValidationEmits = ["update:error", "update:errorMessages"];
var useValidation = (props, emit, options) => {
  const { reset, focus } = options;
  const { isFocused, onFocus, onBlur } = useFocus();
  let canValidate = true;
  const [computedError] = useSyncProp("error", props, emit, false);
  const [computedErrorMessages] = useSyncProp("errorMessages", props, emit, []);
  const resetValidation = () => {
    computedError.value = false;
    computedErrorMessages.value = [];
  };
  const withoutValidation = (cb) => {
    canValidate = false;
    cb();
  };
  const validate = () => {
    if (!props.rules || !props.rules.length || !canValidate) {
      canValidate = true;
      return true;
    }
    let error = false;
    let errorMessages = [];
    const rules = flatten_1(props.rules);
    normalizeValidationRules(rules, props.modelValue).forEach((validationResult) => {
      if (isString_1(validationResult)) {
        errorMessages = [...errorMessages, validationResult];
        error = true;
      } else if (validationResult === false) {
        error = true;
      }
    });
    computedErrorMessages.value = errorMessages;
    computedError.value = error;
    return !error;
  };
  watch(isFocused, (newVal) => !newVal && validate());
  watch(() => props.modelValue, () => validate(), { immediate: props.immediateValidation });
  const context = {
    resetValidation,
    focus,
    validate,
    reset,
    hasError: () => computedError.value
  };
  const form = inject(FormServiceKey, void 0);
  const validationAriaAttributes = computed(() => ({
    "aria-invalid": !!computedErrorMessages.value.length,
    "aria-errormessage": typeof computedErrorMessages.value === "string" ? computedErrorMessages.value : computedErrorMessages.value.join(", ")
  }));
  onMounted(() => {
    form == null ? void 0 : form.onChildMounted(context);
  });
  onBeforeUnmount(() => {
    form == null ? void 0 : form.onChildUnmounted(context);
  });
  return {
    computedError,
    computedErrorMessages,
    listeners: { onFocus, onBlur },
    validate,
    resetValidation,
    withoutValidation,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useSelectable.js
var __defProp41 = Object.defineProperty;
var __defProps33 = Object.defineProperties;
var __getOwnPropDescs33 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols41 = Object.getOwnPropertySymbols;
var __hasOwnProp41 = Object.prototype.hasOwnProperty;
var __propIsEnum41 = Object.prototype.propertyIsEnumerable;
var __defNormalProp41 = (obj, key, value) => key in obj ? __defProp41(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues41 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp41.call(b2, prop))
      __defNormalProp41(a2, prop, b2[prop]);
  if (__getOwnPropSymbols41)
    for (var prop of __getOwnPropSymbols41(b2)) {
      if (__propIsEnum41.call(b2, prop))
        __defNormalProp41(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps33 = (a2, b2) => __defProps33(a2, __getOwnPropDescs33(b2));
var useSelectableProps = __spreadProps33(__spreadValues41(__spreadValues41(__spreadValues41({}, useStatefulProps), useLoadingProps), useValidationProps), {
  arrayValue: { type: [String, Boolean, Object, Number], default: void 0 },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
});
var useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
var checkDuplicates = (props) => {
  const values = [props.falseValue, props.trueValue];
  if (props.indeterminate) {
    values.push(props.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
var useSelectable = (props, emit, { input, label, container }) => {
  checkDuplicates(props);
  const reset = () => withoutValidation(() => {
    emit("update:modelValue", false);
    resetValidation();
  });
  const focus = () => {
    var _a;
    (_a = input.value) == null ? void 0 : _a.focus();
  };
  const {
    computedError,
    computedErrorMessages,
    validate,
    validationAriaAttributes,
    withoutValidation,
    resetValidation
  } = useValidation(props, emit, { reset, focus });
  const { valueComputed } = useStateful(props, emit);
  const { isFocused } = useFocus();
  const isElementRelated = (element) => {
    return !!element && [label.value, container.value].includes(element);
  };
  const onBlur = (event) => {
    if (input.value === event.target && !isElementRelated(event.relatedTarget)) {
      isFocused.value = false;
      computedError.value = false;
      validate();
      emit("blur", event);
    }
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit("focus", event);
  };
  const isIndeterminate = computed(() => props.indeterminate && valueComputed.value === props.indeterminateValue);
  const modelIsArray = computed(() => props.arrayValue !== void 0 && props.arrayValue !== null);
  const isChecked = computed(() => {
    var _a;
    if (modelIsArray.value) {
      return (_a = props.modelValue) == null ? void 0 : _a.includes(props.arrayValue);
    }
    return valueComputed.value === props.trueValue;
  });
  const toggleSelection = () => {
    if (props.readonly || props.disabled || props.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props.modelValue) {
        emit("update:modelValue", [props.arrayValue]);
      } else if (!Array.isArray(props.modelValue)) {
        emit("update:modelValue", props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
      } else if (props.modelValue.includes(props.arrayValue)) {
        emit("update:modelValue", props.modelValue.filter((option) => option !== props.arrayValue));
      } else {
        emit("update:modelValue", props.modelValue.concat(props.arrayValue));
      }
      return;
    }
    if (props.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props.falseValue;
      } else {
        valueComputed.value = props.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props.falseValue;
    } else {
      valueComputed.value = props.trueValue;
    }
  };
  return {
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages,
    validationAriaAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaMessageListWrapper.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaMessageList/VaMessageList.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaMessageList/VaMessageList.css";
var _sfc_main27 = defineComponent({
  name: "VaMessageList",
  components: { VaIcon: VaIcon2 },
  props: {
    modelValue: {
      type: [String, Array],
      default: ""
    },
    limit: { type: Number, default: 1 },
    color: { type: String },
    hasError: { type: Boolean, default: false }
  },
  setup(props) {
    const { getColor } = useColors();
    return {
      messages: computed(() => {
        if (!props.modelValue) {
          return [];
        }
        if (!Array.isArray(props.modelValue)) {
          return [props.modelValue];
        }
        return props.modelValue.slice(0, props.limit);
      }),
      computedStyle: computed(() => props.color ? { color: getColor(props.color) } : {})
    };
  }
});
function _sfc_render26(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.messages.length ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-message-list",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.messages, (message, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: "va-message-list__message"
      }, [
        _ctx.hasError ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-message-list__icon",
          name: "va-warning",
          size: 16
        })) : createCommentVNode("", true),
        createTextVNode(toDisplayString(message), 1)
      ]);
    }), 128))
  ], 4)) : createCommentVNode("", true);
}
var _VaMessageList = _export_sfc(_sfc_main27, [["render", _sfc_render26]]);

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaMessageList/index.js
var VaMessageList = withConfigTransport(_VaMessageList);

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaMessageListWrapper.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaMessageListWrapper.css";
var __defProp42 = Object.defineProperty;
var __getOwnPropSymbols42 = Object.getOwnPropertySymbols;
var __hasOwnProp42 = Object.prototype.hasOwnProperty;
var __propIsEnum42 = Object.prototype.propertyIsEnumerable;
var __defNormalProp42 = (obj, key, value) => key in obj ? __defProp42(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues42 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp42.call(b2, prop))
      __defNormalProp42(a2, prop, b2[prop]);
  if (__getOwnPropSymbols42)
    for (var prop of __getOwnPropSymbols42(b2)) {
      if (__propIsEnum42.call(b2, prop))
        __defNormalProp42(a2, prop, b2[prop]);
    }
  return a2;
};
var _sfc_main28 = defineComponent({
  name: "VaMessageListWrapper",
  components: { VaMessageList },
  props: __spreadValues42({}, useValidationProps),
  setup(props) {
    return {
      messagesColor: computed(() => {
        if (props.error) {
          return "danger";
        }
        if (props.success) {
          return "success";
        }
        return "";
      }),
      hasError: toRef(props, "error"),
      messagesComputed: computed(() => props.error ? props.errorMessages : props.messages),
      errorLimit: computed(() => props.error ? Number(props.errorCount) : 99)
    };
  }
});
var _hoisted_114 = { class: "va-message-list-wrapper" };
function _sfc_render27(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", _hoisted_114, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(_component_va_message_list, {
      color: _ctx.messagesColor,
      limit: _ctx.errorLimit,
      "has-error": _ctx.hasError,
      "model-value": _ctx.messagesComputed
    }, null, 8, ["color", "limit", "has-error", "model-value"])
  ]);
}
var VaMessageListWrapper = _export_sfc(_sfc_main28, [["render", _sfc_render27]]);

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/VaCheckbox.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-checkbox/VaCheckbox.css";
var __defProp43 = Object.defineProperty;
var __defProps34 = Object.defineProperties;
var __getOwnPropDescs34 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols43 = Object.getOwnPropertySymbols;
var __hasOwnProp43 = Object.prototype.hasOwnProperty;
var __propIsEnum43 = Object.prototype.propertyIsEnumerable;
var __defNormalProp43 = (obj, key, value) => key in obj ? __defProp43(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues43 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp43.call(b2, prop))
      __defNormalProp43(a2, prop, b2[prop]);
  if (__getOwnPropSymbols43)
    for (var prop of __getOwnPropSymbols43(b2)) {
      if (__propIsEnum43.call(b2, prop))
        __defNormalProp43(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps34 = (a2, b2) => __defProps34(a2, __getOwnPropDescs34(b2));
var VaCheckboxValueType = [Boolean, Array, String, Object];
var _sfc_main29 = defineComponent({
  name: "VaCheckbox",
  components: { VaMessageListWrapper, VaIcon: VaIcon2 },
  emits: useSelectableEmits,
  props: __spreadProps34(__spreadValues43(__spreadValues43({}, useSelectableProps), useComponentPresetProp), {
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "va-check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 }
  }),
  setup(props, { emit }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor();
    const isActive = computed(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props.readonly,
      "va-checkbox--disabled": props.disabled,
      "va-checkbox--indeterminate": props.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : "",
        padding: !props.label ? "" : props.leftLabel ? "0 0.5rem 0 0" : "0 0 0 0.5rem"
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: isActive.value ? getColor(props.color) : "",
        borderColor: isActive.value ? getColor(props.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const computedIconName = computed(() => props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon);
    const uniqueId2 = computed(generateUniqueId);
    const computedId = computed(() => props.id || uniqueId2.value);
    const computedName = computed(() => props.name || uniqueId2.value);
    const inputAttributesComputed = computed(() => __spreadValues43({
      name: computedName.value,
      disabled: props.disabled,
      readonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      ariaLabel: props.ariaLabel,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ariaChecked: isActive.value
    }, validationAriaAttributes.value));
    return {
      isActive,
      computedClass,
      labelStyle,
      inputStyle,
      computedIconName,
      textColorComputed,
      computedError,
      computedErrorMessages,
      keyboardFocusListeners,
      toggleSelection,
      onBlur,
      onFocus,
      inputAttributesComputed,
      computedId,
      computedName
    };
  }
});
var _hoisted_115 = ["id", "indeterminate", "value", "checked"];
var _hoisted_29 = ["for"];
function _sfc_render28(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-checkbox", _ctx.computedClass]),
    disabled: _ctx.disabled,
    success: _ctx.success,
    messages: _ctx.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-checkbox__input-container",
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-checkbox__square",
          style: normalizeStyle(_ctx.inputStyle),
          onSelectstart: _cache[4] || (_cache[4] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-checkbox__input",
            id: _ctx.computedId,
            indeterminate: _ctx.indeterminate,
            value: _ctx.label,
            checked: _ctx.isActive
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop", "prevent"])),
            onKeypress: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]))
          }), null, 16, _hoisted_115),
          withDirectives(createVNode(_component_va_icon, {
            class: "va-checkbox__icon",
            size: "20px",
            name: _ctx.computedIconName,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"]), [
            [vShow, _ctx.isActive]
          ])
        ], 36),
        _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          ref: "label",
          class: "va-checkbox__label",
          for: _ctx.computedId,
          style: normalizeStyle(_ctx.labelStyle),
          onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ], 44, _hoisted_29)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
var _VaCheckbox = _export_sfc(_sfc_main29, [["render", _sfc_render28]]);

// node_modules/vuestic-ui/dist/es/src/components/va-checkbox/index.js
var VaCheckbox = withConfigTransport(_VaCheckbox);

// node_modules/vuestic-ui/dist/es/src/components/va-chip/VaChip.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-chip/VaChip.css";
var __defProp44 = Object.defineProperty;
var __defProps35 = Object.defineProperties;
var __getOwnPropDescs35 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols44 = Object.getOwnPropertySymbols;
var __hasOwnProp44 = Object.prototype.hasOwnProperty;
var __propIsEnum44 = Object.prototype.propertyIsEnumerable;
var __defNormalProp44 = (obj, key, value) => key in obj ? __defProp44(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues44 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp44.call(b2, prop))
      __defNormalProp44(a2, prop, b2[prop]);
  if (__getOwnPropSymbols44)
    for (var prop of __getOwnPropSymbols44(b2)) {
      if (__propIsEnum44.call(b2, prop))
        __defNormalProp44(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps35 = (a2, b2) => __defProps35(a2, __getOwnPropDescs35(b2));
var _sfc_main30 = defineComponent({
  name: "VaChip",
  components: { VaIcon: VaIcon2 },
  emits: [...useStatefulEmits, "focus"],
  props: __spreadProps35(__spreadValues44(__spreadValues44(__spreadValues44(__spreadValues44({}, useRouterLinkProps), useColorProps), useStatefulProps), useComponentPresetProp), {
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    }
  }),
  setup(props, { emit }) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const borderColor = computed(() => props.outline ? colorComputed.value : "");
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
    const size = {
      small: "0.875rem",
      medium: "1rem",
      large: "1.25rem"
    };
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed(() => {
      if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props, emit);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    return __spreadProps35(__spreadValues44({}, useTranslation()), {
      keyboardFocusListeners,
      valueComputed,
      hrefComputed,
      tagComputed,
      onMouseEnter,
      onMouseLeave,
      isHovered,
      close: () => {
        if (!props.disabled) {
          valueComputed.value = false;
        }
      },
      iconSize: computed(() => size[props.size]),
      tabIndexComputed: computed(() => props.disabled ? -1 : 0),
      computedClass: useBem("va-chip", () => __spreadProps35(__spreadValues44({}, pick_1(props, ["disabled", "square"])), {
        small: props.size === "small",
        large: props.size === "large"
      })),
      computedStyle: computed(() => {
        const result = {
          color: textColorComputed.value,
          borderColor: borderColor.value,
          background: "",
          boxShadow: shadowStyle.value
        };
        if (props.outline || props.flat) {
          if (hasKeyboardFocus.value) {
            result.background = getFocusColor(colorComputed.value);
          } else if (isHovered.value) {
            result.background = getHoverColor(colorComputed.value);
          }
        } else {
          result.background = colorComputed.value;
        }
        return result;
      })
    });
  }
});
var _hoisted_116 = { class: "va-chip__content" };
function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return _ctx.valueComputed ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    key: 0,
    class: normalizeClass(["va-chip", _ctx.computedClass]),
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle)
  }, {
    default: withCtx(() => [
      createBaseVNode("span", mergeProps({
        class: "va-chip__inner",
        onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
      }, toHandlers(_ctx.keyboardFocusListeners)), [
        _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
          key: 0,
          class: "va-chip__icon",
          name: _ctx.icon,
          size: _ctx.iconSize
        }, null, 8, ["name", "size"])) : createCommentVNode("", true),
        createBaseVNode("span", _hoisted_116, [
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.closeable ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          role: "button",
          name: "va-close",
          class: "va-chip__close-icon",
          "aria-label": _ctx.t("close"),
          tabindex: _ctx.tabIndexComputed,
          size: _ctx.iconSize,
          onClick: withModifiers(_ctx.close, ["stop"]),
          onKeydown: [
            withKeys(withModifiers(_ctx.close, ["stop"]), ["enter"]),
            withKeys(withModifiers(_ctx.close, ["stop"]), ["space"])
          ]
        }, null, 8, ["aria-label", "tabindex", "size", "onClick", "onKeydown"])) : createCommentVNode("", true)
      ], 16)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"])) : createCommentVNode("", true);
}
var _VaChip = _export_sfc(_sfc_main30, [["render", _sfc_render29]]);

// node_modules/vuestic-ui/dist/es/src/components/va-chip/index.js
var VaChip = withConfigTransport(_VaChip);

// node_modules/vuestic-ui/dist/es/src/components/va-collapse/VaCollapse.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useResizeObserver.js
init_vue_runtime_esm_bundler();
var useResizeObserver = (elementsList, cb) => {
  const resizeObserver = ref();
  const observeAll = (elementsList2) => {
    elementsList2.forEach((element) => {
      var _a;
      const unrefedElement = unref(element);
      unrefedElement && ((_a = resizeObserver.value) == null ? void 0 : _a.observe(unrefedElement));
    });
  };
  watch(elementsList, (newValue) => {
    var _a;
    (_a = resizeObserver.value) == null ? void 0 : _a.disconnect();
    observeAll(newValue);
  });
  onMounted(() => {
    resizeObserver.value = new ResizeObserver(cb);
    observeAll(elementsList);
  });
  onBeforeUnmount(() => {
    var _a;
    return (_a = resizeObserver.value) == null ? void 0 : _a.disconnect();
  });
  return resizeObserver;
};

// node_modules/vuestic-ui/dist/es/src/components/va-collapse/VaCollapse.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-collapse/VaCollapse.css";
var __defProp45 = Object.defineProperty;
var __defProps36 = Object.defineProperties;
var __getOwnPropDescs36 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols45 = Object.getOwnPropertySymbols;
var __hasOwnProp45 = Object.prototype.hasOwnProperty;
var __propIsEnum45 = Object.prototype.propertyIsEnumerable;
var __defNormalProp45 = (obj, key, value) => key in obj ? __defProp45(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues45 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp45.call(b2, prop))
      __defNormalProp45(a2, prop, b2[prop]);
  if (__getOwnPropSymbols45)
    for (var prop of __getOwnPropSymbols45(b2)) {
      if (__propIsEnum45.call(b2, prop))
        __defNormalProp45(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps36 = (a2, b2) => __defProps36(a2, __getOwnPropDescs36(b2));
var _sfc_main31 = defineComponent({
  name: "VaCollapse",
  components: {
    VaIcon: VaIcon2
  },
  props: __spreadProps36(__spreadValues45({}, useComponentPresetProp), {
    modelValue: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    solid: { type: Boolean, default: false },
    color: { type: String, default: "background-element" },
    textColor: { type: String, default: "" },
    colorAll: { type: Boolean, default: false }
  }),
  emits: ["update:modelValue"],
  setup(props, { emit, slots }) {
    const body = shallowRef();
    const [computedModelValue] = useSyncProp("modelValue", props, emit, false);
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const { accordionProps, toggle } = useAccordionItem(computedModelValue);
    const { textColorComputed } = useTextColor();
    const bodyHeight = ref();
    useResizeObserver([body], () => {
      var _a, _b;
      bodyHeight.value = (_b = (_a = body.value) == null ? void 0 : _a.clientHeight) != null ? _b : 0;
    });
    const height = computed(() => computedModelValue.value ? bodyHeight.value : 0);
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const getBackground = () => {
      return props.color && props.colorAll ? getHoverColor2(getColor(props.color)) : "";
    };
    const uniqueId2 = computed(generateUniqueId);
    const headerIdComputed = computed(() => `header-${uniqueId2.value}`);
    const panelIdComputed = computed(() => `panel-${uniqueId2.value}`);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const headerAttributes = computed(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props.disabled,
      role: "button"
    }));
    const computedClasses = useBem("va-collapse", () => __spreadProps36(__spreadValues45({}, pick_1(props, ["disabled", "solid"])), {
      expanded: computedModelValue.value,
      active: props.solid && computedModelValue.value,
      popout: !!(accordionProps.value.popout && computedModelValue.value),
      inset: !!(accordionProps.value.inset && computedModelValue.value)
    }));
    return {
      body,
      height,
      toggle,
      computedModelValue,
      headerIdComputed,
      headerAttributes,
      panelIdComputed,
      tabIndexComputed,
      textColorComputed,
      computedClasses,
      headerStyle: computed(() => ({
        paddingLeft: props.icon && 0,
        color: textColorComputed.value,
        backgroundColor: props.color ? getColor(props.color) : ""
      })),
      contentStyle: computed(() => {
        var _a;
        const hasContent = computedModelValue.value && !!((_a = slots.default) == null ? void 0 : _a.call(slots)[0]);
        return {
          visibility: hasContent ? "visible" : "hidden",
          height: `${height.value}px`,
          transitionDuration: getTransition(),
          background: hasContent ? getBackground() : ""
        };
      })
    };
  }
});
var _hoisted_117 = { class: "va-collapse__header__text" };
var _hoisted_210 = ["id", "aria-labelledby"];
function _sfc_render30(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-collapse", _ctx.computedClasses])
  }, [
    createBaseVNode("div", {
      class: "va-collapse__header-wrapper",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggle && _ctx.toggle(...args)),
      onKeydown: [
        _cache[1] || (_cache[1] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["enter"])),
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggle && _ctx.toggle(...args), ["space"]))
      ]
    }, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({
        value: _ctx.computedModelValue,
        bind: _ctx.headerAttributes,
        attributes: _ctx.headerAttributes
      })), () => [
        createBaseVNode("div", mergeProps(_ctx.headerAttributes, {
          class: "va-collapse__header",
          style: _ctx.headerStyle
        }), [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-collapse__header__icon",
            name: _ctx.icon,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_117, toDisplayString(_ctx.header), 1),
          createVNode(_component_va_icon, {
            class: "va-collapse__header__icon",
            name: _ctx.computedModelValue ? "va-arrow-up" : "va-arrow-down",
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"])
        ], 16)
      ])
    ], 32),
    createBaseVNode("div", {
      class: "va-collapse__body-wrapper",
      style: normalizeStyle(_ctx.contentStyle)
    }, [
      createBaseVNode("div", {
        class: "va-collapse_body",
        ref: "body",
        role: "region",
        id: _ctx.panelIdComputed,
        "aria-labelledby": _ctx.headerIdComputed
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 8, _hoisted_210)
    ], 4)
  ], 2);
}
var _VaCollapse = _export_sfc(_sfc_main31, [["render", _sfc_render30]]);

// node_modules/vuestic-ui/dist/es/src/components/va-collapse/index.js
var VaCollapse = withConfigTransport(_VaCollapse);

// node_modules/vuestic-ui/dist/es/src/components/va-color-indicator/VaColorIndicator.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-color-indicator/VaColorIndicator.css";
var __defProp46 = Object.defineProperty;
var __defProps37 = Object.defineProperties;
var __getOwnPropDescs37 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols46 = Object.getOwnPropertySymbols;
var __hasOwnProp46 = Object.prototype.hasOwnProperty;
var __propIsEnum46 = Object.prototype.propertyIsEnumerable;
var __defNormalProp46 = (obj, key, value) => key in obj ? __defProp46(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues46 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp46.call(b2, prop))
      __defNormalProp46(a2, prop, b2[prop]);
  if (__getOwnPropSymbols46)
    for (var prop of __getOwnPropSymbols46(b2)) {
      if (__propIsEnum46.call(b2, prop))
        __defNormalProp46(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps37 = (a2, b2) => __defProps37(a2, __getOwnPropDescs37(b2));
var _sfc_main32 = defineComponent({
  name: "VaColorIndicator",
  emits: useStatefulEmits,
  props: __spreadProps37(__spreadValues46(__spreadValues46({}, useStatefulProps), useComponentPresetProp), {
    modelValue: { type: Boolean, default: null },
    color: { type: String, default: "" },
    square: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      borderRadius: props.square ? "0px" : "50%",
      backgroundColor: colorComputed.value
    }));
    const computedClass = computed(() => ({
      "va-color-indicator--selected": valueComputed.value,
      "va-color-indicator--hoverable": valueComputed.value !== void 0
    }));
    const toggleModelValue = () => {
      valueComputed.value = !valueComputed.value;
    };
    return {
      valueComputed,
      computedStyle,
      computedClass,
      toggleModelValue
    };
  }
});
function _sfc_render31(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-color-indicator", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args)),
    onKeydown: [
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["enter"])),
      _cache[2] || (_cache[2] = withKeys((...args) => _ctx.toggleModelValue && _ctx.toggleModelValue(...args), ["space"]))
    ]
  }, [
    createBaseVNode("div", {
      class: "va-color-indicator__core",
      style: normalizeStyle(_ctx.computedStyle)
    }, null, 4)
  ], 38);
}
var _VaColorIndicatort = _export_sfc(_sfc_main32, [["render", _sfc_render31]]);

// node_modules/vuestic-ui/dist/es/src/components/va-color-indicator/index.js
var VaColorIndicator = withConfigTransport(_VaColorIndicatort);

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/VaColorInput.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-input/VaInput.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useClearable.js
init_vue_runtime_esm_bundler();
var useClearableProps = {
  clearable: { type: Boolean, default: false },
  clearableIcon: { type: String, default: "va-clear" },
  clearValue: { type: String, default: "" }
};
var useClearableEmits = ["clear"];
var useClearable = (props, inputValue, el, hasError) => {
  const { isFocused, onFocus, onBlur } = useFocus(el);
  const clearedValues = [null, void 0, props.clearValue];
  const canBeCleared = computed(() => props.clearable && !props.disabled && !props.readonly && !clearedValues.includes(inputValue.value));
  const clearIconColor = computed(() => {
    if (isFocused == null ? void 0 : isFocused.value) {
      return props.color || "primary";
    }
    if (hasError == null ? void 0 : hasError.value) {
      return "danger";
    }
    if (props.success) {
      return "success";
    }
    return "secondary";
  });
  const clearIconProps = computed(() => ({
    name: props.clearableIcon,
    color: clearIconColor.value,
    size: "small"
  }));
  return {
    canBeCleared,
    clearIconColor,
    clearIconProps,
    onFocus,
    onBlur
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocusDeep.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useCurrentElement.js
init_vue_runtime_esm_bundler();
var useCurrentElement = (el) => {
  if (el) {
    return el;
  }
  const vm = getCurrentInstance();
  const currentEl = shallowRef();
  onMounted(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  onUpdated(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  onBeforeUnmount(() => {
    var _a;
    currentEl.value = (_a = vm.proxy.$el) != null ? _a : void 0;
  });
  return currentEl;
};

// node_modules/vuestic-ui/dist/es/src/composables/useFocusDeep.js
var useActiveElement = () => {
  const activeEl = shallowRef();
  const updateActiveElement = () => {
    activeEl.value = document.activeElement;
  };
  onMounted(updateActiveElement);
  useCaptureEvent("focus", updateActiveElement);
  useCaptureEvent("blur", updateActiveElement);
  return activeEl;
};
var useFocusDeep = (el) => {
  const focused = useActiveElement();
  const current = useCurrentElement(el ? useHTMLElement(el) : void 0);
  let previouslyFocusedElement = null;
  return computed({
    get() {
      var _a;
      if (!focused.value) {
        return false;
      }
      if (focused.value === current.value) {
        return true;
      }
      const isFocused = (_a = current.value) == null ? void 0 : _a.contains(focused.value);
      if (isFocused) {
        previouslyFocusedElement = focused.value;
      }
      return isFocused;
    },
    set(value) {
      var _a;
      let target = previouslyFocusedElement != null ? previouslyFocusedElement : current.value;
      if (!((_a = current.value) == null ? void 0 : _a.contains(target))) {
        target = current.value;
      }
      if (value) {
        target == null ? void 0 : target.focus();
      } else {
        target == null ? void 0 : target.blur();
      }
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useForm.js
init_vue_runtime_esm_bundler();
var useFormProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
var useForm = (prefix2, props) => {
  const computedClasses = useBem(prefix2, computed(() => pick_1(props, ["disabled", "readonly"])));
  return { computedClasses };
};

// node_modules/vuestic-ui/dist/es/src/components/va-input/hooks/useCleave.js
init_vue_runtime_esm_bundler();

// node_modules/cleave.js/dist/cleave-esm.js
var commonjsGlobal2 = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var NumeralFormatter = function(numeralDecimalMark, numeralIntegerScale, numeralDecimalScale, numeralThousandsGroupStyle, numeralPositiveOnly, stripLeadingZeroes, prefix2, signBeforePrefix, tailPrefix, delimiter) {
  var owner = this;
  owner.numeralDecimalMark = numeralDecimalMark || ".";
  owner.numeralIntegerScale = numeralIntegerScale > 0 ? numeralIntegerScale : 0;
  owner.numeralDecimalScale = numeralDecimalScale >= 0 ? numeralDecimalScale : 2;
  owner.numeralThousandsGroupStyle = numeralThousandsGroupStyle || NumeralFormatter.groupStyle.thousand;
  owner.numeralPositiveOnly = !!numeralPositiveOnly;
  owner.stripLeadingZeroes = stripLeadingZeroes !== false;
  owner.prefix = prefix2 || prefix2 === "" ? prefix2 : "";
  owner.signBeforePrefix = !!signBeforePrefix;
  owner.tailPrefix = !!tailPrefix;
  owner.delimiter = delimiter || delimiter === "" ? delimiter : ",";
  owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
};
NumeralFormatter.groupStyle = {
  thousand: "thousand",
  lakh: "lakh",
  wan: "wan",
  none: "none"
};
NumeralFormatter.prototype = {
  getRawValue: function(value) {
    return value.replace(this.delimiterRE, "").replace(this.numeralDecimalMark, ".");
  },
  format: function(value) {
    var owner = this, parts, partSign, partSignAndPrefix, partInteger, partDecimal = "";
    value = value.replace(/[A-Za-z]/g, "").replace(owner.numeralDecimalMark, "M").replace(/[^\dM-]/g, "").replace(/^\-/, "N").replace(/\-/g, "").replace("N", owner.numeralPositiveOnly ? "" : "-").replace("M", owner.numeralDecimalMark);
    if (owner.stripLeadingZeroes) {
      value = value.replace(/^(-)?0+(?=\d)/, "$1");
    }
    partSign = value.slice(0, 1) === "-" ? "-" : "";
    if (typeof owner.prefix != "undefined") {
      if (owner.signBeforePrefix) {
        partSignAndPrefix = partSign + owner.prefix;
      } else {
        partSignAndPrefix = owner.prefix + partSign;
      }
    } else {
      partSignAndPrefix = partSign;
    }
    partInteger = value;
    if (value.indexOf(owner.numeralDecimalMark) >= 0) {
      parts = value.split(owner.numeralDecimalMark);
      partInteger = parts[0];
      partDecimal = owner.numeralDecimalMark + parts[1].slice(0, owner.numeralDecimalScale);
    }
    if (partSign === "-") {
      partInteger = partInteger.slice(1);
    }
    if (owner.numeralIntegerScale > 0) {
      partInteger = partInteger.slice(0, owner.numeralIntegerScale);
    }
    switch (owner.numeralThousandsGroupStyle) {
      case NumeralFormatter.groupStyle.lakh:
        partInteger = partInteger.replace(/(\d)(?=(\d\d)+\d$)/g, "$1" + owner.delimiter);
        break;
      case NumeralFormatter.groupStyle.wan:
        partInteger = partInteger.replace(/(\d)(?=(\d{4})+$)/g, "$1" + owner.delimiter);
        break;
      case NumeralFormatter.groupStyle.thousand:
        partInteger = partInteger.replace(/(\d)(?=(\d{3})+$)/g, "$1" + owner.delimiter);
        break;
    }
    if (owner.tailPrefix) {
      return partSign + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "") + owner.prefix;
    }
    return partSignAndPrefix + partInteger.toString() + (owner.numeralDecimalScale > 0 ? partDecimal.toString() : "");
  }
};
var NumeralFormatter_1 = NumeralFormatter;
var DateFormatter = function(datePattern, dateMin, dateMax) {
  var owner = this;
  owner.date = [];
  owner.blocks = [];
  owner.datePattern = datePattern;
  owner.dateMin = dateMin.split("-").reverse().map(function(x2) {
    return parseInt(x2, 10);
  });
  if (owner.dateMin.length === 2)
    owner.dateMin.unshift(0);
  owner.dateMax = dateMax.split("-").reverse().map(function(x2) {
    return parseInt(x2, 10);
  });
  if (owner.dateMax.length === 2)
    owner.dateMax.unshift(0);
  owner.initBlocks();
};
DateFormatter.prototype = {
  initBlocks: function() {
    var owner = this;
    owner.datePattern.forEach(function(value) {
      if (value === "Y") {
        owner.blocks.push(4);
      } else {
        owner.blocks.push(2);
      }
    });
  },
  getISOFormatDate: function() {
    var owner = this, date = owner.date;
    return date[2] ? date[2] + "-" + owner.addLeadingZero(date[1]) + "-" + owner.addLeadingZero(date[0]) : "";
  },
  getBlocks: function() {
    return this.blocks;
  },
  getValidatedDate: function(value) {
    var owner = this, result = "";
    value = value.replace(/[^\d]/g, "");
    owner.blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
        switch (owner.datePattern[index]) {
          case "d":
            if (sub === "00") {
              sub = "01";
            } else if (parseInt(sub0, 10) > 3) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > 31) {
              sub = "31";
            }
            break;
          case "m":
            if (sub === "00") {
              sub = "01";
            } else if (parseInt(sub0, 10) > 1) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > 12) {
              sub = "12";
            }
            break;
        }
        result += sub;
        value = rest;
      }
    });
    return this.getFixedDateString(result);
  },
  getFixedDateString: function(value) {
    var owner = this, datePattern = owner.datePattern, date = [], dayIndex = 0, monthIndex = 0, yearIndex = 0, dayStartIndex = 0, monthStartIndex = 0, yearStartIndex = 0, day, month, year, fullYearDone = false;
    if (value.length === 4 && datePattern[0].toLowerCase() !== "y" && datePattern[1].toLowerCase() !== "y") {
      dayStartIndex = datePattern[0] === "d" ? 0 : 2;
      monthStartIndex = 2 - dayStartIndex;
      day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      date = this.getFixedDate(day, month, 0);
    }
    if (value.length === 8) {
      datePattern.forEach(function(type, index) {
        switch (type) {
          case "d":
            dayIndex = index;
            break;
          case "m":
            monthIndex = index;
            break;
          default:
            yearIndex = index;
            break;
        }
      });
      yearStartIndex = yearIndex * 2;
      dayStartIndex = dayIndex <= yearIndex ? dayIndex * 2 : dayIndex * 2 + 2;
      monthStartIndex = monthIndex <= yearIndex ? monthIndex * 2 : monthIndex * 2 + 2;
      day = parseInt(value.slice(dayStartIndex, dayStartIndex + 2), 10);
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
      date = this.getFixedDate(day, month, year);
    }
    if (value.length === 4 && (datePattern[0] === "y" || datePattern[1] === "y")) {
      monthStartIndex = datePattern[0] === "m" ? 0 : 2;
      yearStartIndex = 2 - monthStartIndex;
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 2), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 2).length === 2;
      date = [0, month, year];
    }
    if (value.length === 6 && (datePattern[0] === "Y" || datePattern[1] === "Y")) {
      monthStartIndex = datePattern[0] === "m" ? 0 : 4;
      yearStartIndex = 2 - 0.5 * monthStartIndex;
      month = parseInt(value.slice(monthStartIndex, monthStartIndex + 2), 10);
      year = parseInt(value.slice(yearStartIndex, yearStartIndex + 4), 10);
      fullYearDone = value.slice(yearStartIndex, yearStartIndex + 4).length === 4;
      date = [0, month, year];
    }
    date = owner.getRangeFixedDate(date);
    owner.date = date;
    var result = date.length === 0 ? value : datePattern.reduce(function(previous, current) {
      switch (current) {
        case "d":
          return previous + (date[0] === 0 ? "" : owner.addLeadingZero(date[0]));
        case "m":
          return previous + (date[1] === 0 ? "" : owner.addLeadingZero(date[1]));
        case "y":
          return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], false) : "");
        case "Y":
          return previous + (fullYearDone ? owner.addLeadingZeroForYear(date[2], true) : "");
      }
    }, "");
    return result;
  },
  getRangeFixedDate: function(date) {
    var owner = this, datePattern = owner.datePattern, dateMin = owner.dateMin || [], dateMax = owner.dateMax || [];
    if (!date.length || dateMin.length < 3 && dateMax.length < 3)
      return date;
    if (datePattern.find(function(x2) {
      return x2.toLowerCase() === "y";
    }) && date[2] === 0)
      return date;
    if (dateMax.length && (dateMax[2] < date[2] || dateMax[2] === date[2] && (dateMax[1] < date[1] || dateMax[1] === date[1] && dateMax[0] < date[0])))
      return dateMax;
    if (dateMin.length && (dateMin[2] > date[2] || dateMin[2] === date[2] && (dateMin[1] > date[1] || dateMin[1] === date[1] && dateMin[0] > date[0])))
      return dateMin;
    return date;
  },
  getFixedDate: function(day, month, year) {
    day = Math.min(day, 31);
    month = Math.min(month, 12);
    year = parseInt(year || 0, 10);
    if (month < 7 && month % 2 === 0 || month > 8 && month % 2 === 1) {
      day = Math.min(day, month === 2 ? this.isLeapYear(year) ? 29 : 28 : 30);
    }
    return [day, month, year];
  },
  isLeapYear: function(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  },
  addLeadingZero: function(number) {
    return (number < 10 ? "0" : "") + number;
  },
  addLeadingZeroForYear: function(number, fullYearMode) {
    if (fullYearMode) {
      return (number < 10 ? "000" : number < 100 ? "00" : number < 1e3 ? "0" : "") + number;
    }
    return (number < 10 ? "0" : "") + number;
  }
};
var DateFormatter_1 = DateFormatter;
var TimeFormatter = function(timePattern, timeFormat) {
  var owner = this;
  owner.time = [];
  owner.blocks = [];
  owner.timePattern = timePattern;
  owner.timeFormat = timeFormat;
  owner.initBlocks();
};
TimeFormatter.prototype = {
  initBlocks: function() {
    var owner = this;
    owner.timePattern.forEach(function() {
      owner.blocks.push(2);
    });
  },
  getISOFormatTime: function() {
    var owner = this, time = owner.time;
    return time[2] ? owner.addLeadingZero(time[0]) + ":" + owner.addLeadingZero(time[1]) + ":" + owner.addLeadingZero(time[2]) : "";
  },
  getBlocks: function() {
    return this.blocks;
  },
  getTimeFormatOptions: function() {
    var owner = this;
    if (String(owner.timeFormat) === "12") {
      return {
        maxHourFirstDigit: 1,
        maxHours: 12,
        maxMinutesFirstDigit: 5,
        maxMinutes: 60
      };
    }
    return {
      maxHourFirstDigit: 2,
      maxHours: 23,
      maxMinutesFirstDigit: 5,
      maxMinutes: 60
    };
  },
  getValidatedTime: function(value) {
    var owner = this, result = "";
    value = value.replace(/[^\d]/g, "");
    var timeFormatOptions = owner.getTimeFormatOptions();
    owner.blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), sub0 = sub.slice(0, 1), rest = value.slice(length);
        switch (owner.timePattern[index]) {
          case "h":
            if (parseInt(sub0, 10) > timeFormatOptions.maxHourFirstDigit) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > timeFormatOptions.maxHours) {
              sub = timeFormatOptions.maxHours + "";
            }
            break;
          case "m":
          case "s":
            if (parseInt(sub0, 10) > timeFormatOptions.maxMinutesFirstDigit) {
              sub = "0" + sub0;
            } else if (parseInt(sub, 10) > timeFormatOptions.maxMinutes) {
              sub = timeFormatOptions.maxMinutes + "";
            }
            break;
        }
        result += sub;
        value = rest;
      }
    });
    return this.getFixedTimeString(result);
  },
  getFixedTimeString: function(value) {
    var owner = this, timePattern = owner.timePattern, time = [], secondIndex = 0, minuteIndex = 0, hourIndex = 0, secondStartIndex = 0, minuteStartIndex = 0, hourStartIndex = 0, second, minute, hour;
    if (value.length === 6) {
      timePattern.forEach(function(type, index) {
        switch (type) {
          case "s":
            secondIndex = index * 2;
            break;
          case "m":
            minuteIndex = index * 2;
            break;
          case "h":
            hourIndex = index * 2;
            break;
        }
      });
      hourStartIndex = hourIndex;
      minuteStartIndex = minuteIndex;
      secondStartIndex = secondIndex;
      second = parseInt(value.slice(secondStartIndex, secondStartIndex + 2), 10);
      minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
      hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
      time = this.getFixedTime(hour, minute, second);
    }
    if (value.length === 4 && owner.timePattern.indexOf("s") < 0) {
      timePattern.forEach(function(type, index) {
        switch (type) {
          case "m":
            minuteIndex = index * 2;
            break;
          case "h":
            hourIndex = index * 2;
            break;
        }
      });
      hourStartIndex = hourIndex;
      minuteStartIndex = minuteIndex;
      second = 0;
      minute = parseInt(value.slice(minuteStartIndex, minuteStartIndex + 2), 10);
      hour = parseInt(value.slice(hourStartIndex, hourStartIndex + 2), 10);
      time = this.getFixedTime(hour, minute, second);
    }
    owner.time = time;
    return time.length === 0 ? value : timePattern.reduce(function(previous, current) {
      switch (current) {
        case "s":
          return previous + owner.addLeadingZero(time[2]);
        case "m":
          return previous + owner.addLeadingZero(time[1]);
        case "h":
          return previous + owner.addLeadingZero(time[0]);
      }
    }, "");
  },
  getFixedTime: function(hour, minute, second) {
    second = Math.min(parseInt(second || 0, 10), 60);
    minute = Math.min(minute, 60);
    hour = Math.min(hour, 60);
    return [hour, minute, second];
  },
  addLeadingZero: function(number) {
    return (number < 10 ? "0" : "") + number;
  }
};
var TimeFormatter_1 = TimeFormatter;
var PhoneFormatter = function(formatter, delimiter) {
  var owner = this;
  owner.delimiter = delimiter || delimiter === "" ? delimiter : " ";
  owner.delimiterRE = delimiter ? new RegExp("\\" + delimiter, "g") : "";
  owner.formatter = formatter;
};
PhoneFormatter.prototype = {
  setFormatter: function(formatter) {
    this.formatter = formatter;
  },
  format: function(phoneNumber) {
    var owner = this;
    owner.formatter.clear();
    phoneNumber = phoneNumber.replace(/[^\d+]/g, "");
    phoneNumber = phoneNumber.replace(/^\+/, "B").replace(/\+/g, "").replace("B", "+");
    phoneNumber = phoneNumber.replace(owner.delimiterRE, "");
    var result = "", current, validated = false;
    for (var i2 = 0, iMax = phoneNumber.length; i2 < iMax; i2++) {
      current = owner.formatter.inputDigit(phoneNumber.charAt(i2));
      if (/[\s()-]/g.test(current)) {
        result = current;
        validated = true;
      } else {
        if (!validated) {
          result = current;
        }
      }
    }
    result = result.replace(/[()]/g, "");
    result = result.replace(/[\s-]/g, owner.delimiter);
    return result;
  }
};
var PhoneFormatter_1 = PhoneFormatter;
var CreditCardDetector = {
  blocks: {
    uatp: [4, 5, 6],
    amex: [4, 6, 5],
    diners: [4, 6, 4],
    discover: [4, 4, 4, 4],
    mastercard: [4, 4, 4, 4],
    dankort: [4, 4, 4, 4],
    instapayment: [4, 4, 4, 4],
    jcb15: [4, 6, 5],
    jcb: [4, 4, 4, 4],
    maestro: [4, 4, 4, 4],
    visa: [4, 4, 4, 4],
    mir: [4, 4, 4, 4],
    unionPay: [4, 4, 4, 4],
    general: [4, 4, 4, 4]
  },
  re: {
    uatp: /^(?!1800)1\d{0,14}/,
    amex: /^3[47]\d{0,13}/,
    discover: /^(?:6011|65\d{0,2}|64[4-9]\d?)\d{0,12}/,
    diners: /^3(?:0([0-5]|9)|[689]\d?)\d{0,11}/,
    mastercard: /^(5[1-5]\d{0,2}|22[2-9]\d{0,1}|2[3-7]\d{0,2})\d{0,12}/,
    dankort: /^(5019|4175|4571)\d{0,12}/,
    instapayment: /^63[7-9]\d{0,13}/,
    jcb15: /^(?:2131|1800)\d{0,11}/,
    jcb: /^(?:35\d{0,2})\d{0,12}/,
    maestro: /^(?:5[0678]\d{0,2}|6304|67\d{0,2})\d{0,12}/,
    mir: /^220[0-4]\d{0,12}/,
    visa: /^4\d{0,15}/,
    unionPay: /^(62|81)\d{0,14}/
  },
  getStrictBlocks: function(block) {
    var total = block.reduce(function(prev, current) {
      return prev + current;
    }, 0);
    return block.concat(19 - total);
  },
  getInfo: function(value, strictMode) {
    var blocks = CreditCardDetector.blocks, re = CreditCardDetector.re;
    strictMode = !!strictMode;
    for (var key in re) {
      if (re[key].test(value)) {
        var matchedBlocks = blocks[key];
        return {
          type: key,
          blocks: strictMode ? this.getStrictBlocks(matchedBlocks) : matchedBlocks
        };
      }
    }
    return {
      type: "unknown",
      blocks: strictMode ? this.getStrictBlocks(blocks.general) : blocks.general
    };
  }
};
var CreditCardDetector_1 = CreditCardDetector;
var Util = {
  noop: function() {
  },
  strip: function(value, re) {
    return value.replace(re, "");
  },
  getPostDelimiter: function(value, delimiter, delimiters) {
    if (delimiters.length === 0) {
      return value.slice(-delimiter.length) === delimiter ? delimiter : "";
    }
    var matchedDelimiter = "";
    delimiters.forEach(function(current) {
      if (value.slice(-current.length) === current) {
        matchedDelimiter = current;
      }
    });
    return matchedDelimiter;
  },
  getDelimiterREByDelimiter: function(delimiter) {
    return new RegExp(delimiter.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"), "g");
  },
  getNextCursorPosition: function(prevPos, oldValue, newValue, delimiter, delimiters) {
    if (oldValue.length === prevPos) {
      return newValue.length;
    }
    return prevPos + this.getPositionOffset(prevPos, oldValue, newValue, delimiter, delimiters);
  },
  getPositionOffset: function(prevPos, oldValue, newValue, delimiter, delimiters) {
    var oldRawValue, newRawValue, lengthOffset;
    oldRawValue = this.stripDelimiters(oldValue.slice(0, prevPos), delimiter, delimiters);
    newRawValue = this.stripDelimiters(newValue.slice(0, prevPos), delimiter, delimiters);
    lengthOffset = oldRawValue.length - newRawValue.length;
    return lengthOffset !== 0 ? lengthOffset / Math.abs(lengthOffset) : 0;
  },
  stripDelimiters: function(value, delimiter, delimiters) {
    var owner = this;
    if (delimiters.length === 0) {
      var delimiterRE = delimiter ? owner.getDelimiterREByDelimiter(delimiter) : "";
      return value.replace(delimiterRE, "");
    }
    delimiters.forEach(function(current) {
      current.split("").forEach(function(letter) {
        value = value.replace(owner.getDelimiterREByDelimiter(letter), "");
      });
    });
    return value;
  },
  headStr: function(str, length) {
    return str.slice(0, length);
  },
  getMaxLength: function(blocks) {
    return blocks.reduce(function(previous, current) {
      return previous + current;
    }, 0);
  },
  getPrefixStrippedValue: function(value, prefix2, prefixLength, prevResult, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix) {
    if (prefixLength === 0) {
      return value;
    }
    if (value === prefix2 && value !== "") {
      return "";
    }
    if (signBeforePrefix && value.slice(0, 1) == "-") {
      var prev = prevResult.slice(0, 1) == "-" ? prevResult.slice(1) : prevResult;
      return "-" + this.getPrefixStrippedValue(value.slice(1), prefix2, prefixLength, prev, delimiter, delimiters, noImmediatePrefix, tailPrefix, signBeforePrefix);
    }
    if (prevResult.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
      if (noImmediatePrefix && !prevResult && value)
        return value;
      return "";
    } else if (prevResult.slice(-prefixLength) !== prefix2 && tailPrefix) {
      if (noImmediatePrefix && !prevResult && value)
        return value;
      return "";
    }
    var prevValue = this.stripDelimiters(prevResult, delimiter, delimiters);
    if (value.slice(0, prefixLength) !== prefix2 && !tailPrefix) {
      return prevValue.slice(prefixLength);
    } else if (value.slice(-prefixLength) !== prefix2 && tailPrefix) {
      return prevValue.slice(0, -prefixLength - 1);
    }
    return tailPrefix ? value.slice(0, -prefixLength) : value.slice(prefixLength);
  },
  getFirstDiffIndex: function(prev, current) {
    var index = 0;
    while (prev.charAt(index) === current.charAt(index)) {
      if (prev.charAt(index++) === "") {
        return -1;
      }
    }
    return index;
  },
  getFormattedValue: function(value, blocks, blocksLength, delimiter, delimiters, delimiterLazyShow) {
    var result = "", multipleDelimiters = delimiters.length > 0, currentDelimiter = "";
    if (blocksLength === 0) {
      return value;
    }
    blocks.forEach(function(length, index) {
      if (value.length > 0) {
        var sub = value.slice(0, length), rest = value.slice(length);
        if (multipleDelimiters) {
          currentDelimiter = delimiters[delimiterLazyShow ? index - 1 : index] || currentDelimiter;
        } else {
          currentDelimiter = delimiter;
        }
        if (delimiterLazyShow) {
          if (index > 0) {
            result += currentDelimiter;
          }
          result += sub;
        } else {
          result += sub;
          if (sub.length === length && index < blocksLength - 1) {
            result += currentDelimiter;
          }
        }
        value = rest;
      }
    });
    return result;
  },
  fixPrefixCursor: function(el, prefix2, delimiter, delimiters) {
    if (!el) {
      return;
    }
    var val = el.value, appendix = delimiter || (delimiters[0] || " ");
    if (!el.setSelectionRange || !prefix2 || prefix2.length + appendix.length <= val.length) {
      return;
    }
    var len = val.length * 2;
    setTimeout(function() {
      el.setSelectionRange(len, len);
    }, 1);
  },
  checkFullSelection: function(value) {
    try {
      var selection = window.getSelection() || document.getSelection() || {};
      return selection.toString().length === value.length;
    } catch (ex) {
    }
    return false;
  },
  setSelection: function(element, position, doc) {
    if (element !== this.getActiveElement(doc)) {
      return;
    }
    if (element && element.value.length <= position) {
      return;
    }
    if (element.createTextRange) {
      var range = element.createTextRange();
      range.move("character", position);
      range.select();
    } else {
      try {
        element.setSelectionRange(position, position);
      } catch (e2) {
        console.warn("The input element type does not support selection");
      }
    }
  },
  getActiveElement: function(parent2) {
    var activeElement = parent2.activeElement;
    if (activeElement && activeElement.shadowRoot) {
      return this.getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  },
  isAndroid: function() {
    return navigator && /android/i.test(navigator.userAgent);
  },
  isAndroidBackspaceKeydown: function(lastInputValue, currentInputValue) {
    if (!this.isAndroid() || !lastInputValue || !currentInputValue) {
      return false;
    }
    return currentInputValue === lastInputValue.slice(0, -1);
  }
};
var Util_1 = Util;
var DefaultProperties = {
  assign: function(target, opts) {
    target = target || {};
    opts = opts || {};
    target.creditCard = !!opts.creditCard;
    target.creditCardStrictMode = !!opts.creditCardStrictMode;
    target.creditCardType = "";
    target.onCreditCardTypeChanged = opts.onCreditCardTypeChanged || function() {
    };
    target.phone = !!opts.phone;
    target.phoneRegionCode = opts.phoneRegionCode || "AU";
    target.phoneFormatter = {};
    target.time = !!opts.time;
    target.timePattern = opts.timePattern || ["h", "m", "s"];
    target.timeFormat = opts.timeFormat || "24";
    target.timeFormatter = {};
    target.date = !!opts.date;
    target.datePattern = opts.datePattern || ["d", "m", "Y"];
    target.dateMin = opts.dateMin || "";
    target.dateMax = opts.dateMax || "";
    target.dateFormatter = {};
    target.numeral = !!opts.numeral;
    target.numeralIntegerScale = opts.numeralIntegerScale > 0 ? opts.numeralIntegerScale : 0;
    target.numeralDecimalScale = opts.numeralDecimalScale >= 0 ? opts.numeralDecimalScale : 2;
    target.numeralDecimalMark = opts.numeralDecimalMark || ".";
    target.numeralThousandsGroupStyle = opts.numeralThousandsGroupStyle || "thousand";
    target.numeralPositiveOnly = !!opts.numeralPositiveOnly;
    target.stripLeadingZeroes = opts.stripLeadingZeroes !== false;
    target.signBeforePrefix = !!opts.signBeforePrefix;
    target.tailPrefix = !!opts.tailPrefix;
    target.swapHiddenInput = !!opts.swapHiddenInput;
    target.numericOnly = target.creditCard || target.date || !!opts.numericOnly;
    target.uppercase = !!opts.uppercase;
    target.lowercase = !!opts.lowercase;
    target.prefix = target.creditCard || target.date ? "" : opts.prefix || "";
    target.noImmediatePrefix = !!opts.noImmediatePrefix;
    target.prefixLength = target.prefix.length;
    target.rawValueTrimPrefix = !!opts.rawValueTrimPrefix;
    target.copyDelimiter = !!opts.copyDelimiter;
    target.initValue = opts.initValue !== void 0 && opts.initValue !== null ? opts.initValue.toString() : "";
    target.delimiter = opts.delimiter || opts.delimiter === "" ? opts.delimiter : opts.date ? "/" : opts.time ? ":" : opts.numeral ? "," : opts.phone ? " " : " ";
    target.delimiterLength = target.delimiter.length;
    target.delimiterLazyShow = !!opts.delimiterLazyShow;
    target.delimiters = opts.delimiters || [];
    target.blocks = opts.blocks || [];
    target.blocksLength = target.blocks.length;
    target.root = typeof commonjsGlobal2 === "object" && commonjsGlobal2 ? commonjsGlobal2 : window;
    target.document = opts.document || target.root.document;
    target.maxLength = 0;
    target.backspace = false;
    target.result = "";
    target.onValueChanged = opts.onValueChanged || function() {
    };
    return target;
  }
};
var DefaultProperties_1 = DefaultProperties;
var Cleave = function(element, opts) {
  var owner = this;
  var hasMultipleElements = false;
  if (typeof element === "string") {
    owner.element = document.querySelector(element);
    hasMultipleElements = document.querySelectorAll(element).length > 1;
  } else {
    if (typeof element.length !== "undefined" && element.length > 0) {
      owner.element = element[0];
      hasMultipleElements = element.length > 1;
    } else {
      owner.element = element;
    }
  }
  if (!owner.element) {
    throw new Error("[cleave.js] Please check the element");
  }
  if (hasMultipleElements) {
    try {
      console.warn("[cleave.js] Multiple input fields matched, cleave.js will only take the first one.");
    } catch (e2) {
    }
  }
  opts.initValue = owner.element.value;
  owner.properties = Cleave.DefaultProperties.assign({}, opts);
  owner.init();
};
Cleave.prototype = {
  init: function() {
    var owner = this, pps = owner.properties;
    if (!pps.numeral && !pps.phone && !pps.creditCard && !pps.time && !pps.date && (pps.blocksLength === 0 && !pps.prefix)) {
      owner.onInput(pps.initValue);
      return;
    }
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
    owner.isAndroid = Cleave.Util.isAndroid();
    owner.lastInputValue = "";
    owner.isBackward = "";
    owner.onChangeListener = owner.onChange.bind(owner);
    owner.onKeyDownListener = owner.onKeyDown.bind(owner);
    owner.onFocusListener = owner.onFocus.bind(owner);
    owner.onCutListener = owner.onCut.bind(owner);
    owner.onCopyListener = owner.onCopy.bind(owner);
    owner.initSwapHiddenInput();
    owner.element.addEventListener("input", owner.onChangeListener);
    owner.element.addEventListener("keydown", owner.onKeyDownListener);
    owner.element.addEventListener("focus", owner.onFocusListener);
    owner.element.addEventListener("cut", owner.onCutListener);
    owner.element.addEventListener("copy", owner.onCopyListener);
    owner.initPhoneFormatter();
    owner.initDateFormatter();
    owner.initTimeFormatter();
    owner.initNumeralFormatter();
    if (pps.initValue || pps.prefix && !pps.noImmediatePrefix) {
      owner.onInput(pps.initValue);
    }
  },
  initSwapHiddenInput: function() {
    var owner = this, pps = owner.properties;
    if (!pps.swapHiddenInput)
      return;
    var inputFormatter = owner.element.cloneNode(true);
    owner.element.parentNode.insertBefore(inputFormatter, owner.element);
    owner.elementSwapHidden = owner.element;
    owner.elementSwapHidden.type = "hidden";
    owner.element = inputFormatter;
    owner.element.id = "";
  },
  initNumeralFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.numeral) {
      return;
    }
    pps.numeralFormatter = new Cleave.NumeralFormatter(pps.numeralDecimalMark, pps.numeralIntegerScale, pps.numeralDecimalScale, pps.numeralThousandsGroupStyle, pps.numeralPositiveOnly, pps.stripLeadingZeroes, pps.prefix, pps.signBeforePrefix, pps.tailPrefix, pps.delimiter);
  },
  initTimeFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.time) {
      return;
    }
    pps.timeFormatter = new Cleave.TimeFormatter(pps.timePattern, pps.timeFormat);
    pps.blocks = pps.timeFormatter.getBlocks();
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
  },
  initDateFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.date) {
      return;
    }
    pps.dateFormatter = new Cleave.DateFormatter(pps.datePattern, pps.dateMin, pps.dateMax);
    pps.blocks = pps.dateFormatter.getBlocks();
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Cleave.Util.getMaxLength(pps.blocks);
  },
  initPhoneFormatter: function() {
    var owner = this, pps = owner.properties;
    if (!pps.phone) {
      return;
    }
    try {
      pps.phoneFormatter = new Cleave.PhoneFormatter(new pps.root.Cleave.AsYouTypeFormatter(pps.phoneRegionCode), pps.delimiter);
    } catch (ex) {
      throw new Error("[cleave.js] Please include phone-type-formatter.{country}.js lib");
    }
  },
  onKeyDown: function(event) {
    var owner = this, charCode = event.which || event.keyCode;
    owner.lastInputValue = owner.element.value;
    owner.isBackward = charCode === 8;
  },
  onChange: function(event) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util;
    owner.isBackward = owner.isBackward || event.inputType === "deleteContentBackward";
    var postDelimiter = Util2.getPostDelimiter(owner.lastInputValue, pps.delimiter, pps.delimiters);
    if (owner.isBackward && postDelimiter) {
      pps.postDelimiterBackspace = postDelimiter;
    } else {
      pps.postDelimiterBackspace = false;
    }
    this.onInput(this.element.value);
  },
  onFocus: function() {
    var owner = this, pps = owner.properties;
    owner.lastInputValue = owner.element.value;
    if (pps.prefix && pps.noImmediatePrefix && !owner.element.value) {
      this.onInput(pps.prefix);
    }
    Cleave.Util.fixPrefixCursor(owner.element, pps.prefix, pps.delimiter, pps.delimiters);
  },
  onCut: function(e2) {
    if (!Cleave.Util.checkFullSelection(this.element.value))
      return;
    this.copyClipboardData(e2);
    this.onInput("");
  },
  onCopy: function(e2) {
    if (!Cleave.Util.checkFullSelection(this.element.value))
      return;
    this.copyClipboardData(e2);
  },
  copyClipboardData: function(e2) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, inputValue = owner.element.value, textToCopy = "";
    if (!pps.copyDelimiter) {
      textToCopy = Util2.stripDelimiters(inputValue, pps.delimiter, pps.delimiters);
    } else {
      textToCopy = inputValue;
    }
    try {
      if (e2.clipboardData) {
        e2.clipboardData.setData("Text", textToCopy);
      } else {
        window.clipboardData.setData("Text", textToCopy);
      }
      e2.preventDefault();
    } catch (ex) {
    }
  },
  onInput: function(value) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util;
    var postDelimiterAfter = Util2.getPostDelimiter(value, pps.delimiter, pps.delimiters);
    if (!pps.numeral && pps.postDelimiterBackspace && !postDelimiterAfter) {
      value = Util2.headStr(value, value.length - pps.postDelimiterBackspace.length);
    }
    if (pps.phone) {
      if (pps.prefix && (!pps.noImmediatePrefix || value.length)) {
        pps.result = pps.prefix + pps.phoneFormatter.format(value).slice(pps.prefix.length);
      } else {
        pps.result = pps.phoneFormatter.format(value);
      }
      owner.updateValueState();
      return;
    }
    if (pps.numeral) {
      if (pps.prefix && pps.noImmediatePrefix && value.length === 0) {
        pps.result = "";
      } else {
        pps.result = pps.numeralFormatter.format(value);
      }
      owner.updateValueState();
      return;
    }
    if (pps.date) {
      value = pps.dateFormatter.getValidatedDate(value);
    }
    if (pps.time) {
      value = pps.timeFormatter.getValidatedTime(value);
    }
    value = Util2.stripDelimiters(value, pps.delimiter, pps.delimiters);
    value = Util2.getPrefixStrippedValue(value, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
    value = pps.numericOnly ? Util2.strip(value, /[^\d]/g) : value;
    value = pps.uppercase ? value.toUpperCase() : value;
    value = pps.lowercase ? value.toLowerCase() : value;
    if (pps.prefix) {
      if (pps.tailPrefix) {
        value = value + pps.prefix;
      } else {
        value = pps.prefix + value;
      }
      if (pps.blocksLength === 0) {
        pps.result = value;
        owner.updateValueState();
        return;
      }
    }
    if (pps.creditCard) {
      owner.updateCreditCardPropsByValue(value);
    }
    value = Util2.headStr(value, pps.maxLength);
    pps.result = Util2.getFormattedValue(value, pps.blocks, pps.blocksLength, pps.delimiter, pps.delimiters, pps.delimiterLazyShow);
    owner.updateValueState();
  },
  updateCreditCardPropsByValue: function(value) {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, creditCardInfo;
    if (Util2.headStr(pps.result, 4) === Util2.headStr(value, 4)) {
      return;
    }
    creditCardInfo = Cleave.CreditCardDetector.getInfo(value, pps.creditCardStrictMode);
    pps.blocks = creditCardInfo.blocks;
    pps.blocksLength = pps.blocks.length;
    pps.maxLength = Util2.getMaxLength(pps.blocks);
    if (pps.creditCardType !== creditCardInfo.type) {
      pps.creditCardType = creditCardInfo.type;
      pps.onCreditCardTypeChanged.call(owner, pps.creditCardType);
    }
  },
  updateValueState: function() {
    var owner = this, Util2 = Cleave.Util, pps = owner.properties;
    if (!owner.element) {
      return;
    }
    var endPos = owner.element.selectionEnd;
    var oldValue = owner.element.value;
    var newValue = pps.result;
    endPos = Util2.getNextCursorPosition(endPos, oldValue, newValue, pps.delimiter, pps.delimiters);
    if (owner.isAndroid) {
      window.setTimeout(function() {
        owner.element.value = newValue;
        Util2.setSelection(owner.element, endPos, pps.document, false);
        owner.callOnValueChanged();
      }, 1);
      return;
    }
    owner.element.value = newValue;
    if (pps.swapHiddenInput)
      owner.elementSwapHidden.value = owner.getRawValue();
    Util2.setSelection(owner.element, endPos, pps.document, false);
    owner.callOnValueChanged();
  },
  callOnValueChanged: function() {
    var owner = this, pps = owner.properties;
    pps.onValueChanged.call(owner, {
      target: {
        name: owner.element.name,
        value: pps.result,
        rawValue: owner.getRawValue()
      }
    });
  },
  setPhoneRegionCode: function(phoneRegionCode) {
    var owner = this, pps = owner.properties;
    pps.phoneRegionCode = phoneRegionCode;
    owner.initPhoneFormatter();
    owner.onChange();
  },
  setRawValue: function(value) {
    var owner = this, pps = owner.properties;
    value = value !== void 0 && value !== null ? value.toString() : "";
    if (pps.numeral) {
      value = value.replace(".", pps.numeralDecimalMark);
    }
    pps.postDelimiterBackspace = false;
    owner.element.value = value;
    owner.onInput(value);
  },
  getRawValue: function() {
    var owner = this, pps = owner.properties, Util2 = Cleave.Util, rawValue = owner.element.value;
    if (pps.rawValueTrimPrefix) {
      rawValue = Util2.getPrefixStrippedValue(rawValue, pps.prefix, pps.prefixLength, pps.result, pps.delimiter, pps.delimiters, pps.noImmediatePrefix, pps.tailPrefix, pps.signBeforePrefix);
    }
    if (pps.numeral) {
      rawValue = pps.numeralFormatter.getRawValue(rawValue);
    } else {
      rawValue = Util2.stripDelimiters(rawValue, pps.delimiter, pps.delimiters);
    }
    return rawValue;
  },
  getISOFormatDate: function() {
    var owner = this, pps = owner.properties;
    return pps.date ? pps.dateFormatter.getISOFormatDate() : "";
  },
  getISOFormatTime: function() {
    var owner = this, pps = owner.properties;
    return pps.time ? pps.timeFormatter.getISOFormatTime() : "";
  },
  getFormattedValue: function() {
    return this.element.value;
  },
  destroy: function() {
    var owner = this;
    owner.element.removeEventListener("input", owner.onChangeListener);
    owner.element.removeEventListener("keydown", owner.onKeyDownListener);
    owner.element.removeEventListener("focus", owner.onFocusListener);
    owner.element.removeEventListener("cut", owner.onCutListener);
    owner.element.removeEventListener("copy", owner.onCopyListener);
  },
  toString: function() {
    return "[Cleave Object]";
  }
};
Cleave.NumeralFormatter = NumeralFormatter_1;
Cleave.DateFormatter = DateFormatter_1;
Cleave.TimeFormatter = TimeFormatter_1;
Cleave.PhoneFormatter = PhoneFormatter_1;
Cleave.CreditCardDetector = CreditCardDetector_1;
Cleave.Util = Util_1;
Cleave.DefaultProperties = DefaultProperties_1;
(typeof commonjsGlobal2 === "object" && commonjsGlobal2 ? commonjsGlobal2 : window)["Cleave"] = Cleave;
var Cleave_1 = Cleave;
var cleave_esm_default = Cleave_1;

// node_modules/vuestic-ui/dist/es/src/components/va-input/hooks/useCleave.js
var __defProp47 = Object.defineProperty;
var __getOwnPropSymbols47 = Object.getOwnPropertySymbols;
var __hasOwnProp47 = Object.prototype.hasOwnProperty;
var __propIsEnum47 = Object.prototype.propertyIsEnumerable;
var __defNormalProp47 = (obj, key, value) => key in obj ? __defProp47(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues47 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp47.call(b2, prop))
      __defNormalProp47(a2, prop, b2[prop]);
  if (__getOwnPropSymbols47)
    for (var prop of __getOwnPropSymbols47(b2)) {
      if (__propIsEnum47.call(b2, prop))
        __defNormalProp47(a2, prop, b2[prop]);
    }
  return a2;
};
var DEFAULT_MASK_TOKENS = {
  creditCard: {
    creditCard: true
  },
  date: {
    date: true,
    datePattern: ["d", "m", "Y"]
  },
  time: {
    time: true,
    timePattern: ["h", "m"],
    timeFormat: "24"
  },
  numeral: {
    numeral: true,
    numeralThousandsGroupStyle: "thousand"
  }
};
var useCleaveProps = {
  mask: { type: [String, Object], default: "" },
  returnRaw: { type: Boolean, default: true },
  modelValue: { type: String }
};
var useCleave = (element, props, emit) => {
  const cleave = ref();
  const getMask = (mask) => {
    if (typeof mask === "string") {
      return DEFAULT_MASK_TOKENS[mask] ? __spreadValues47({}, DEFAULT_MASK_TOKENS[mask]) : {};
    }
    return __spreadValues47({}, mask);
  };
  const destroyCleave = () => {
    if (cleave.value) {
      cleave.value.destroy();
    }
  };
  const initCleave = () => {
    destroyCleave();
    if (!element.value) {
      return;
    }
    cleave.value = new cleave_esm_default(element.value, getMask(props.mask));
  };
  onMounted(() => {
    initCleave();
  });
  onBeforeUnmount(() => {
    destroyCleave();
  });
  watch(() => [element.value, props.mask], () => {
    initCleave();
  });
  const computedValue = computed(() => {
    if (cleave.value) {
      if (props.returnRaw && props.modelValue === cleave.value.getRawValue()) {
        return cleave.value.getFormattedValue();
      }
    }
    return props.modelValue;
  });
  const onInput = (event) => {
    const value = event.target.value;
    if (props.mask !== "string" && !Object.keys(props.mask).length) {
      emit("update:modelValue", value);
      return;
    }
    if (cleave.value) {
      cleave.value.setRawValue(value);
      if (props.returnRaw) {
        emit("update:modelValue", cleave.value.getRawValue());
        return;
      }
    }
    emit("update:modelValue", value);
  };
  return {
    cleave,
    computedValue,
    onInput
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaInputWrapper/VaInputWrapper.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useCSSVariables.js
init_vue_runtime_esm_bundler();
var useCSSVariables = (prefix2, cb) => {
  return computed(() => Object.entries(cb()).map(([key, value]) => ({ [`--${prefix2}-${kebabCase_1(key)}`]: value })));
};

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaInputWrapper/VaInputWrapper.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaInputWrapper/VaInputWrapper.css";
var __defProp48 = Object.defineProperty;
var __defProps38 = Object.defineProperties;
var __getOwnPropDescs38 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols48 = Object.getOwnPropertySymbols;
var __hasOwnProp48 = Object.prototype.hasOwnProperty;
var __propIsEnum48 = Object.prototype.propertyIsEnumerable;
var __defNormalProp48 = (obj, key, value) => key in obj ? __defProp48(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues48 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp48.call(b2, prop))
      __defNormalProp48(a2, prop, b2[prop]);
  if (__getOwnPropSymbols48)
    for (var prop of __getOwnPropSymbols48(b2)) {
      if (__propIsEnum48.call(b2, prop))
        __defNormalProp48(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps38 = (a2, b2) => __defProps38(a2, __getOwnPropDescs38(b2));
var __default__2 = defineComponent({
  name: "VaInputWrapper",
  components: { VaMessageList, VaIcon: VaIcon2 },
  props: __spreadProps38(__spreadValues48(__spreadValues48({}, useFormProps), useValidationProps), {
    counterValue: { type: Number, default: void 0 },
    maxLength: { type: Number, default: void 0 },
    label: { type: String, default: "" },
    color: { type: String, default: "primary" },
    background: { type: String, default: "background-element" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    error: { type: Boolean, default: false },
    success: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  }),
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner"
  ],
  setup(props) {
    const { getColor } = useColors();
    const wrapperClass = useBem("va-input-wrapper", () => __spreadProps38(__spreadValues48({}, pick_1(props, ["outline", "bordered", "success", "focused", "error", "disabled", "readonly"])), {
      labeled: !!props.label,
      solid: !props.outline && !props.bordered
    }));
    const wrapperStyle = useCSSVariables("va-input-wrapper", () => ({
      color: colorComputed.value
    }));
    const colorComputed = computed(() => getColor(props.color));
    const borderColorComputed = computed(() => props.focused ? colorComputed.value : void 0);
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const hasMessages = computed(() => {
      var _a;
      return Boolean(typeof messagesComputed.value === "string" ? messagesComputed.value : (_a = messagesComputed.value) == null ? void 0 : _a.length);
    });
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const containerStyle = computed(() => ({
      color: textColorComputed.value,
      "caret-color": textColorComputed.value,
      "--va-input-color": props.background ? getColor(props.background) : void 0,
      borderColor: borderColorComputed.value
    }));
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    const isCounterVisible = computed(() => props.counterValue !== void 0);
    const counterComputed = computed(() => props.maxLength !== void 0 ? `${props.counterValue}/${props.maxLength}` : props.counterValue);
    return {
      containerStyle,
      wrapperClass,
      wrapperStyle,
      textColorComputed,
      isCounterVisible,
      counterComputed,
      colorComputed,
      borderColorComputed,
      messagesColor,
      messagesComputed,
      hasMessages,
      errorLimit
    };
  },
  methods: {
    focus() {
      this.$el.focus();
    },
    blur() {
      this.$el.blur();
    }
  }
});
var __injectCSSVars__2 = () => {
  useCssVars((_ctx) => ({
    "54f3ee2b": _ctx.textColorComputed
  }));
};
var __setup__2 = __default__2.setup;
__default__2.setup = __setup__2 ? (props, ctx) => {
  __injectCSSVars__2();
  return __setup__2(props, ctx);
} : __injectCSSVars__2;
var _sfc_main33 = __default__2;
var _hoisted_118 = { class: "va-input-wrapper__container" };
var _hoisted_211 = { class: "va-input-wrapper__field" };
var _hoisted_36 = { class: "va-input-wrapper__text" };
var _hoisted_46 = {
  key: 0,
  class: "va-input-wrapper__required-mark"
};
var _hoisted_55 = {
  key: 0,
  class: "va-input-wrapper__bottom"
};
var _hoisted_64 = { class: "va-input-wrapper__bottom-counter" };
function _sfc_render32(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-input-wrapper", _ctx.wrapperClass]),
    style: normalizeStyle(_ctx.wrapperStyle),
    onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click", $event))
  }, [
    createBaseVNode("div", _hoisted_118, [
      _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-input-wrapper__prepend-inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-prepend"))
      }, [
        renderSlot(_ctx.$slots, "prepend")
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_211, [
        _ctx.$slots.prependInner ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "va-input__container",
          ref: "container",
          style: normalizeStyle(_ctx.containerStyle),
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-prepend-inner", $event))
        }, [
          renderSlot(_ctx.$slots, "prependInner")
        ], 4)) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_36, [
          _ctx.label ? (openBlock(), createElementBlock("label", {
            key: 0,
            "aria-hidden": "true",
            class: "va-input-wrapper__label",
            style: normalizeStyle({ color: _ctx.colorComputed })
          }, [
            createTextVNode(toDisplayString(_ctx.label) + " ", 1),
            _ctx.requiredMark ? (openBlock(), createElementBlock("span", _hoisted_46, " * ")) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default")
        ]),
        _ctx.success ? (openBlock(), createBlock(_component_va_icon, {
          key: 1,
          color: "success",
          name: "va-check-circle",
          size: "small"
        })) : createCommentVNode("", true),
        _ctx.error ? (openBlock(), createBlock(_component_va_icon, {
          key: 2,
          color: "danger",
          name: "va-warning",
          size: "small"
        })) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "icon"),
        _ctx.$slots.appendInner ? (openBlock(), createElementBlock("div", {
          key: 3,
          class: "va-input-wrapper__append-inner",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click-append-inner", $event))
        }, [
          renderSlot(_ctx.$slots, "appendInner")
        ])) : createCommentVNode("", true)
      ]),
      _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-input-wrapper__append-inner",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-append"))
      }, [
        renderSlot(_ctx.$slots, "append")
      ])) : createCommentVNode("", true)
    ]),
    _ctx.isCounterVisible ? (openBlock(), createElementBlock("div", _hoisted_55, [
      renderSlot(_ctx.$slots, "counter", normalizeProps(guardReactiveProps({ valueLength: _ctx.$props.counterValue, maxLength: _ctx.$props.maxLength })), () => [
        createBaseVNode("div", _hoisted_64, toDisplayString(_ctx.counterComputed), 1)
      ])
    ])) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "messages", normalizeProps(guardReactiveProps({ messages: _ctx.messagesComputed, errorLimit: _ctx.errorLimit, color: _ctx.messagesColor })), () => [
      _ctx.hasMessages ? (openBlock(), createBlock(_component_va_message_list, {
        key: 0,
        color: _ctx.messagesColor,
        "model-value": _ctx.messagesComputed,
        limit: _ctx.errorLimit
      }, null, 8, ["color", "model-value", "limit"])) : createCommentVNode("", true)
    ])
  ], 6);
}
var VaInputWrapper = _export_sfc(_sfc_main33, [["render", _sfc_render32]]);

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaTextarea/VaTextarea.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaTextarea/useTextareaRowHeight.js
var HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important';
`;
var SIZING_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
var getNodeHeightStyles = (node) => {
  const style = window.getComputedStyle(node);
  return {
    boxSizing: style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing"),
    padding: parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top")),
    border: parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width")),
    styles: SIZING_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";") + ";",
    lineHeight: parseInt(style.getPropertyValue("line-height"))
  };
};
var textarea = null;
var createHiddenTextarea = (original, styles) => {
  if (!textarea) {
    textarea = document.createElement("textarea");
  }
  textarea.setAttribute("style", styles + HIDDEN_TEXTAREA_STYLE);
  textarea.value = original.value || original.placeholder || "";
  const wrap = original.getAttribute("wrap");
  if (wrap !== null) {
    textarea.setAttribute("wrap", wrap);
  } else {
    textarea.removeAttribute("wrap");
  }
  return textarea;
};
var useTextareaRowHeight = (textarea2) => {
  const calculateRowHeight = () => {
    if (!textarea2.value) {
      return 0;
    }
    return getNodeHeightStyles(textarea2.value).lineHeight;
  };
  const calculateHeight = () => {
    if (!textarea2.value) {
      return 0;
    }
    const { boxSizing, padding, border, styles } = getNodeHeightStyles(textarea2.value);
    const hiddenTextarea = createHiddenTextarea(textarea2.value, styles);
    document.body.appendChild(hiddenTextarea);
    let height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += border;
    } else if (boxSizing === "content-box") {
      height -= padding;
    }
    document.body.removeChild(hiddenTextarea);
    return height;
  };
  return {
    calculateRowHeight,
    calculateHeight
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaTextarea/VaTextarea.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-input/components/VaTextarea/VaTextarea.css";
var __defProp49 = Object.defineProperty;
var __defProps39 = Object.defineProperties;
var __getOwnPropDescs39 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols49 = Object.getOwnPropertySymbols;
var __hasOwnProp49 = Object.prototype.hasOwnProperty;
var __propIsEnum49 = Object.prototype.propertyIsEnumerable;
var __defNormalProp49 = (obj, key, value) => key in obj ? __defProp49(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues49 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp49.call(b2, prop))
      __defNormalProp49(a2, prop, b2[prop]);
  if (__getOwnPropSymbols49)
    for (var prop of __getOwnPropSymbols49(b2)) {
      if (__propIsEnum49.call(b2, prop))
        __defNormalProp49(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps39 = (a2, b2) => __defProps39(a2, __getOwnPropDescs39(b2));
var positiveNumberValidator = (val) => {
  if (val > 0 && (val | 0) === val) {
    return true;
  }
  throw new Error(`\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`);
};
var { createEmits: createEmits2, createListeners: createListeners2 } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
var _sfc_main34 = defineComponent({
  name: "VaTextarea",
  props: __spreadProps39(__spreadValues49({}, useFormProps), {
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: Number,
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: Number,
      validator: positiveNumberValidator
    }
  }),
  emits: createEmits2(),
  setup(props, { emit }) {
    const textarea2 = shallowRef();
    const rowHeight = ref(-1);
    const height = ref(-1);
    const { calculateRowHeight, calculateHeight } = useTextareaRowHeight(textarea2);
    const isResizable = computed(() => {
      return Boolean((props.autosize || props.maxRows || props.minRows !== 1) && textarea2.value);
    });
    const updateRowHeight = () => {
      if (isResizable.value) {
        rowHeight.value = calculateRowHeight();
      }
    };
    const updateHeight = () => {
      if (isResizable.value) {
        height.value = calculateHeight();
      }
    };
    onMounted(() => {
      updateRowHeight();
      updateHeight();
    });
    watch(() => props.modelValue, () => {
      nextTick(updateHeight);
    });
    const computedStyle = computed(() => ({
      minHeight: rowHeight.value * props.minRows + "px",
      maxHeight: props.maxRows ? rowHeight.value * props.maxRows + "px" : void 0,
      height: height.value + "px",
      resize: isResizable.value ? void 0 : "none"
    }));
    const computedProps = computed(() => __spreadValues49({}, pick_1(props, ["disabled", "readonly", "placeholder", "ariaLabel"])));
    const focus = () => {
      var _a;
      (_a = textarea2.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = textarea2.value) == null ? void 0 : _a.blur();
    };
    return {
      textarea: textarea2,
      computedStyle,
      listeners: createListeners2(emit),
      computedProps,
      focus,
      blur
    };
  }
});
var _hoisted_119 = ["value"];
function _sfc_render33(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", mergeProps({
    ref: "textarea",
    class: "textarea",
    style: _ctx.computedStyle
  }, __spreadValues49(__spreadValues49({}, _ctx.computedProps), _ctx.listeners), { value: _ctx.modelValue }), null, 16, _hoisted_119);
}
var VaTextarea = _export_sfc(_sfc_main34, [["render", _sfc_render33]]);

// node_modules/vuestic-ui/dist/es/src/components/va-input/VaInput.js
var __defProp50 = Object.defineProperty;
var __defProps40 = Object.defineProperties;
var __getOwnPropDescs40 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols50 = Object.getOwnPropertySymbols;
var __hasOwnProp50 = Object.prototype.hasOwnProperty;
var __propIsEnum50 = Object.prototype.propertyIsEnumerable;
var __defNormalProp50 = (obj, key, value) => key in obj ? __defProp50(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues50 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp50.call(b2, prop))
      __defNormalProp50(a2, prop, b2[prop]);
  if (__getOwnPropSymbols50)
    for (var prop of __getOwnPropSymbols50(b2)) {
      if (__propIsEnum50.call(b2, prop))
        __defNormalProp50(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps40 = (a2, b2) => __defProps40(a2, __getOwnPropDescs40(b2));
var VaTextareaProps = extractComponentProps(VaTextarea);
var { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(["change", "keyup", "keypress", "keydown", "focus", "blur"]);
var { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
var _sfc_main35 = defineComponent({
  name: "VaInput",
  components: { VaInputWrapper, VaTextarea, VaIcon },
  props: __spreadProps40(__spreadValues50(__spreadValues50(__spreadValues50(__spreadValues50(__spreadValues50(__spreadValues50({}, useFormProps), useValidationProps), useClearableProps), useCleaveProps), VaTextareaProps), useComponentPresetProp), {
    placeholder: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    modelValue: { type: [String, Number], default: "" },
    label: { type: String, default: "" },
    type: { type: String, default: "text" },
    loading: { type: Boolean, default: false },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    ariaLabel: { type: String, default: void 0 },
    counter: { type: Boolean, default: false },
    maxLength: { type: Number, default: void 0 },
    color: { type: String, default: "primary" },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false }
  }),
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits(),
    ...createFieldEmits()
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs, slots }) {
    const input = shallowRef();
    const isFocused = useFocusDeep();
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      var _a;
      (_a = input.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = input.value) == null ? void 0 : _a.blur();
    };
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const {
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const computedCleaveTarget = computed(() => props.type === "textarea" ? void 0 : input.value);
    const { computedValue, onInput } = useCleave(computedCleaveTarget, props, emit);
    const inputListeners = createInputListeners(emit);
    const onFocus = (e2) => {
      inputListeners.onFocus(e2);
      validationListeners.onFocus();
    };
    const onBlur = (e2) => {
      inputListeners.onBlur(e2);
      validationListeners.onBlur();
    };
    const inputEvents = __spreadProps40(__spreadValues50({}, inputListeners), {
      onFocus,
      onBlur,
      onInput
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const computedChildAttributes = computed(() => __spreadValues50(__spreadValues50({
      ariaLabel: props.ariaLabel || props.label,
      ariaRequired: props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      ariaDisabled: props.disabled,
      ariaReadonly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    const computedInputAttributes = computed(() => __spreadValues50(__spreadValues50({}, computedChildAttributes.value), pick_1(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode"])));
    const valueLengthComputed = computed(() => props.counter && typeof computedValue.value === "string" ? computedValue.value.length : void 0);
    return __spreadProps40(__spreadValues50({}, useTranslation()), {
      input,
      inputEvents,
      valueLengthComputed,
      computedChildAttributes,
      computedInputAttributes,
      textareaProps: filterComponentProps(props, VaTextareaProps),
      computedValue,
      tabIndexComputed,
      computedError,
      computedErrorMessages,
      isFocused,
      canBeCleared,
      clearIconProps,
      fieldListeners: createFieldListeners(emit),
      filterSlots,
      reset,
      focus,
      blur
    });
  }
});
var _hoisted_120 = ["value"];
function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaTextarea = resolveComponent("VaTextarea");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps(_ctx.fieldListeners, {
    class: ["va-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style,
    color: _ctx.$props.color,
    readonly: _ctx.$props.readonly,
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount,
    label: _ctx.$props.label,
    bordered: _ctx.$props.bordered,
    outline: _ctx.$props.outline,
    requiredMark: _ctx.$props.requiredMark,
    focused: _ctx.isFocused,
    "counter-value": _ctx.valueLengthComputed,
    "max-length": _ctx.$props.maxLength,
    onClick: _ctx.focus
  }), createSlots({
    icon: withCtx((slotScope) => [
      _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
        key: 0,
        role: "button",
        "aria-label": _ctx.t("reset"),
        tabindex: _ctx.tabIndexComputed
      }, _ctx.clearIconProps, {
        onClick: withModifiers(_ctx.reset, ["stop"]),
        onKeydown: [
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
          withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
        ]
      }), null, 16, ["aria-label", "tabindex", "onClick", "onKeydown"])) : createCommentVNode("", true),
      _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
        key: 1,
        color: _ctx.$props.color,
        size: "small",
        name: "va-loading",
        spin: "counter-clockwise"
      }, null, 8, ["color"])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(slotScope)))
    ]),
    default: withCtx(() => [
      _ctx.type === "textarea" && !_ctx.$slots.content ? (openBlock(), createBlock(_component_VaTextarea, mergeProps({
        key: 0,
        ref: "input"
      }, __spreadValues50(__spreadValues50(__spreadValues50({}, _ctx.computedChildAttributes), _ctx.textareaProps), _ctx.inputEvents), { class: "va-input__content__input" }), null, 16)) : !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 1,
        ref: "input",
        class: "va-input__content__input"
      }, __spreadValues50(__spreadValues50({}, _ctx.computedInputAttributes), _ctx.inputEvents), { value: _ctx.computedValue }), null, 16, _hoisted_120)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    renderList(_ctx.filterSlots, (name) => {
      return {
        name,
        fn: withCtx((slotScope) => [
          renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
        ])
      };
    })
  ]), 1040, ["class", "style", "color", "readonly", "disabled", "success", "messages", "error", "error-messages", "error-count", "label", "bordered", "outline", "requiredMark", "focused", "counter-value", "max-length", "onClick"]);
}
var _VaInput = _export_sfc(_sfc_main35, [["render", _sfc_render34]]);

// node_modules/vuestic-ui/dist/es/src/components/va-input/index.js
var VaInput = withConfigTransport(_VaInput);

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/VaColorInput.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-color-input/VaColorInput.css";
var __defProp51 = Object.defineProperty;
var __defProps41 = Object.defineProperties;
var __getOwnPropDescs41 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols51 = Object.getOwnPropertySymbols;
var __hasOwnProp51 = Object.prototype.hasOwnProperty;
var __propIsEnum51 = Object.prototype.propertyIsEnumerable;
var __defNormalProp51 = (obj, key, value) => key in obj ? __defProp51(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues51 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp51.call(b2, prop))
      __defNormalProp51(a2, prop, b2[prop]);
  if (__getOwnPropSymbols51)
    for (var prop of __getOwnPropSymbols51(b2)) {
      if (__propIsEnum51.call(b2, prop))
        __defNormalProp51(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps41 = (a2, b2) => __defProps41(a2, __getOwnPropDescs41(b2));
var _sfc_main36 = defineComponent({
  name: "VaColorInput",
  components: {
    VaInput,
    VaColorIndicator
  },
  emits: useStatefulEmits,
  props: __spreadProps41(__spreadValues51(__spreadValues51({}, useStatefulProps), useComponentPresetProp), {
    modelValue: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    }
  }),
  setup: (props, { emit }) => {
    const colorPicker = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const callPickerDialog = () => {
      var _a;
      return !props.disabled && ((_a = colorPicker.value) == null ? void 0 : _a.click());
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    return __spreadProps41(__spreadValues51({}, useTranslation()), {
      valueComputed,
      callPickerDialog,
      colorPicker,
      tabIndexComputed
    });
  }
});
var _hoisted_121 = { class: "va-color-input" };
function _sfc_render35(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  const _component_va_input = resolveComponent("va-input");
  return openBlock(), createElementBlock("div", _hoisted_121, [
    createVNode(_component_va_input, {
      class: "va-color-input__input",
      placeholder: "input color",
      modelValue: _ctx.valueComputed,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.valueComputed = $event),
      tabindex: _ctx.tabIndexComputed,
      disabled: _ctx.$props.disabled
    }, {
      appendInner: withCtx(() => [
        createVNode(_component_va_color_indicator, {
          class: "va-color-input__dot",
          role: "button",
          "aria-label": _ctx.t("openColorPicker"),
          "aria-disabled": _ctx.$props.disabled,
          tabindex: _ctx.tabIndexComputed,
          color: _ctx.valueComputed,
          indicator: _ctx.$props.indicator,
          onClick: _ctx.callPickerDialog,
          onKeydown: [
            withKeys(_ctx.callPickerDialog, ["space"]),
            withKeys(_ctx.callPickerDialog, ["enter"])
          ]
        }, null, 8, ["aria-label", "aria-disabled", "tabindex", "color", "indicator", "onClick", "onKeydown"])
      ]),
      _: 1
    }, 8, ["modelValue", "tabindex", "disabled"]),
    withDirectives(createBaseVNode("input", {
      ref: "colorPicker",
      type: "color",
      class: "visually-hidden",
      "aria-hidden": "true",
      tabindex: "-1",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueComputed = $event)
    }, null, 512), [
      [vModelText, _ctx.valueComputed]
    ])
  ]);
}
var _VaColorInput = _export_sfc(_sfc_main36, [["render", _sfc_render35]]);

// node_modules/vuestic-ui/dist/es/src/components/va-color-input/index.js
var VaColorInput = withConfigTransport(_VaColorInput);

// node_modules/vuestic-ui/dist/es/src/components/va-color-palette/VaColorPalette.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-color-palette/VaColorPalette.css";
var __defProp52 = Object.defineProperty;
var __defProps42 = Object.defineProperties;
var __getOwnPropDescs42 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols52 = Object.getOwnPropertySymbols;
var __hasOwnProp52 = Object.prototype.hasOwnProperty;
var __propIsEnum52 = Object.prototype.propertyIsEnumerable;
var __defNormalProp52 = (obj, key, value) => key in obj ? __defProp52(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues52 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp52.call(b2, prop))
      __defNormalProp52(a2, prop, b2[prop]);
  if (__getOwnPropSymbols52)
    for (var prop of __getOwnPropSymbols52(b2)) {
      if (__propIsEnum52.call(b2, prop))
        __defNormalProp52(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps42 = (a2, b2) => __defProps42(a2, __getOwnPropDescs42(b2));
var _sfc_main37 = defineComponent({
  name: "VaColorPalette",
  components: { VaColorIndicator },
  emits: useStatefulEmits,
  props: __spreadProps42(__spreadValues52(__spreadValues52({}, useStatefulProps), useComponentPresetProp), {
    modelValue: { type: String, default: null },
    palette: { type: Array, default: () => [] },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    }
  }),
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    return __spreadProps42(__spreadValues52({}, useTranslation()), {
      valueComputed,
      isSelected: (color) => valueComputed.value === color
    });
  }
});
var _hoisted_122 = { class: "va-color-palette" };
var _hoisted_212 = ["aria-label"];
function _sfc_render36(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_color_indicator = resolveComponent("va-color-indicator");
  return openBlock(), createElementBlock("div", _hoisted_122, [
    createBaseVNode("ul", {
      class: "va-color-palette__colors",
      role: "listbox",
      "aria-label": _ctx.t("colorSelection")
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palette, (color, index) => {
        return openBlock(), createBlock(_component_va_color_indicator, {
          key: index,
          role: "option",
          "aria-label": _ctx.t("color", { color }),
          "aria-selected": _ctx.isSelected(color),
          tabindex: "0",
          modelValue: _ctx.isSelected(color),
          color,
          square: _ctx.indicator === "square",
          "onUpdate:modelValue": ($event) => _ctx.valueComputed = color
        }, null, 8, ["aria-label", "aria-selected", "modelValue", "color", "square", "onUpdate:modelValue"]);
      }), 128))
    ], 8, _hoisted_212)
  ]);
}
var _VaColorPalette = _export_sfc(_sfc_main37, [["render", _sfc_render36]]);

// node_modules/vuestic-ui/dist/es/src/components/va-color-palette/index.js
var VaColorPalette = withConfigTransport(_VaColorPalette);

// node_modules/vuestic-ui/dist/es/src/components/va-content/VaContent.js
init_vue_runtime_esm_bundler();
var _sfc_main38 = {
  name: "VaContent"
};
var _hoisted_123 = { class: "va-typography-block" };
function _sfc_render37(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_123, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaContent = _export_sfc(_sfc_main38, [["render", _sfc_render37]]);

// node_modules/vuestic-ui/dist/es/src/components/va-content/index.js
var VaContent = withConfigTransport(_VaContent);

// node_modules/vuestic-ui/dist/es/src/components/va-counter/VaCounter.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/utils/css-utils.js
var safeCSSLength = (length) => typeof length === "number" ? `${length}px` : length;

// node_modules/vuestic-ui/dist/es/src/components/va-counter/hooks/useCounterPropsValidation.js
init_vue_runtime_esm_bundler();
function useCounterPropsValidation(props) {
  const validateCounterProps = () => {
    const val = Number(props.modelValue);
    if (Number.isNaN(val)) {
      return;
    }
    if (props.min && props.max && props.min > props.max) {
      warn(`The maximum value (${props.max}) can not be less than the minimum value (${props.min}).`);
    }
    if (props.min && val < props.min) {
      warn(`The value of the counter (${val}) can not be less than the minimum value (${props.min}).`);
    }
    if (props.max && val > props.max) {
      warn(`The value of the counter (${val}) can not be greater than the maximum value (${props.max}).`);
    }
    if (props.min && props.max && props.step > props.max - props.min) {
      warn(`The value of the step (${props.step}) can not be greater than the difference (${props.max - props.min}) between maximum value (${props.max}) and minimum value (${props.min}).`);
    }
  };
  watch([
    () => props.step,
    () => props.min,
    () => props.max
  ], validateCounterProps, { immediate: true });
}

// node_modules/vuestic-ui/dist/es/src/components/va-counter/VaCounter.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-counter/VaCounter.css";
var __defProp53 = Object.defineProperty;
var __defProps43 = Object.defineProperties;
var __getOwnPropDescs43 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols53 = Object.getOwnPropertySymbols;
var __hasOwnProp53 = Object.prototype.hasOwnProperty;
var __propIsEnum53 = Object.prototype.propertyIsEnumerable;
var __defNormalProp53 = (obj, key, value) => key in obj ? __defProp53(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues53 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp53.call(b2, prop))
      __defNormalProp53(a2, prop, b2[prop]);
  if (__getOwnPropSymbols53)
    for (var prop of __getOwnPropSymbols53(b2)) {
      if (__propIsEnum53.call(b2, prop))
        __defNormalProp53(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps43 = (a2, b2) => __defProps43(a2, __getOwnPropDescs43(b2));
var { createEmits: createInputEmits2, createListeners: createInputListeners2 } = useEmitProxy(["change"]);
var { createEmits: createFieldEmits2, createListeners: createFieldListeners2 } = useEmitProxy([
  { listen: "click-prepend", emit: "click:decrease-button" },
  { listen: "click-append", emit: "click:increase-button" },
  { listen: "click-prepend-inner", emit: "click:decrease-icon" },
  { listen: "click-append-inner", emit: "click:increase-icon" }
]);
var _sfc_main39 = defineComponent({
  name: "VaCounter",
  components: { VaInputWrapper, VaIcon, VaButton },
  props: __spreadProps43(__spreadValues53(__spreadValues53(__spreadValues53({}, useFormProps), useStatefulProps), useComponentPresetProp), {
    modelValue: { type: [String, Number], default: 0 },
    manualInput: { type: Boolean, default: false },
    stateful: { type: Boolean, default: false },
    min: { type: Number, default: void 0 },
    max: { type: Number, default: void 0 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    messages: { type: [Array, String], default: () => [] },
    width: { type: [String, Number], default: "160px" },
    color: { type: String, default: "primary" },
    outline: { type: Boolean },
    bordered: { type: Boolean },
    increaseIcon: { type: String, default: "add" },
    decreaseIcon: { type: String, default: "remove" },
    buttons: { type: Boolean, default: false },
    flat: { type: Boolean, default: true },
    rounded: { type: Boolean, default: false },
    margins: { type: [String, Number], default: "4px" },
    textColor: { type: String, default: void 0 }
  }),
  emits: [
    "update:modelValue",
    ...createInputEmits2(),
    ...createFieldEmits2(),
    ...useFocusEmits
  ],
  inheritAttrs: false,
  setup(props, { emit, attrs }) {
    const input = shallowRef();
    const {
      isFocused,
      focus,
      blur
    } = useFocus(input, emit);
    const { valueComputed } = useStateful(props, emit);
    const setCountInput = ({ target }) => {
      valueComputed.value = Number(target == null ? void 0 : target.value);
    };
    const setCountChange = ({ target }) => {
      calculateCounterValue(Number(target == null ? void 0 : target.value));
    };
    const getRoundDownWithStep = (value) => {
      if (!props.min || !props.step) {
        return value;
      }
      return props.min + props.step * Math.floor((value - props.min) / props.step);
    };
    const calculateCounterValue = (counterValue) => {
      if (props.min && counterValue < props.min) {
        valueComputed.value = props.min;
        return;
      }
      if (props.max && counterValue > props.max) {
        valueComputed.value = props.min && props.step ? getRoundDownWithStep(props.max) : props.max;
        return;
      }
      valueComputed.value = getRoundDownWithStep(counterValue);
    };
    const isMinReached = computed(() => {
      if (!props.min) {
        return false;
      }
      return Number(valueComputed.value) <= props.min;
    });
    const isMaxReached = computed(() => {
      if (!props.max) {
        return false;
      }
      return props.step ? Number(valueComputed.value) > props.max - props.step : Number(valueComputed.value) >= props.max;
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const isDecreaseActionDisabled = computed(() => isMinReached.value || props.readonly || props.disabled);
    const isIncreaseActionDisabled = computed(() => isMaxReached.value || props.readonly || props.disabled);
    const decreaseCount = () => {
      if (isDecreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) - props.step);
    };
    const increaseCount = () => {
      if (isIncreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) + props.step);
    };
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const decreaseIconProps = computed(() => __spreadValues53({
      class: { "va-counter__icon--inactive": isDecreaseActionDisabled.value },
      color: colorComputed.value,
      name: props.decreaseIcon
    }, !isDecreaseActionDisabled.value && { onClick: decreaseCount }));
    const increaseIconProps = computed(() => __spreadValues53({
      class: { "va-counter__icon--inactive": isIncreaseActionDisabled.value },
      color: colorComputed.value,
      name: props.increaseIcon
    }, !isIncreaseActionDisabled.value && { onClick: increaseCount }));
    const isSquareCorners = computed(() => (typeof props.margins === "string" ? parseFloat(props.margins) : props.margins) === 0);
    const buttonProps = computed(() => __spreadProps43(__spreadValues53({}, pick_1(props, ["rounded", "color", "textColor"])), {
      flat: props.flat && !props.outline,
      outline: props.flat && props.outline
    }));
    const decreaseButtonProps = computed(() => __spreadProps43(__spreadValues53({}, buttonProps.value), {
      icon: props.decreaseIcon,
      disabled: isDecreaseActionDisabled.value
    }));
    const increaseButtonProps = computed(() => __spreadProps43(__spreadValues53({}, buttonProps.value), {
      icon: props.increaseIcon,
      disabled: isIncreaseActionDisabled.value
    }));
    const { t: t2 } = useTranslation();
    const inputAttributesComputed = computed(() => __spreadProps43(__spreadValues53(__spreadValues53({
      tabindex: tabIndexComputed.value,
      ariaLabel: props.label || t2("counterValue"),
      ariaValuemin: props.min,
      ariaValuemax: props.max
    }, omit_1(attrs, ["class", "style"])), pick_1(props, ["disabled", "min", "max", "step"])), {
      readonly: props.readonly || !props.manualInput
    }));
    const inputWrapperPropsComputed = computed(() => __spreadValues53({}, pick_1(props, ["color", "readonly", "disabled", "messages", "label", "bordered", "outline"])));
    const classComputed = computed(() => [
      attrs.class,
      { "va-counter--input-square": isSquareCorners.value }
    ]);
    const styleComputed = computed(() => __spreadValues53({
      width: safeCSSLength(props.width)
    }, attrs.style || {}));
    const marginComputed = computed(() => safeCSSLength(props.margins));
    useCounterPropsValidation(props);
    return __spreadProps43(__spreadValues53({}, useTranslation()), {
      input,
      valueComputed,
      isFocused,
      fieldListeners: createFieldListeners2(emit),
      inputListeners: createInputListeners2(emit),
      inputAttributesComputed,
      inputWrapperPropsComputed,
      setCountInput,
      setCountChange,
      decreaseCount,
      increaseCount,
      decreaseIconProps,
      increaseIconProps,
      decreaseButtonProps,
      increaseButtonProps,
      colorComputed,
      classComputed,
      styleComputed,
      marginComputed,
      focus,
      blur
    });
  }
});
var _hoisted_124 = {
  ref: "input",
  tabindex: "0",
  class: "va-counter__content-wrapper"
};
var _hoisted_213 = ["value"];
function _sfc_render38(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  return openBlock(), createBlock(_component_va_input_wrapper, mergeProps({ class: "va-counter" }, __spreadValues53(__spreadValues53({}, _ctx.fieldListeners), _ctx.inputWrapperPropsComputed), {
    class: _ctx.classComputed,
    style: _ctx.styleComputed,
    focused: _ctx.isFocused,
    onKeydown: [
      withKeys(withModifiers(_ctx.increaseCount, ["prevent"]), ["up"]),
      withKeys(withModifiers(_ctx.decreaseCount, ["prevent"]), ["down"])
    ]
  }), createSlots({
    default: withCtx(() => [
      !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps({
        key: 0,
        ref: "input",
        class: "va-input__content__input",
        type: "number",
        inputmode: "decimal"
      }, __spreadValues53(__spreadValues53({}, _ctx.inputAttributesComputed), _ctx.inputListeners), {
        value: _ctx.valueComputed,
        onInput: _cache[4] || (_cache[4] = (...args) => _ctx.setCountInput && _ctx.setCountInput(...args)),
        onChange: _cache[5] || (_cache[5] = (...args) => _ctx.setCountChange && _ctx.setCountChange(...args))
      }), null, 16, _hoisted_213)) : createCommentVNode("", true)
    ]),
    _: 2
  }, [
    _ctx.$props.buttons ? {
      name: "prepend",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__prepend-wrapper",
          style: normalizeStyle({ marginRight: _ctx.marginComputed }),
          onMousedown: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps(__spreadProps43(__spreadValues53({}, slotScope), { decreaseCount: _ctx.decreaseCount }))), () => [
            createVNode(_component_va_button, mergeProps({
              class: "va-counter__button-decrease",
              "aria-label": _ctx.t("decreaseCounter")
            }, _ctx.decreaseButtonProps, { onClick: _ctx.decreaseCount }), null, 16, ["aria-label", "onClick"])
          ])
        ], 36)
      ])
    } : {
      name: "prependInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "decreaseAction", normalizeProps(guardReactiveProps(__spreadProps43(__spreadValues53({}, slotScope), { decreaseCount: _ctx.decreaseCount }))), () => [
            createVNode(_component_va_icon, mergeProps({ class: "va-counter__icon-decrease" }, _ctx.decreaseIconProps), null, 16)
          ])
        ], 32)
      ])
    },
    _ctx.$props.buttons ? {
      name: "append",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          class: "va-counter__append-wrapper",
          style: normalizeStyle({ marginLeft: _ctx.marginComputed }),
          onMousedown: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps(__spreadProps43(__spreadValues53({}, slotScope), { increaseCount: _ctx.increaseCount }))), () => [
            createVNode(_component_va_button, mergeProps({
              class: "va-counter__button-increase",
              "aria-label": _ctx.t("increaseCounter")
            }, _ctx.increaseButtonProps, { onClick: _ctx.increaseCount }), null, 16, ["aria-label", "onClick"])
          ])
        ], 36)
      ])
    } : {
      name: "appendInner",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", {
          onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.focus && _ctx.focus(...args), ["prevent"]))
        }, [
          renderSlot(_ctx.$slots, "increaseAction", normalizeProps(guardReactiveProps(__spreadProps43(__spreadValues53({}, slotScope), { increaseCount: _ctx.increaseCount }))), () => [
            createVNode(_component_va_icon, mergeProps({ class: "va-counter__icon-increase" }, _ctx.increaseIconProps), null, 16)
          ])
        ], 32)
      ])
    },
    _ctx.$slots.content ? {
      name: "default",
      fn: withCtx((slotScope) => [
        createBaseVNode("div", _hoisted_124, [
          renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps(__spreadProps43(__spreadValues53({}, slotScope), { value: Number(_ctx.valueComputed) }))))
        ], 512)
      ])
    } : void 0
  ]), 1040, ["class", "style", "focused", "onKeydown"]);
}
var _VaCounter = _export_sfc(_sfc_main39, [["render", _sfc_render38]]);

// node_modules/vuestic-ui/dist/es/src/components/va-counter/index.js
var VaCounter = withConfigTransport(_VaCounter);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/VaDataTable.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useColumns.js
init_vue_runtime_esm_bundler();
var sortingOptionsValidator = (options) => {
  const isAllowedOptionsLength = options.length === 2 || options.length === 3;
  const isAvailableOptions = options.every((option) => ["asc", "desc", null].includes(option));
  const isUniqueOptions = options.length === new Set(options).size;
  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;
};
var buildTableColumn = (source, initialIndex, props) => {
  const input = typeof source === "string" ? { key: source } : source;
  const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;
  if (!isValidOptions) {
    warn(`The "sortingOptions" array in the column with "${input.key}" key is invalid. For this column, the "sortingOptions" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`);
  }
  return {
    source,
    initialIndex,
    key: input.key,
    name: input.name || input.key,
    label: input.label || startCase_1(input.key),
    thTitle: input.thTitle || input.headerTitle || input.label || startCase_1(input.key),
    sortable: input.sortable || false,
    sortingFn: input.sortingFn,
    sortingOptions: isValidOptions && input.sortingOptions || props.sortingOptions,
    thAlign: input.thAlign || input.alignHead || "left",
    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
    tdAlign: input.tdAlign || input.align || "left",
    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
    width: input.width,
    tdClass: input.tdClass || input.classes,
    thClass: input.thClass || input.headerClasses,
    tdStyle: input.tdStyle || input.style,
    thStyle: input.thStyle || input.headerStyle
  };
};
var buildColumnsFromItems = (props) => {
  return Object.keys(merge_1({}, ...props.items)).map((item, index) => buildTableColumn(item, index, props));
};
var buildNormalizedColumns = (props) => {
  return props.columns.map((item, index) => buildTableColumn(item, index, props));
};
function useColumns(props) {
  const columnsComputed = computed(() => {
    if (props.columns.length === 0) {
      return buildColumnsFromItems(props);
    } else {
      return buildNormalizedColumns(props);
    }
  });
  return {
    columnsComputed
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useRows.js
init_vue_runtime_esm_bundler();
var getItemKey = (source, itemsTrackBy) => typeof itemsTrackBy === "function" ? itemsTrackBy(source) : getValueByPath(source, itemsTrackBy) || source;
var buildTableCell = (rowIndex, rowKey, rowData, column) => {
  var _a;
  const source = getValueByPath(rowData, column.key);
  return {
    rowIndex,
    rowKey,
    rowData,
    column,
    source,
    value: ((_a = source == null ? void 0 : source.toString) == null ? void 0 : _a.call(source)) || ""
  };
};
var buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
  const itemKey = getItemKey(source, itemsTrackBy);
  return {
    initialIndex,
    itemKey,
    source,
    cells: columns.map((column) => buildTableCell(initialIndex, itemKey, source, column))
  };
};
function useRows(columns, props) {
  const rowsComputed = computed(() => props.items.map((rawItem, index) => buildTableRow(rawItem, index, props.itemsTrackBy, columns.value)));
  return {
    rowsComputed
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useFilterable.js
init_vue_runtime_esm_bundler();
function useFilterable(rawRows, props, emit) {
  const filteredRows = computed(() => {
    if (!rawRows.value.length) {
      return rawRows.value;
    }
    if (props.filter === "" && !props.filterMethod) {
      return rawRows.value;
    }
    return rawRows.value.filter((row) => row.cells.some((cell) => {
      return typeof props.filterMethod === "function" ? props.filterMethod(cell.source) : cell.value.toLowerCase().includes(props.filter.toLowerCase());
    }));
  });
  watch(filteredRows, () => {
    emit("filtered", {
      items: filteredRows.value.map((row) => row.source),
      itemsIndexes: filteredRows.value.map((row) => row.initialIndex)
    });
  });
  return {
    filteredRows
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useSortable.js
init_vue_runtime_esm_bundler();
function useSortable(columns, filteredRows, props, emit) {
  const sortByFallback = ref("");
  const sortBySync = computed({
    get() {
      if (props.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props.sortBy;
      }
    },
    set(value) {
      if (props.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref(null);
  const sortingOrderSync = computed({
    get() {
      if (props.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props.sortingOrder;
      }
    },
    set(value) {
      if (props.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit("update:sortingOrder", value);
    }
  });
  const sortedRows = computed(() => {
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const column = columns.value.find((column2) => column2.name === sortBySync.value);
    if (!column || !column.sortable) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.indexOf(column);
    return [...filteredRows.value].sort((a2, b2) => {
      const firstValue = a2.cells[columnIndex].value;
      const secondValue = b2.cells[columnIndex].value;
      const firstSource = a2.cells[columnIndex].source;
      const secondSource = b2.cells[columnIndex].source;
      if (sortingOrderSync.value === null) {
        return a2.initialIndex - b2.initialIndex;
      } else {
        const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : firstValue.localeCompare(secondValue));
      }
    });
  });
  watch(sortedRows, () => {
    emit("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  const getNextSortingOptionsValue = (value, options) => {
    const index = options.findIndex((sortingValue) => sortingValue === value);
    return index !== -1 ? options[(index + 1) % options.length] : options[0];
  };
  function toggleSorting(column) {
    if (column.name === sortBySync.value) {
      sortingOrderSync.value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
    } else {
      sortBySync.value = column.name;
      sortingOrderSync.value = column.sortingOptions[0];
    }
  }
  const sortingOrderIconName = computed(() => {
    return sortingOrderSync.value === "asc" ? "va-arrow-up" : sortingOrderSync.value === "desc" ? "va-arrow-down" : "unfold_more";
  });
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting,
    sortedRows,
    sortingOrderIconName
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/usePaginatedRows.js
init_vue_runtime_esm_bundler();
function usePaginatedRows(sortedRows, props) {
  const paginatedRows = computed(() => {
    if (!props.perPage || props.perPage < 0) {
      return sortedRows.value;
    }
    if (!props.currentPage || props.currentPage < 0) {
      return sortedRows.value.slice(0, props.perPage);
    }
    const pageStartIndex = props.perPage * (props.currentPage - 1);
    return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
  });
  return {
    paginatedRows
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useSelectableRow.js
init_vue_runtime_esm_bundler();
function useSelectableRow(paginatedRows, props, emit) {
  const selectedItemsFallback = ref([]);
  const selectedItemsSync = computed({
    get() {
      if (props.modelValue === void 0) {
        return selectedItemsFallback.value;
      } else {
        return props.modelValue;
      }
    },
    set(modelValue) {
      if (props.modelValue === void 0) {
        selectedItemsFallback.value = modelValue;
      }
      emit("update:modelValue", modelValue);
    }
  });
  const prevSelectedRowIndex = ref(-1);
  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {
    if (newSelectMode === "single" && oldSelectMode === "multiple") {
      selectedItemsSync.value = [];
      setPrevSelectedRowIndex(-1);
    }
  });
  watch(paginatedRows, () => {
    setPrevSelectedRowIndex(-1);
  });
  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
    emit("selectionChange", {
      currentSelectedItems,
      previousSelectedItems
    });
  }, { immediate: true });
  const getKey = (source) => getItemKey(source, props.itemsTrackBy);
  const noRowsSelected = computed(() => !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source))));
  const allRowsSelected = computed(() => {
    if (paginatedRows.value.length === 0) {
      return false;
    }
    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
  });
  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);
  function isRowSelected(row) {
    return selectedItemsSync.value.includes(getKey(row.source));
  }
  function selectAllRows() {
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...paginatedRows.value.map((row) => getKey(row.source))
    ])];
  }
  function unselectAllRows() {
    const paginatedRowsKeys = paginatedRows.value.map((row) => getKey(row.source));
    selectedItemsSync.value = selectedItemsSync.value.filter((item) => !paginatedRowsKeys.includes(item));
  }
  function selectRow(row) {
    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
  }
  function selectOnlyRow(row) {
    selectedItemsSync.value = [getKey(row.source)];
  }
  function unselectRow(row) {
    const index = selectedItemsSync.value.findIndex((item) => item === getKey(row.source));
    selectedItemsSync.value = [
      ...selectedItemsSync.value.slice(0, index),
      ...selectedItemsSync.value.slice(index + 1)
    ];
  }
  function setPrevSelectedRowIndex(rowInitialIndex) {
    if (rowInitialIndex === -1) {
      prevSelectedRowIndex.value = -1;
    } else {
      const prevSelectedRow = paginatedRows.value.find((row) => row.initialIndex === rowInitialIndex);
      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
    }
  }
  function getRowsToSelect(targetIndex) {
    let start;
    let end;
    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
      start = Math.min(prevSelectedRowIndex.value, targetIndex);
      end = Math.max(prevSelectedRowIndex.value, targetIndex);
    } else {
      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
    }
    return paginatedRows.value.slice(start, end + 1);
  }
  function mergeSelection(rowsToSelect) {
    const rowsToSelectedItems = rowsToSelect.map((row) => getKey(row.source));
    if (noRowsSelected.value) {
      selectedItemsSync.value = rowsToSelectedItems;
      return;
    }
    const isInternalSelection = rowsToSelectedItems.every((item) => selectedItemsSync.value.includes(item));
    if (isInternalSelection) {
      selectedItemsSync.value = selectedItemsSync.value.filter((item) => !rowsToSelectedItems.includes(item));
      return;
    }
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...rowsToSelectedItems
    ])];
  }
  function toggleRowSelection(row) {
    if (!props.selectable) {
      return;
    }
    if (isRowSelected(row)) {
      unselectRow(row);
      props.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
    } else {
      props.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
      setPrevSelectedRowIndex(row.initialIndex);
    }
  }
  function ctrlSelectRow(row) {
    if (!props.selectable) {
      return;
    }
    toggleRowSelection(row);
  }
  function shiftSelectRows(row) {
    if (!props.selectable) {
      return;
    }
    if (props.selectMode === "single" || prevSelectedRowIndex.value === -1) {
      return toggleRowSelection(row);
    }
    const targetIndex = paginatedRows.value.indexOf(row);
    mergeSelection(getRowsToSelect(targetIndex));
    setPrevSelectedRowIndex(-1);
  }
  function toggleBulkSelection() {
    if (allRowsSelected.value) {
      unselectAllRows();
    } else {
      selectAllRows();
    }
    setPrevSelectedRowIndex(-1);
  }
  return {
    ctrlSelectRow,
    shiftSelectRows,
    toggleRowSelection,
    toggleBulkSelection,
    isRowSelected,
    noRowsSelected,
    severalRowsSelected,
    allRowsSelected
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useStylable.js
init_vue_runtime_esm_bundler();
var prefix = "--va-data-table";
var isFunction2 = (val) => typeof val === "function";
var getClass = (classes) => isFunction2(classes) ? classes() : classes;
var getStyle = (styles) => isFunction2(styles) ? styles() : styles;
function useStyleable(props) {
  const { getColor, getFocusColor: getFocusColor2, getHoverColor: getHoverColor2 } = useColors();
  const color = computed(() => getColor(props.selectedColor));
  const CSSVariables = computed(() => ({
    hoverColor: getHoverColor2(color.value),
    selectedColor: props.selectable ? getFocusColor2(color.value) : void 0,
    tableHeight: props.height ? safeCSSLength(props.height) : "var(--va-data-table-height)",
    theadBg: props.stickyHeader ? "var(--va-data-table-thead-background, var(--va-data-table-header-background))" : "var(--va-data-table-thead-background)",
    tfootBg: props.stickyFooter ? "var(--va-data-table-tfoot-background, var(--va-data-table-header-background))" : "var(--va-data-table-tfoot-background)"
  }));
  const getHeaderCSSVariables = (column) => ({
    [`${prefix}-width`]: column.width && safeCSSLength(column.width),
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
  });
  const getCellCSSVariables = (cell) => ({
    [`${prefix}-align`]: cell.column.tdAlign,
    [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
  });
  const getFooterCSSVariables = (column) => ({
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? "pointer" : "default"
  });
  return {
    CSSVariables,
    getHeaderCSSVariables,
    getCellCSSVariables,
    getFooterCSSVariables,
    getClass,
    getStyle
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useBinding.js
var isFunction3 = (val) => typeof val === "function";
var isObject3 = (val) => val !== null && typeof val === "object";
function useBinding(props) {
  const getRowBind = (row) => isFunction3(props.rowBind) ? props.rowBind(row.source, row.initialIndex) : isObject3(props.rowBind) ? props.rowBind : {};
  const getCellBind = (cell, row) => isFunction3(props.cellBind) ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject3(props.cellBind) ? props.cellBind : {};
  return {
    getRowBind,
    getCellBind
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useAnimationName.js
init_vue_runtime_esm_bundler();
function useAnimationName(props, rows) {
  const animationType = ref("shuffle");
  const animationName = computed(() => props.animated ? `table-transition-${animationType.value}` : "");
  const oldRowsLength = ref(rows.value.length);
  const isDifferentRowLength = computed(() => rows.value.length !== oldRowsLength.value);
  watch(rows, (newRows, oldRows) => {
    const hasRows = !!(newRows.length && oldRows.length);
    animationType.value = newRows.length > 50 || isDifferentRowLength.value && hasRows ? "fade" : "shuffle";
    oldRowsLength.value = newRows.length;
  });
  watch(() => props.currentPage, () => {
    if (!isDifferentRowLength.value) {
      animationType.value = "shuffle";
    }
  });
  return animationName;
}

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useTableScroll.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useElementRef.js
init_vue_runtime_esm_bundler();
var unrefElement = (el) => {
  var _a;
  const e2 = unref(el);
  return (_a = e2 == null ? void 0 : e2.$el) != null ? _a : e2;
};
var useElementRef = () => {
  const el = shallowRef();
  return computed({
    get() {
      return unrefElement(el);
    },
    set(node) {
      el.value = node;
    }
  });
};

// node_modules/vuestic-ui/dist/es/src/composables/useIntersectionObserver.js
init_vue_runtime_esm_bundler();
var useIntersectionObserver = (cb, options = {}, targetsList = ref([])) => {
  const observer2 = ref();
  const disconnectObserver = () => {
    var _a;
    (_a = observer2.value) == null ? void 0 : _a.disconnect();
  };
  const observeTarget = (target) => {
    var _a;
    const disclosedTarget = unref(target);
    disclosedTarget && ((_a = observer2.value) == null ? void 0 : _a.observe(disclosedTarget));
  };
  const observeAll = (targets) => {
    const disclosedTargets = unref(targets);
    disclosedTargets.forEach(observeTarget);
  };
  const initObserver = () => {
    observer2.value = new IntersectionObserver(cb, unref(options));
  };
  watch([targetsList, options], ([newList, newOptions], [oldList, oldOptions]) => {
    disconnectObserver();
    if (newOptions !== oldOptions) {
      if (newList.length) {
        initObserver();
        observeAll(newList);
      }
      return;
    }
    if (newList.length) {
      if (!observer2.value) {
        initObserver();
      }
      observeAll(newList);
    }
  }, { immediate: true });
  onBeforeUnmount(disconnectObserver);
  return observer2;
};

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/hooks/useTableScroll.js
var useTableScrollProps = {
  scrollTopMargin: { type: Number, default: 0 },
  scrollBottomMargin: { type: Number, default: 0 }
};
var useTableScrollEmits = ["scroll:top", "scroll:bottom"];
function useTableScroll(props, emit) {
  var _a;
  const vNodeProps = (_a = getCurrentInstance()) == null ? void 0 : _a.vnode.props;
  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:top"]) !== void 0;
  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:bottom"]) !== void 0;
  const scrollContainer = useElementRef();
  const topTrigger = useElementRef();
  const bottomTrigger = useElementRef();
  const isObservable = computed(() => !!scrollContainer.value);
  const intersectionHandler = (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target === topTrigger.value ? emit("scroll:top") : emit("scroll:bottom");
      }
    });
  };
  const targets = computed(() => {
    const list = [];
    if (isObservable.value) {
      topTrigger.value && list.push(topTrigger.value);
      bottomTrigger.value && list.push(bottomTrigger.value);
    }
    return list;
  });
  const options = computed(() => {
    var _a2, _b;
    return {
      root: scrollContainer.value,
      rootMargin: `${(_a2 = props.scrollTopMargin) != null ? _a2 : 0}px 0px ${(_b = props.scrollBottomMargin) != null ? _b : 0}px 0px`
    };
  });
  useIntersectionObserver(intersectionHandler, options, targets);
  return {
    scrollContainer,
    topTrigger,
    bottomTrigger,
    doRenderTopTrigger,
    doRenderBottomTrigger
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/VaVirtualScroller.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useTrackBy.js
var useTrackByProps = {
  trackBy: {
    type: [String, Number, Function],
    default: ""
  }
};
var useTrackBy = (props) => {
  const getKey = (item, index, defaultValue) => {
    if (props.trackBy && item && typeof item === "object" && !isFunction_1(props.trackBy)) {
      const isArrayItem = Array.isArray(item);
      let key;
      if (isArrayItem && !isNaN(+props.trackBy)) {
        key = item[+props.trackBy];
      }
      if (!isArrayItem) {
        key = item[props.trackBy];
      }
      if (key || key === 0) {
        return key;
      }
      warn(`${isArrayItem ? "Index" : "Key"} '${props.trackBy}' wasn't found in provided ${isArrayItem ? "array" : "object"}: `, item);
    }
    if (isFunction_1(props.trackBy)) {
      return props.trackBy(item);
    }
    return defaultValue;
  };
  return { getKey };
};

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/useVirtualScrollerSizes.js
init_vue_runtime_esm_bundler();
var validateSizeProp = (v2, propName) => {
  const isProperValue = isParsablePositiveMeasure(v2);
  return isProperValue;
};
var useVirtualScrollerSizesProps = {
  horizontal: { type: Boolean, default: false },
  itemSize: {
    type: [Number, String],
    default: 0,
    validator: (v2) => {
      return validateSizeProp(v2);
    }
  },
  wrapperSize: {
    type: [Number, String],
    default: 100,
    validator: (v2) => {
      return validateSizeProp(v2);
    }
  }
};
var useVirtualScrollerSizes = (props, scrollPosition) => {
  const list = shallowRef();
  const wrapper = shallowRef();
  const parseSizeValue = (value) => {
    if (typeof value === "string") {
      const parsedValue = parseInt(value);
      if (isNaN(parsedValue)) {
        return 0;
      }
      return value.endsWith("rem") ? parsedValue * pageFontSize.value : parsedValue;
    }
    return value;
  };
  const wrapperSize = computed(() => {
    return parseSizeValue(props.wrapperSize);
  });
  const pageFontSize = ref(16);
  const handleWindowResize = () => {
    pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
  };
  useEvent("resize", handleWindowResize, true);
  const itemSizeCalculated = ref(0);
  const calcAverageItemsSize = () => {
    if (!list.value) {
      return;
    }
    const sizes = [];
    const itemsList = list.value.children;
    const itemsAmount = itemsList.length;
    for (let i2 = 0; i2 < itemsAmount; i2++) {
      const currentChild = list.value.children.item(i2);
      currentChild && sizes.push(currentChild[props.horizontal ? "clientWidth" : "clientHeight"]);
    }
    itemSizeCalculated.value = itemsAmount ? Math.trunc(sizes.reduce((acc, el) => acc + el, 0) / (itemsAmount - 1)) : 0;
  };
  const instance = getCurrentInstance();
  onMounted(() => {
    var _a, _b;
    if (!list.value) {
      list.value = (_b = (_a = instance == null ? void 0 : instance.parent) == null ? void 0 : _a.refs) == null ? void 0 : _b.list;
    }
    calcAverageItemsSize();
  });
  watch(scrollPosition, calcAverageItemsSize);
  watch(wrapperSize, calcAverageItemsSize);
  let oldItemSize = 0;
  const itemSize = computed(() => {
    const sizeParsed = parseSizeValue(props.itemSize);
    const result = Math.max(sizeParsed, itemSizeCalculated.value, 1);
    const diff = Math.abs(oldItemSize / result * 100 - 100);
    if (diff > 5 || oldItemSize === 0) {
      oldItemSize = result;
      return result;
    }
    return oldItemSize;
  });
  return { list, wrapper, itemSize, wrapperSize };
};

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/VaVirtualScroller.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/VaVirtualScroller.css";
var __defProp54 = Object.defineProperty;
var __defProps44 = Object.defineProperties;
var __getOwnPropDescs44 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols54 = Object.getOwnPropertySymbols;
var __hasOwnProp54 = Object.prototype.hasOwnProperty;
var __propIsEnum54 = Object.prototype.propertyIsEnumerable;
var __defNormalProp54 = (obj, key, value) => key in obj ? __defProp54(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues54 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp54.call(b2, prop))
      __defNormalProp54(a2, prop, b2[prop]);
  if (__getOwnPropSymbols54)
    for (var prop of __getOwnPropSymbols54(b2)) {
      if (__propIsEnum54.call(b2, prop))
        __defNormalProp54(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps44 = (a2, b2) => __defProps44(a2, __getOwnPropDescs44(b2));
var _sfc_main40 = defineComponent({
  name: "VaVirtualScroller",
  props: __spreadProps44(__spreadValues54(__spreadValues54({}, useTrackByProps), useVirtualScrollerSizesProps), {
    items: { type: Array, default: () => [] },
    bench: { type: Number, default: 10, validator: (v2) => v2 >= 0 },
    disabled: { type: Boolean, default: false },
    table: { type: Boolean, default: false }
  }),
  emits: ["scroll:bottom"],
  setup: (props, { emit }) => {
    const listScrollPosition = ref(0);
    const scrollDirection = computed(() => props.horizontal ? "scrollLeft" : "scrollTop");
    const handleScroll = () => {
      if (!wrapper.value) {
        return;
      }
      listScrollPosition.value = wrapper.value[scrollDirection.value];
    };
    if (!props.disabled) {
      useEvent("scroll", handleScroll, true);
    }
    const { list, wrapper, itemSize, wrapperSize } = useVirtualScrollerSizes(props, listScrollPosition);
    const { getKey } = useTrackBy(props);
    const uniqueKey = (item, index, defaultValue) => getKey(item, index, defaultValue);
    watch(listScrollPosition, (newValue) => {
      if (newValue + wrapperSize.value === containerSize.value) {
        emit("scroll:bottom");
      }
    });
    const renderStartIndex = computed(() => {
      return Math.max(0, Math.floor(listScrollPosition.value / itemSize.value) - props.bench);
    });
    const renderItemsAmount = computed(() => {
      var _a;
      if (!((_a = props.items) == null ? void 0 : _a.length)) {
        return 0;
      }
      return props.disabled ? props.items.length : Math.min(props.items.length - renderStartIndex.value, Math.ceil(wrapperSize.value / itemSize.value) + props.bench * 2);
    });
    const renderEndIndex = computed(() => renderStartIndex.value + renderItemsAmount.value);
    const renderBuffer = computed(() => {
      var _a;
      if (!((_a = props.items) == null ? void 0 : _a.length)) {
        return [];
      }
      return props.items.slice(renderStartIndex.value, renderEndIndex.value);
    });
    const sizeAttribute = computed(() => props.horizontal ? "width" : "height");
    const isDisabledVirtualTable = computed(() => props.table && props.disabled);
    const wrapperStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value ? void 0 : `${wrapperSize.value}px`
    }));
    const wrapperClassComputed = useBem("va-virtual-scroller", () => __spreadValues54({}, pick_1(props, ["horizontal"])));
    const containerSize = computed(() => {
      var _a, _b;
      return ((_b = (_a = props.items) == null ? void 0 : _a.length) != null ? _b : 0) * itemSize.value;
    });
    const containerStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value ? void 0 : `${containerSize.value}px`
    }));
    const currentListOffset = computed(() => renderStartIndex.value * itemSize.value);
    const listStyleComputed = computed(() => ({
      transform: `translate${props.horizontal ? "X" : "Y"}(${currentListOffset.value}px)`
    }));
    const scrollToAttribute = computed(() => props.horizontal ? "left" : "top");
    const virtualScrollTo = (index) => {
      var _a;
      if (!index && index !== 0) {
        return;
      }
      (_a = wrapper.value) == null ? void 0 : _a.scrollTo({ [scrollToAttribute.value]: index * itemSize.value });
    };
    return {
      containerStyleComputed,
      wrapperStyleComputed,
      wrapperClassComputed,
      listStyleComputed,
      currentListOffset,
      renderStartIndex,
      virtualScrollTo,
      renderBuffer,
      uniqueKey,
      wrapper,
      list
    };
  }
});
function _sfc_render39(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(["va-virtual-scroller", _ctx.wrapperClassComputed]),
    style: normalizeStyle(_ctx.wrapperStyleComputed)
  }, [
    renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps({ containerStyleComputed: _ctx.containerStyleComputed, listStyleComputed: _ctx.listStyleComputed, renderBuffer: _ctx.renderBuffer, uniqueKey: _ctx.uniqueKey, currentListOffset: _ctx.currentListOffset })), () => [
      createBaseVNode("div", {
        class: "va-virtual-scroller__container",
        style: normalizeStyle(_ctx.containerStyleComputed)
      }, [
        createBaseVNode("div", {
          ref: "list",
          role: "list",
          class: "va-virtual-scroller__list",
          style: normalizeStyle(_ctx.listStyleComputed)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderBuffer, (item, index) => {
            return renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({
              key: _ctx.uniqueKey(item, index)
            }, { item, index: _ctx.renderStartIndex + index })));
          }), 128))
        ], 4)
      ], 4)
    ])
  ], 6);
}
var _VaVirtualScroller = _export_sfc(_sfc_main40, [["render", _sfc_render39]]);

// node_modules/vuestic-ui/dist/es/src/components/va-virtual-scroller/index.js
var VaVirtualScroller = withConfigTransport(_VaVirtualScroller);

// node_modules/vuestic-ui/dist/es/src/components/va-inner-loading/VaInnerLoading.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-inner-loading/VaInnerLoading.css";
var __defProp55 = Object.defineProperty;
var __defProps45 = Object.defineProperties;
var __getOwnPropDescs45 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols55 = Object.getOwnPropertySymbols;
var __hasOwnProp55 = Object.prototype.hasOwnProperty;
var __propIsEnum55 = Object.prototype.propertyIsEnumerable;
var __defNormalProp55 = (obj, key, value) => key in obj ? __defProp55(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues55 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp55.call(b2, prop))
      __defNormalProp55(a2, prop, b2[prop]);
  if (__getOwnPropSymbols55)
    for (var prop of __getOwnPropSymbols55(b2)) {
      if (__propIsEnum55.call(b2, prop))
        __defNormalProp55(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps45 = (a2, b2) => __defProps45(a2, __getOwnPropDescs45(b2));
var _sfc_main41 = defineComponent({
  name: "VaInnerLoading",
  components: { VaIcon: VaIcon2 },
  props: __spreadProps45(__spreadValues55(__spreadValues55({}, useLoadingProps), useComponentPresetProp), {
    color: { type: String },
    icon: { type: String, default: "autorenew" },
    size: { type: Number, default: 30 }
  }),
  setup(props) {
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    return { colorComputed };
  }
});
var _hoisted_125 = { class: "inner-loading" };
var _hoisted_214 = {
  key: 0,
  class: "inner-loading__overlay",
  "aria-hidden": "true"
};
function _sfc_render40(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", _hoisted_125, [
    renderSlot(_ctx.$slots, "default"),
    _ctx.$props.loading ? (openBlock(), createElementBlock("div", _hoisted_214, [
      createVNode(_component_va_icon, {
        class: "inner-loading__spinner",
        spin: "",
        color: _ctx.colorComputed,
        size: _ctx.$props.size,
        name: _ctx.$props.icon
      }, null, 8, ["color", "size", "name"])
    ])) : createCommentVNode("", true)
  ]);
}
var _VaInnerLoading = _export_sfc(_sfc_main41, [["render", _sfc_render40]]);

// node_modules/vuestic-ui/dist/es/src/components/va-inner-loading/index.js
var VaInnerLoading = withConfigTransport(_VaInnerLoading);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/VaDataTable.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-data-table/VaDataTable.css";
var __defProp56 = Object.defineProperty;
var __defProps46 = Object.defineProperties;
var __getOwnPropDescs46 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols56 = Object.getOwnPropertySymbols;
var __hasOwnProp56 = Object.prototype.hasOwnProperty;
var __propIsEnum56 = Object.prototype.propertyIsEnumerable;
var __defNormalProp56 = (obj, key, value) => key in obj ? __defProp56(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues56 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp56.call(b2, prop))
      __defNormalProp56(a2, prop, b2[prop]);
  if (__getOwnPropSymbols56)
    for (var prop of __getOwnPropSymbols56(b2)) {
      if (__propIsEnum56.call(b2, prop))
        __defNormalProp56(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps46 = (a2, b2) => __defProps46(a2, __getOwnPropDescs46(b2));
var VaVirtualScrollerProps = extractComponentProps(VaVirtualScroller, ["items", "trackBy", "horizontal", "disabled", "table"]);
var __default__3 = defineComponent({
  name: "VaDataTable",
  components: {
    VaVirtualScroller,
    VaInnerLoading,
    VaCheckbox,
    VaIcon: VaIcon2
  },
  inheritAttrs: false,
  props: __spreadProps46(__spreadValues56(__spreadValues56(__spreadValues56({}, useComponentPresetProp), VaVirtualScrollerProps), useTableScrollProps), {
    columns: { type: Array, default: () => [] },
    items: { type: Array, default: () => [] },
    itemsTrackBy: { type: [String, Function], default: "" },
    modelValue: { type: Array },
    sortingOrder: { type: String },
    sortBy: { type: String },
    sortingOptions: {
      type: Array,
      default: () => ["asc", "desc", null],
      validator: sortingOptionsValidator
    },
    filter: { type: String, default: "" },
    filterMethod: { type: Function },
    hoverable: { type: Boolean, default: false },
    clickable: { type: Boolean, default: false },
    animated: { type: Boolean, default: true },
    selectable: { type: Boolean, default: false },
    selectMode: { type: String, default: "multiple" },
    selectedColor: { type: String, default: "primary" },
    perPage: { type: Number },
    currentPage: { type: Number },
    loading: { type: Boolean, default: false },
    loadingColor: { type: String, default: "primary" },
    noDataHtml: { type: String, default: "No items" },
    noDataFilteredHtml: { type: String, default: "No items match the provided filtering condition" },
    hideDefaultHeader: { type: Boolean, default: false },
    footerClone: { type: Boolean, default: false },
    allowFooterSorting: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    stickyHeader: { type: Boolean, default: false },
    stickyFooter: { type: Boolean, default: false },
    height: { type: [String, Number] },
    rowBind: { type: null },
    cellBind: { type: null },
    virtualScroller: { type: Boolean, default: false },
    virtualTrackBy: { type: [String, Number], default: "initialIndex" }
  }),
  emits: [
    "update:modelValue",
    "update:sortBy",
    "update:sortingOrder",
    "filtered",
    "sorted",
    "selectionChange",
    "row:click",
    "row:dblclick",
    "row:contextmenu",
    ...useTableScrollEmits
  ],
  setup(props, { attrs, emit }) {
    const { columnsComputed } = useColumns(props);
    const { rowsComputed } = useRows(columnsComputed, props);
    const { filteredRows } = useFilterable(rowsComputed, props, emit);
    const {
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortedRows,
      sortingOrderIconName
    } = useSortable(columnsComputed, filteredRows, props, emit);
    const { paginatedRows } = usePaginatedRows(sortedRows, props);
    const {
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected
    } = useSelectableRow(paginatedRows, props, emit);
    const {
      CSSVariables,
      getHeaderCSSVariables,
      getCellCSSVariables,
      getFooterCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStyleable(props);
    const { getRowBind, getCellBind } = useBinding(props);
    const animationName = useAnimationName(props, paginatedRows);
    const showNoDataHtml = computed(() => props.items.length === 0);
    const showNoDataFilteredHtml = computed(() => paginatedRows.value.length === 0);
    const onRowClickHandler = (name, event, row) => {
      if (props.clickable) {
        emit(name, {
          event,
          item: row.source,
          itemIndex: row.initialIndex
        });
      }
    };
    const computedTableAttributes = computed(() => __spreadProps46(__spreadValues56({}, omit_1(attrs, ["class", "style"])), {
      class: pick_1(props, ["striped", "selectable", "hoverable", "clickable"])
    }));
    const getColumnAriaSortOrder = (columnName) => sortingOrderSync.value && sortBySync.value === columnName ? sortingOrderSync.value === "asc" ? "ascending" : "descending" : "none";
    const virtualScrollerPropsComputed = computed(() => __spreadProps46(__spreadValues56({}, pick_1(props, ["wrapperSize", "itemSize", "bench"])), {
      items: paginatedRows.value,
      trackBy: props.virtualTrackBy,
      disabled: !props.virtualScroller,
      table: true
    }));
    const computedAttributes = computed(() => __spreadValues56({
      class: [
        { "va-data-table--sticky": props.stickyHeader || props.stickyFooter },
        { "va-data-table--scroll": !!props.height },
        { "va-data-table--virtual-scroller": props.virtualScroller },
        attrs.class
      ],
      style: [attrs.style]
    }, virtualScrollerPropsComputed.value));
    const {
      scrollContainer,
      topTrigger,
      bottomTrigger,
      doRenderTopTrigger,
      doRenderBottomTrigger
    } = useTableScroll(props, emit);
    return __spreadProps46(__spreadValues56({}, useTranslation()), {
      scrollContainer,
      topTrigger,
      bottomTrigger,
      columnsComputed,
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected,
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortingOrderIconName,
      CSSVariables,
      getHeaderCSSVariables,
      getCellCSSVariables,
      getFooterCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2,
      showNoDataHtml,
      showNoDataFilteredHtml,
      onRowClickHandler,
      computedAttributes,
      computedTableAttributes,
      animationName,
      getColumnAriaSortOrder,
      getRowBind,
      getCellBind,
      doRenderTopTrigger,
      doRenderBottomTrigger
    });
  }
});
var __injectCSSVars__3 = () => {
  useCssVars((_ctx) => ({
    "f1d7a5de": _ctx.CSSVariables.selectedColor,
    "48be8ec4": _ctx.CSSVariables.hoverColor,
    "5d7a2744": _ctx.CSSVariables.tableHeight,
    "1bf46bfc": _ctx.CSSVariables.theadBg,
    "21a0c5e0": _ctx.CSSVariables.tfootBg
  }));
};
var __setup__3 = __default__3.setup;
__default__3.setup = __setup__3 ? (props, ctx) => {
  __injectCSSVars__3();
  return __setup__3(props, ctx);
} : __injectCSSVars__3;
var _sfc_main42 = __default__3;
var _hoisted_126 = {
  key: 0,
  ref: "topTrigger",
  class: "va-data-table__scroll-trigger"
};
var _hoisted_215 = { key: 0 };
var _hoisted_37 = {
  key: 0,
  class: "va-data-table__table-tr"
};
var _hoisted_47 = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
var _hoisted_56 = ["aria-sort", "aria-label", "title", "onClick", "onKeydown"];
var _hoisted_65 = { class: "va-data-table__table-th-wrapper" };
var _hoisted_73 = { key: 0 };
var _hoisted_82 = {
  ref: "list",
  class: "va-data-table__table-tbody"
};
var _hoisted_92 = { key: "showNoDataHtml" };
var _hoisted_10 = ["colspan", "innerHTML"];
var _hoisted_11 = { key: "showNoDataFilteredHtml" };
var _hoisted_127 = ["colspan", "innerHTML"];
var _hoisted_132 = ["onClick", "onDblclick", "onContextmenu"];
var _hoisted_142 = {
  key: 0,
  class: "va-data-table__table-tr"
};
var _hoisted_152 = {
  key: 0,
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
var _hoisted_162 = ["title", "aria-label", "onClick", "onKeydown"];
var _hoisted_172 = { class: "va-data-table__table-th-wrapper" };
var _hoisted_182 = { key: 0 };
var _hoisted_192 = {
  key: 1,
  ref: "bottomTrigger",
  class: "va-data-table__scroll-trigger"
};
function _sfc_render41(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_inner_loading = resolveComponent("va-inner-loading");
  const _component_va_virtual_scroller = resolveComponent("va-virtual-scroller");
  return openBlock(), createBlock(_component_va_virtual_scroller, mergeProps({ class: "va-data-table" }, _ctx.computedAttributes), {
    content: withCtx(({
      uniqueKey,
      renderBuffer,
      currentListOffset,
      listStyleComputed,
      containerStyleComputed
    }) => [
      createVNode(_component_va_inner_loading, {
        ref: "scrollContainer",
        "aria-live": "polite",
        style: normalizeStyle(containerStyleComputed),
        loading: _ctx.loading,
        color: _ctx.loadingColor
      }, {
        default: withCtx(() => [
          _ctx.doRenderTopTrigger ? (openBlock(), createElementBlock("div", _hoisted_126, null, 512)) : createCommentVNode("", true),
          createBaseVNode("table", mergeProps({
            class: "va-data-table__table",
            style: listStyleComputed
          }, _ctx.computedTableAttributes), [
            "colgroup" in _ctx.$slots ? (openBlock(), createElementBlock("colgroup", _hoisted_215, [
              renderSlot(_ctx.$slots, "colgroup", normalizeProps(guardReactiveProps(_ctx.columnsComputed)))
            ])) : createCommentVNode("", true),
            createBaseVNode("thead", {
              class: normalizeClass(["va-data-table__table-thead", { "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader }]),
              style: normalizeStyle({ top: _ctx.$props.virtualScroller && _ctx.$props.stickyHeader ? `-${currentListOffset}px` : void 0 })
            }, [
              renderSlot(_ctx.$slots, "headerPrepend"),
              !_ctx.hideDefaultHeader ? (openBlock(), createElementBlock("tr", _hoisted_37, [
                _ctx.selectable ? (openBlock(), createElementBlock("th", _hoisted_47, [
                  _ctx.selectMode === "multiple" ? (openBlock(), createBlock(_component_va_checkbox, {
                    key: 0,
                    class: "va-data-table__table-cell-checkbox",
                    "aria-label": _ctx.t("selectAllRows"),
                    "model-value": _ctx.severalRowsSelected ? "idl" : _ctx.allRowsSelected,
                    "true-value": true,
                    "false-value": false,
                    color: _ctx.selectedColor,
                    "indeterminate-value": "idl",
                    indeterminate: "",
                    "onUpdate:modelValue": _ctx.toggleBulkSelection
                  }, null, 8, ["aria-label", "model-value", "color", "onUpdate:modelValue"])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsComputed, (column) => {
                  return openBlock(), createElementBlock("th", {
                    key: column.name,
                    scope: "col",
                    "aria-sort": _ctx.getColumnAriaSortOrder(column.name),
                    "aria-label": column.sortable ? _ctx.t(`sortColumnBy`, { name: column.label }) : void 0,
                    title: column.thTitle,
                    class: normalizeClass(["va-data-table__table-th", _ctx.getClass(column.thClass)]),
                    style: normalizeStyle([_ctx.getHeaderCSSVariables(column), _ctx.getStyle(column.thStyle)]),
                    onClick: withModifiers(($event) => column.sortable && _ctx.toggleSorting(column), ["exact"]),
                    onKeydown: withKeys(withModifiers(($event) => column.sortable && _ctx.toggleSorting(column), ["stop"]), ["enter"])
                  }, [
                    createBaseVNode("div", _hoisted_65, [
                      `header(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_73, [
                        renderSlot(_ctx.$slots, `header(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
                      ])) : renderSlot(_ctx.$slots, "header", normalizeProps(mergeProps({ key: 1 }, { label: column.label, key: column.key })), () => [
                        createBaseVNode("span", null, toDisplayString(column.label), 1)
                      ]),
                      column.sortable ? (openBlock(), createElementBlock("div", {
                        key: 2,
                        class: "va-data-table__table-th-sorting",
                        "aria-hidden": "true",
                        onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {
                        }, ["prevent"]))
                      }, [
                        createVNode(_component_va_icon, {
                          role: column.sortable ? "button" : void 0,
                          tabindex: column.sortable ? 0 : -1,
                          name: _ctx.sortingOrderIconName,
                          size: "small",
                          class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }])
                        }, null, 8, ["role", "tabindex", "name", "class"])
                      ], 32)) : createCommentVNode("", true)
                    ])
                  ], 46, _hoisted_56);
                }), 128))
              ])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "headerAppend")
            ], 6),
            createBaseVNode("tbody", _hoisted_82, [
              renderSlot(_ctx.$slots, "bodyPrepend"),
              createVNode(TransitionGroup, {
                name: _ctx.$props.virtualScroller ? "" : _ctx.animationName,
                css: !_ctx.$props.virtualScroller,
                appear: !_ctx.$props.virtualScroller
              }, {
                default: withCtx(() => [
                  _ctx.showNoDataHtml ? (openBlock(), createElementBlock("tr", _hoisted_92, [
                    createBaseVNode("td", {
                      class: "no-data",
                      colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                      innerHTML: _ctx.noDataHtml
                    }, null, 8, _hoisted_10)
                  ])) : _ctx.showNoDataFilteredHtml ? (openBlock(), createElementBlock("tr", _hoisted_11, [
                    createBaseVNode("td", {
                      class: "no-data",
                      colspan: _ctx.columnsComputed.length + (_ctx.selectable ? 1 : 0),
                      innerHTML: _ctx.noDataFilteredHtml
                    }, null, 8, _hoisted_127)
                  ])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(renderBuffer, (row, index) => {
                    return openBlock(), createElementBlock("tr", mergeProps({
                      key: `table-row_${uniqueKey(row, index)}`,
                      class: ["va-data-table__table-tr", [{ selected: _ctx.isRowSelected(row) }]]
                    }, _ctx.getRowBind(row), {
                      onClick: ($event) => _ctx.onRowClickHandler("row:click", $event, row),
                      onDblclick: ($event) => _ctx.onRowClickHandler("row:dblclick", $event, row),
                      onContextmenu: ($event) => _ctx.onRowClickHandler("row:contextmenu", $event, row)
                    }), [
                      _ctx.selectable ? (openBlock(), createElementBlock("td", {
                        class: "va-data-table__table-td va-data-table__table-cell-select",
                        key: `selectable_${uniqueKey(row, index)}`,
                        onSelectstart: _cache[1] || (_cache[1] = withModifiers(() => {
                        }, ["prevent"]))
                      }, [
                        createVNode(_component_va_checkbox, {
                          class: "va-data-table__table-cell-checkbox",
                          "model-value": _ctx.isRowSelected(row),
                          color: _ctx.selectedColor,
                          "aria-label": _ctx.t(`selectRowByIndex`, { index: row.initialIndex }),
                          onClick: [
                            withModifiers(($event) => _ctx.shiftSelectRows(row), ["shift", "exact", "stop"]),
                            withModifiers(($event) => _ctx.ctrlSelectRow(row), ["ctrl", "exact", "stop"]),
                            withModifiers(($event) => _ctx.ctrlSelectRow(row), ["exact", "stop"])
                          ]
                        }, null, 8, ["model-value", "color", "aria-label", "onClick"])
                      ], 32)) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell) => {
                        return openBlock(), createElementBlock("td", mergeProps({
                          key: `table-cell_${cell.column.name + cell.rowIndex}`,
                          class: ["va-data-table__table-td", _ctx.getClass(cell.column.tdClass)],
                          style: [_ctx.getCellCSSVariables(cell), _ctx.getStyle(cell.column.tdStyle)]
                        }, _ctx.getCellBind(cell, row)), [
                          `cell(${cell.column.name})` in _ctx.$slots ? renderSlot(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps(mergeProps({ key: 0 }, cell))) : renderSlot(_ctx.$slots, "cell", normalizeProps(mergeProps({ key: 1 }, cell)), () => [
                            createTextVNode(toDisplayString(cell.value), 1)
                          ])
                        ], 16);
                      }), 128))
                    ], 16, _hoisted_132);
                  }), 128))
                ]),
                _: 2
              }, 1032, ["name", "css", "appear"]),
              renderSlot(_ctx.$slots, "bodyAppend")
            ], 512),
            _ctx.footerClone ? (openBlock(), createElementBlock("tfoot", {
              key: 1,
              class: normalizeClass(["va-data-table__table-tfoot", { "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter }]),
              style: normalizeStyle({ bottom: _ctx.$props.virtualScroller && _ctx.$props.stickyFooter ? `${currentListOffset}px` : void 0 })
            }, [
              renderSlot(_ctx.$slots, "footerPrepend"),
              !_ctx.hideDefaultHeader ? (openBlock(), createElementBlock("tr", _hoisted_142, [
                _ctx.selectable ? (openBlock(), createElementBlock("th", _hoisted_152, [
                  _ctx.selectMode === "multiple" ? (openBlock(), createBlock(_component_va_checkbox, {
                    key: 0,
                    class: "va-data-table__table-cell-checkbox",
                    "aria-label": _ctx.t("selectAllRows"),
                    "model-value": _ctx.severalRowsSelected ? "idl" : _ctx.allRowsSelected,
                    "true-value": true,
                    "false-value": false,
                    color: _ctx.selectedColor,
                    "indeterminate-value": "idl",
                    indeterminate: "",
                    "onUpdate:modelValue": _ctx.toggleBulkSelection
                  }, null, 8, ["aria-label", "model-value", "color", "onUpdate:modelValue"])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsComputed, (column) => {
                  return openBlock(), createElementBlock("th", {
                    key: column.name,
                    title: column.thTitle,
                    "aria-label": _ctx.allowFooterSorting && column.sortable ? _ctx.t(`sortColumnBy`, { name: column.label }) : void 0,
                    class: normalizeClass(["va-data-table__table-th", _ctx.getClass(column.thClass)]),
                    style: normalizeStyle([_ctx.getFooterCSSVariables(column), _ctx.getStyle(column.thStyle)]),
                    onClick: withModifiers(($event) => _ctx.allowFooterSorting && column.sortable && _ctx.toggleSorting(column), ["exact"]),
                    onKeydown: withKeys(withModifiers(($event) => _ctx.allowFooterSorting && column.sortable && _ctx.toggleSorting(column), ["stop"]), ["enter"])
                  }, [
                    createBaseVNode("div", _hoisted_172, [
                      `footer(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_182, [
                        renderSlot(_ctx.$slots, `footer(${column.name})`, normalizeProps(guardReactiveProps({ label: column.label, key: column.key })))
                      ])) : renderSlot(_ctx.$slots, "footer", normalizeProps(mergeProps({ key: 1 }, column)), () => [
                        createBaseVNode("span", null, toDisplayString(column.label), 1)
                      ]),
                      _ctx.allowFooterSorting && column.sortable ? (openBlock(), createElementBlock("div", {
                        key: 2,
                        class: "va-data-table__table-th-sorting",
                        onSelectstart: _cache[2] || (_cache[2] = withModifiers(() => {
                        }, ["prevent"]))
                      }, [
                        createVNode(_component_va_icon, {
                          role: _ctx.allowFooterSorting && column.sortable ? "button" : void 0,
                          tabindex: _ctx.allowFooterSorting && column.sortable ? 0 : -1,
                          name: _ctx.sortingOrderIconName,
                          size: "small",
                          class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: _ctx.sortBySync === column.name && _ctx.sortingOrderSync !== null }])
                        }, null, 8, ["role", "tabindex", "name", "class"])
                      ], 32)) : createCommentVNode("", true)
                    ])
                  ], 46, _hoisted_162);
                }), 128))
              ])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "footerAppend")
            ], 6)) : createCommentVNode("", true)
          ], 16),
          _ctx.doRenderBottomTrigger ? (openBlock(), createElementBlock("div", _hoisted_192, null, 512)) : createCommentVNode("", true)
        ]),
        _: 2
      }, 1032, ["style", "loading", "color"])
    ]),
    _: 3
  }, 16);
}
var _VaDataTable = _export_sfc(_sfc_main42, [["render", _sfc_render41]]);

// node_modules/vuestic-ui/dist/es/src/components/va-data-table/index.js
var VaDataTable = withConfigTransport(_VaDataTable);

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/VaDateInput.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useParsable.js
init_vue_runtime_esm_bundler();
var useParsable = (parsable, parse2, format) => {
  const text = computed({
    get() {
      const value2 = parsable.value;
      if (typeof value2 === "string") {
        return value2;
      }
      return format(value2);
    },
    set(v2) {
      if (typeof parsable.value === "string") {
        parsable.value = v2;
      } else {
        parsable.value = parse2(v2);
      }
    }
  });
  const value = computed({
    get() {
      if (typeof parsable.value === "string") {
        return parse2(parsable.value);
      }
      return parsable.value;
    },
    set(v2) {
      if (typeof parsable.value === "string") {
        parsable.value = format(v2);
      } else {
        parsable.value = v2;
      }
    }
  });
  return {
    text,
    value
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/sync-prop.js
init_vue_runtime_esm_bundler();
function useSyncProp2(propRef, propName, emit, defaultValue) {
  if (defaultValue === void 0) {
    return {
      syncProp: computed({
        set(value) {
          emit(`update:${propName}`, value);
        },
        get() {
          return propRef.value;
        }
      })
    };
  }
  const statefulValue = ref(defaultValue);
  return {
    syncProp: computed({
      set(value) {
        statefulValue.value = value;
        emit(`update:${propName}`, value);
      },
      get() {
        return (propRef == null ? void 0 : propRef.value) === void 0 ? statefulValue.value : propRef.value;
      }
    })
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/range-model-value-guard.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/input-text-parser.js
init_vue_runtime_esm_bundler();
var defaultParseDateFunction = (text) => new Date(Date.parse(text));
var isValidDate = (d2) => isDate_1(d2) && !isNaN(d2.getTime());
var useDateParser = (props) => {
  const isMultipleDates = (text) => text.includes(props.delimiter);
  const isRange3 = (text) => text.includes(props.rangeDelimiter);
  const isValid = ref(true);
  const parseDate = (text) => {
    const splitDate = text.split(".");
    const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join("-") : text;
    const date = (props.parseDate || defaultParseDateFunction)(valueToParse);
    isValid.value = isValidDate(date);
    return date;
  };
  const parseDateInputValue = (text) => {
    isValid.value = true;
    if (props.parse) {
      return props.parse(text, isValid);
    }
    if (isMultipleDates(text)) {
      return text.split(props.delimiter).map(parseDate);
    }
    if (isRange3(text)) {
      const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
      return { start, end };
    }
    return parseDate(text);
  };
  return {
    parseDateInputValue,
    isValid
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/model-value-parser.js
var isRange = (date) => {
  return typeof date === "object" && ("start" in date || "end" in date);
};
var parseSingleDate = (date) => typeof date === "string" ? defaultParseDateFunction(date) : new Date(date);
var parseModelValue = (date) => {
  if (Array.isArray(date)) {
    return date.map(parseSingleDate);
  }
  if (isRange(date)) {
    return {
      start: isNil_1(date.start) ? date.start : parseSingleDate(date.start),
      end: isNil_1(date.end) ? date.end : parseSingleDate(date.end)
    };
  }
  return parseSingleDate(date);
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/hooks/range-model-value-guard.js
var useRangeModelValueGuard = (modelValue, disabled, parseValue = parseModelValue) => {
  const bufferValue = ref(modelValue.value && parseValue(modelValue.value));
  const valueComputed = computed({
    get: () => bufferValue.value,
    set: (value) => {
      if (disabled.value) {
        modelValue.value = value;
      }
      if (!value) {
        modelValue.value = value;
        return;
      }
      if (isRange(value)) {
        if (value.end !== null) {
          modelValue.value = value;
        }
      } else {
        modelValue.value = value;
      }
      bufferValue.value = value;
    }
  });
  watch(modelValue, (newValue) => {
    bufferValue.value = newValue;
  });
  const reset = () => {
    if (bufferValue.value && isRange(bufferValue.value)) {
      bufferValue.value = modelValue.value && parseValue(modelValue.value);
    }
  };
  return {
    valueComputed,
    reset
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/utils/date-utils.js
var isDatesDayEqual = (date1, date2) => (date1 == null ? void 0 : date1.toDateString()) === (date2 == null ? void 0 : date2.toDateString());
var isDatesYearEqual = (date1, date2) => {
  return (date1 == null ? void 0 : date1.getFullYear()) === (date2 == null ? void 0 : date2.getFullYear());
};
var isDatesMonthEqual = (date1, date2) => {
  return isDatesYearEqual(date1, date2) && (date1 == null ? void 0 : date1.getMonth()) === (date2 == null ? void 0 : date2.getMonth());
};
var createYearDate = (year) => {
  const date = new Date();
  date.setFullYear(year);
  return date;
};
var isRange2 = (value) => {
  return typeof value === "object" && ("start" in value || "end" in value);
};
var isSingleDate = (value) => isDate_1(value);
var isDates = (value) => Array.isArray(value);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/VaDatePicker.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/view.js
init_vue_runtime_esm_bundler();
var __defProp57 = Object.defineProperty;
var __defProps47 = Object.defineProperties;
var __getOwnPropDescs47 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols57 = Object.getOwnPropertySymbols;
var __hasOwnProp57 = Object.prototype.hasOwnProperty;
var __propIsEnum57 = Object.prototype.propertyIsEnumerable;
var __defNormalProp57 = (obj, key, value) => key in obj ? __defProp57(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues57 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp57.call(b2, prop))
      __defNormalProp57(a2, prop, b2[prop]);
  if (__getOwnPropSymbols57)
    for (var prop of __getOwnPropSymbols57(b2)) {
      if (__propIsEnum57.call(b2, prop))
        __defNormalProp57(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps47 = (a2, b2) => __defProps47(a2, __getOwnPropDescs47(b2));
var JANUARY_MONTH_INDEX = 0;
var DECEMBER_MONTH_INDEX = 11;
var addMonth = (view) => {
  if (view.month === DECEMBER_MONTH_INDEX) {
    return __spreadProps47(__spreadValues57({}, view), { year: view.year + 1, month: JANUARY_MONTH_INDEX });
  } else {
    return __spreadProps47(__spreadValues57({}, view), { month: view.month + 1 });
  }
};
var subMonth = (view) => {
  if (view.month === JANUARY_MONTH_INDEX) {
    return __spreadProps47(__spreadValues57({}, view), { year: view.year - 1, month: DECEMBER_MONTH_INDEX });
  } else {
    return __spreadProps47(__spreadValues57({}, view), { month: view.month - 1 });
  }
};
var getDefaultDate = (modelValue) => {
  if (isDate_1(modelValue)) {
    return modelValue;
  }
  if (isDate_1(modelValue == null ? void 0 : modelValue.start)) {
    return modelValue.start;
  }
  if (Array.isArray(modelValue) && isDate_1(modelValue[0])) {
    return modelValue[0];
  }
  return new Date();
};
var useView = (props, emit, defaultOverride) => {
  const defaultDate = getDefaultDate(props.modelValue);
  const defaultView = __spreadValues57({
    type: "day",
    year: defaultDate.getFullYear(),
    month: defaultDate.getMonth()
  }, defaultOverride);
  const statefulView = ref(defaultView);
  const syncView = computed({
    get() {
      return __spreadValues57(__spreadValues57({}, statefulView.value), props.view);
    },
    set(view) {
      statefulView.value = view;
      emit("update:view", view);
    }
  });
  const next = () => {
    if (syncView.value.type === "day") {
      syncView.value = addMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = __spreadProps47(__spreadValues57({}, syncView.value), { year: syncView.value.year + 1 });
    }
  };
  const prev = () => {
    if (syncView.value.type === "day") {
      syncView.value = subMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = __spreadProps47(__spreadValues57({}, syncView.value), { year: syncView.value.year - 1 });
    }
  };
  return {
    syncView,
    next,
    prev
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/grid-keyboard-navigation.js
init_vue_runtime_esm_bundler();
function isUndefined(t2) {
  return t2 === void 0;
}
var useGridKeyboardNavigation = ({
  rowSize,
  start,
  end,
  onSelected,
  onFocusIndex
}) => {
  const focusedCellIndex = ref(-1);
  let previouslyClicked = false;
  const onMousedown = () => {
    previouslyClicked = true;
  };
  const onFocus = () => {
    if (previouslyClicked) {
      return;
    }
    previouslyClicked = false;
    const index = onFocusIndex === void 0 ? unref(start) || 0 : unref(onFocusIndex);
    focusedCellIndex.value = index;
  };
  const onBlur = () => {
    previouslyClicked = false;
    focusedCellIndex.value = -1;
  };
  const onKeydown = (e2) => {
    if (["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp", "Enter", "Space"].includes(e2.key)) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    if (e2.key === "Enter" || e2.key === "Space") {
      if (onSelected === void 0) {
        return;
      }
      onSelected(focusedCellIndex.value);
      return;
    }
    if (e2.key === "ArrowRight") {
      focusedCellIndex.value += 1;
    }
    if (e2.key === "ArrowLeft") {
      focusedCellIndex.value -= 1;
    }
    if (e2.key === "ArrowDown") {
      focusedCellIndex.value += rowSize;
    }
    if (e2.key === "ArrowUp") {
      focusedCellIndex.value -= rowSize;
    }
    if (!isUndefined(start) && focusedCellIndex.value < unref(start)) {
      focusedCellIndex.value = unref(start);
    }
    if (!isUndefined(end) && focusedCellIndex.value > unref(end) - 1) {
      focusedCellIndex.value = unref(end) - 1;
    }
  };
  const containerAttributes = {
    onFocus,
    onKeydown,
    onBlur,
    onMousedown,
    tabindex: 0
  };
  return {
    focusedCellIndex,
    containerAttributes
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/use-picker.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/model-value-helper.js
var modeInitialValue = (date, mode) => {
  if (mode === "single") {
    return date;
  } else if (mode === "range") {
    return { start: date, end: null };
  } else if (mode === "multiple") {
    return [date];
  } else if (mode === "auto") {
    return date;
  }
  throw new Error("Unknown mode");
};
var throwIncorrectModelValueError = (modelValue, mode) => {
  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
var modeFromModelValue = (modelValue) => {
  if (isSingleDate(modelValue)) {
    return "single";
  } else if (isRange2(modelValue)) {
    return "range";
  } else if (isDates(modelValue)) {
    return "multiple";
  }
  return throwIncorrectModelValueError(modelValue, "auto");
};
var sortRange = (modelValue) => {
  if (modelValue.start && modelValue.end) {
    if (modelValue.start > modelValue.end) {
      return { start: modelValue.end, end: modelValue.start };
    }
  }
  return modelValue;
};
var useDatePickerModelValue = (props, emit, dateEqual) => {
  const updateModelValue = (date) => {
    if (!props.modelValue) {
      emit("update:modelValue", modeInitialValue(date, props.mode));
      return;
    }
    const mode = props.mode === "auto" ? modeFromModelValue(props.modelValue) : props.mode;
    if (mode === "single") {
      if (!isSingleDate(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      emit("update:modelValue", date);
    } else if (mode === "range") {
      if (!isRange2(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {
        return emit("update:modelValue", { start: props.modelValue.start, end: null });
      }
      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {
        return emit("update:modelValue", { start: null, end: props.modelValue.end });
      }
      if (props.modelValue.end === null) {
        return emit("update:modelValue", sortRange({ start: props.modelValue.start, end: date }));
      }
      if (props.modelValue.start === null) {
        return emit("update:modelValue", sortRange({ end: props.modelValue.end, start: date }));
      }
      emit("update:modelValue", { start: date, end: null });
    } else if (mode === "multiple") {
      if (!isDates(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      const isDatesIncludesDate = !!props.modelValue.find((d2) => dateEqual(d2, date));
      if (isDatesIncludesDate) {
        emit("update:modelValue", props.modelValue.filter((d2) => !dateEqual(d2, date)));
      } else {
        emit("update:modelValue", [...props.modelValue, date].sort((a2, b2) => a2.getTime() - b2.getTime()));
      }
    }
  };
  return {
    updateModelValue
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/hooks/use-picker.js
var getDateEqualFunction = (type) => {
  return {
    month: isDatesMonthEqual,
    day: isDatesDayEqual,
    year: isDatesYearEqual
  }[type];
};
var useDatePicker = (type, dates, props, emit) => {
  const datesEqual = getDateEqualFunction(type);
  const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
  const isDateDisabled = (date) => isAllowedDate === void 0 ? false : !isAllowedDate(date);
  const hoveredIndex = ref(-1);
  const hoveredValue = computed(() => dates.value[hoveredIndex.value]);
  const { updateModelValue } = useDatePickerModelValue(props, emit, datesEqual);
  const onClick = (date) => {
    if (props.readonly || isDateDisabled(date)) {
      return;
    }
    updateModelValue(date);
    emit(`click:${type}`, date);
  };
  const isToday = (date) => {
    const today = new Date();
    return datesEqual(today, date);
  };
  const isSelected = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (isSingleDate(props.modelValue)) {
      return datesEqual(props.modelValue, date);
    } else if (isDates(props.modelValue)) {
      return !!props.modelValue.find((d2) => datesEqual(d2, date));
    } else if (isRange2(props.modelValue)) {
      return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
    }
    return false;
  };
  const isInRange = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (!isRange2(props.modelValue)) {
      return false;
    }
    if (props.modelValue.start && props.modelValue.end) {
      return props.modelValue.start < date && props.modelValue.end > date;
    }
    const selectedDate = props.modelValue.start || props.modelValue.end;
    if (selectedDate) {
      if (!hoveredValue.value) {
        return false;
      }
      return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
    }
    return false;
  };
  watch(hoveredValue, (date) => {
    emit(`hover:${type}`, date);
  });
  return {
    hoveredIndex,
    hoveredValue,
    onClick,
    isToday,
    isSelected,
    isInRange
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/va-date-picker-calendar-hook.js
init_vue_runtime_esm_bundler();
var getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
var getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
var getNumbersArray = (length) => Array.from(Array(length).keys()).map((k2) => k2 + 1);
var useVaDatePickerCalendar = (view, options) => {
  const CALENDAR_ROWS_COUNT = 6;
  const localizeWeekday = (weekdayNumber) => {
    var _a;
    if (options && ((_a = options.firstWeekday) == null ? void 0 : _a.value) === "Monday") {
      return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
    }
    return weekdayNumber;
  };
  const currentMonthStartWeekday = computed(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
  const getPreviousDates = () => {
    if (currentMonthStartWeekday.value === 0) {
      return [];
    }
    const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
    const prevMonthDays = getNumbersArray(prevMonthDaysCount);
    return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d2) => new Date(view.value.year, view.value.month - 1, d2));
  };
  const getCurrentDates = () => {
    const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
    return currentMonthDays.map((d2) => new Date(view.value.year, view.value.month, d2));
  };
  const prevAndCurrentDays = computed(() => [...getPreviousDates(), ...getCurrentDates()]);
  const currentMonthEndIndex = computed(() => prevAndCurrentDays.value.length);
  const calendarDates = computed(() => {
    const days = prevAndCurrentDays.value;
    const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
    const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
    const nextMonthDays = getNumbersArray(nextMonthDaysCount);
    return [
      ...days,
      ...nextMonthDays.slice(0, daysRemaining).map((d2) => new Date(view.value.year, view.value.month + 1, d2))
    ];
  });
  return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerCell.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerCell.css";
var _sfc_main43 = defineComponent({
  name: "VaDatePickerCell",
  props: {
    otherMonth: { type: Boolean, default: false },
    today: { type: Boolean, default: false },
    inRange: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    selected: { type: Boolean, default: false },
    weekend: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const onClick = () => {
      if (!props.disabled) {
        emit("click");
      }
    };
    const { textColorComputed } = useTextColor(toRef(props, "color"));
    const computedStyle = computed(() => {
      if (props.selected) {
        return { color: textColorComputed.value };
      }
      return {};
    });
    return {
      onClick,
      computedStyle
    };
  }
});
var _hoisted_128 = {
  key: 0,
  class: "va-date-picker-cell va-date-picker-cell_clear"
};
function _sfc_render42(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.hidden ? (openBlock(), createElementBlock("div", _hoisted_128)) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(["va-date-picker-cell", {
      "va-date-picker-cell_other-month": _ctx.otherMonth,
      "va-date-picker-cell_today": _ctx.highlightToday && _ctx.today,
      "va-date-picker-cell_in-range": _ctx.inRange,
      "va-date-picker-cell_disabled": _ctx.disabled,
      "va-date-picker-cell_highlighted-weekend": _ctx.highlightWeekend && _ctx.weekend,
      "va-date-picker-cell_selected": _ctx.selected,
      "va-date-picker-cell_focused": _ctx.focused,
      "va-date-picker-cell_readonly": _ctx.readonly
    }]),
    style: normalizeStyle(_ctx.computedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
    onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.onClick && _ctx.onClick(...args), ["prevent", "stop"]), ["space", "enter"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 38));
}
var VaDatePickerCell = _export_sfc(_sfc_main43, [["render", _sfc_render42]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDayPicker/VaDayPicker.css";
var _sfc_main44 = defineComponent({
  name: "VaDayPicker",
  components: { VaDatePickerCell },
  props: {
    monthNames: { type: Array, required: true },
    weekdayNames: { type: Array, required: true },
    firstWeekday: { type: String, default: "Sunday" },
    hideWeekDays: { type: Boolean, default: false },
    view: { type: Object, default: () => ({ type: "day" }) },
    modelValue: { type: [Date, Array, Object] },
    mode: { type: String, default: "auto" },
    showOtherMonths: { type: Boolean, default: false },
    allowedDays: { type: Function },
    weekends: { type: Function },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:day", "click:day"],
  setup(props, { emit }) {
    const { firstWeekday, weekdayNames, view } = toRefs(props);
    const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
    const weekdayNamesComputed = computed(() => {
      return firstWeekday.value === "Sunday" ? weekdayNames.value : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("day", calendarDates, props, emit);
    const gridStartIndex = computed(() => props.showOtherMonths ? 0 : currentMonthStartIndex.value);
    const gridEndIndex = computed(() => props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 7,
      start: gridStartIndex,
      end: gridEndIndex,
      onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    const isOtherMonth = (date) => props.view.month !== date.getMonth();
    const isDateDisabled = (date) => props.allowedDays === void 0 ? false : !props.allowedDays(date);
    const isDateWeekend = (date) => {
      if (props.weekends === void 0) {
        return date.getDay() === 6 || date.getDay() === 0;
      }
      return props.weekends(date);
    };
    return {
      hoveredIndex,
      calendarDates,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isOtherMonth,
      isDateDisabled,
      isDateWeekend,
      containerAttributes,
      weekdayNamesComputed,
      focusedCellIndex
    };
  }
});
var _hoisted_129 = ["onMouseenter"];
var _hoisted_216 = { class: "va-date-picker-cell__day" };
function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-day-picker" }, _ctx.containerAttributes), [
    !_ctx.hideWeekDays ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.weekdayNamesComputed, (weekday) => {
      return openBlock(), createElementBlock("div", {
        key: weekday,
        class: "va-day-picker__weekday"
      }, [
        renderSlot(_ctx.$slots, "weekday", {}, () => [
          createTextVNode(toDisplayString(weekday), 1)
        ])
      ]);
    }), 128)) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.calendarDates, (date, index) => {
      return openBlock(), createElementBlock("div", {
        class: "va-day-picker__calendar__day-wrapper",
        key: index,
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          hidden: _ctx.isOtherMonth(date) && !_ctx.showOtherMonths,
          today: _ctx.isToday(date),
          selected: _ctx.isSelected(date),
          "in-range": _ctx.isInRange(date),
          "other-month": _ctx.isOtherMonth(date),
          weekend: _ctx.isDateWeekend(date),
          disabled: _ctx.isDateDisabled(date),
          focused: _ctx.hoveredIndex === index,
          "highlight-today": _ctx.highlightToday,
          "highlight-weekend": _ctx.highlightWeekend,
          readonly: _ctx.$props.readonly,
          color: _ctx.color,
          onClick: ($event) => {
            _ctx.onClick(date);
            _ctx.focusedCellIndex = index;
          }
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_216, [
              renderSlot(_ctx.$slots, "day", normalizeProps(guardReactiveProps({ date })), () => [
                createTextVNode(toDisplayString(date.getDate()), 1)
              ])
            ])
          ]),
          _: 2
        }, 1032, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "color", "onClick"])
      ], 40, _hoisted_129);
    }), 128))
  ], 16);
}
var VaDayPicker = _export_sfc(_sfc_main44, [["render", _sfc_render43]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaDatePickerHeader/VaDatePickerHeader.css";
var __defProp58 = Object.defineProperty;
var __defProps48 = Object.defineProperties;
var __getOwnPropDescs48 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols58 = Object.getOwnPropertySymbols;
var __hasOwnProp58 = Object.prototype.hasOwnProperty;
var __propIsEnum58 = Object.prototype.propertyIsEnumerable;
var __defNormalProp58 = (obj, key, value) => key in obj ? __defProp58(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues58 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp58.call(b2, prop))
      __defNormalProp58(a2, prop, b2[prop]);
  if (__getOwnPropSymbols58)
    for (var prop of __getOwnPropSymbols58(b2)) {
      if (__propIsEnum58.call(b2, prop))
        __defNormalProp58(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps48 = (a2, b2) => __defProps48(a2, __getOwnPropDescs48(b2));
var _sfc_main45 = defineComponent({
  name: "VaDatePickerHeader",
  components: { VaButton: VaButton2 },
  emits: ["update:view"],
  props: {
    monthNames: { type: Array, required: true },
    view: { type: Object },
    color: { type: String },
    textColor: { type: String },
    disabled: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const { syncView, prev, next } = useView(props, emit);
    const switchView = () => {
      if (syncView.value.type === "day") {
        syncView.value = __spreadProps48(__spreadValues58({}, syncView.value), { type: "month" });
      } else if (syncView.value.type === "month") {
        syncView.value = __spreadProps48(__spreadValues58({}, syncView.value), { type: "year" });
      }
    };
    const changeView = (view) => {
      syncView.value = view;
    };
    return __spreadProps48(__spreadValues58({}, useTranslation()), {
      prev,
      next,
      changeView,
      switchView,
      syncView
    });
  }
});
var _hoisted_130 = { class: "va-date-picker__header__text" };
var _hoisted_217 = { class: "ml-1" };
function _sfc_render44(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.syncView.type !== "year" ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "va-date-picker-header va-date-picker__header",
    style: normalizeStyle({ color: _ctx.textColor })
  }, [
    renderSlot(_ctx.$slots, "buttonPrev", normalizeProps(guardReactiveProps({ onClick: _ctx.prev })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "va-arrow-left",
        preset: "plain",
        size: "small",
        color: _ctx.color,
        textColor: _ctx.textColor,
        "aria-label": _ctx.t("nextPeriod"),
        round: "",
        onClick: _ctx.prev
      }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
    ]),
    createBaseVNode("div", _hoisted_130, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year, month: _ctx.syncView.month, monthNames: _ctx.monthNames, view: _ctx.syncView, changeView: _ctx.changeView, switchView: _ctx.switchView })), () => [
        createVNode(_component_va_button, {
          disabled: _ctx.$props.disabled,
          preset: "plain",
          size: "small",
          color: _ctx.color,
          textColor: _ctx.textColor,
          "aria-label": _ctx.t("switchView"),
          onClick: _ctx.switchView
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "year", normalizeProps(guardReactiveProps({ year: _ctx.syncView.year })), () => [
              createTextVNode(toDisplayString(_ctx.syncView.year), 1)
            ]),
            _ctx.syncView.type === "day" ? renderSlot(_ctx.$slots, "month", normalizeProps(mergeProps({ key: 0 }, { month: _ctx.syncView.month })), () => [
              createBaseVNode("span", _hoisted_217, toDisplayString(_ctx.monthNames[_ctx.syncView.month]), 1)
            ]) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
      ])
    ]),
    renderSlot(_ctx.$slots, "buttonNext", normalizeProps(guardReactiveProps({ onClick: _ctx.next })), () => [
      createVNode(_component_va_button, {
        disabled: _ctx.$props.disabled,
        icon: "va-arrow-right",
        preset: "plain",
        size: "small",
        color: _ctx.color,
        textColor: _ctx.textColor,
        "aria-label": _ctx.t("previousPeriod"),
        onClick: _ctx.next,
        round: ""
      }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
    ])
  ], 4)) : createCommentVNode("", true);
}
var VaDatePickerHeader = _export_sfc(_sfc_main45, [["render", _sfc_render44]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaMonthPicker/VaMonthPicker.css";
var _sfc_main46 = defineComponent({
  name: "VaMonthPicker",
  components: { VaDatePickerCell },
  props: {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, required: true },
    view: { type: Object, default: () => ({ type: "month" }) },
    allowedMonths: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    mode: { type: String, default: "auto" },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:month", "click:month"],
  setup(props, { emit }) {
    const { view } = toRefs(props);
    const months = computed(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("month", months, props, emit);
    const isDisabled = (date) => props.allowedMonths === void 0 ? false : !props.allowedMonths(date);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 3,
      start: 0,
      end: months.value.length,
      onSelected: (selectedIndex) => onClick(months.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      months,
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isDisabled,
      containerAttributes,
      focusedCellIndex
    };
  }
});
var _hoisted_131 = ["onMouseenter"];
function _sfc_render45(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({ class: "va-month-picker" }, _ctx.containerAttributes), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.months, (month, monthIndex) => {
      return openBlock(), createElementBlock("div", {
        key: monthIndex,
        class: "va-month-picker__month-wrapper",
        onMouseenter: ($event) => _ctx.hoveredIndex = monthIndex,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, [
        createVNode(_component_va_date_picker_cell, {
          "in-range": !!_ctx.isInRange(month),
          selected: !!_ctx.isSelected(month),
          disabled: !!_ctx.isDisabled(month),
          today: !!_ctx.isToday(month),
          focused: _ctx.hoveredIndex === monthIndex,
          "highlight-today": _ctx.highlightToday,
          readonly: _ctx.$props.readonly,
          color: _ctx.color,
          onClick: ($event) => {
            _ctx.onClick(month);
            _ctx.focusedCellIndex = monthIndex;
          }
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "month", normalizeProps(guardReactiveProps({ monthIndex, month: _ctx.monthNames[monthIndex] })), () => [
              createTextVNode(toDisplayString(_ctx.monthNames[monthIndex]), 1)
            ])
          ]),
          _: 2
        }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick"])
      ], 40, _hoisted_131);
    }), 128))
  ], 16);
}
var VaMonthPicker = _export_sfc(_sfc_main46, [["render", _sfc_render45]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-date-picker/components/VaYearPicker/VaYearPicker.css";
var _sfc_main47 = defineComponent({
  name: "VaYearPicker",
  components: { VaDatePickerCell },
  props: {
    modelValue: { type: [Date, Array, Object] },
    allowedYears: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    startYear: { type: Number, default: 1970 },
    mode: { type: String, default: "auto" },
    view: { type: Object, default: () => ({ type: "year" }) },
    endYear: { type: Number, default: () => new Date().getFullYear() + 50 },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:year", "click:year"],
  setup(props, { emit }) {
    const rootNode = shallowRef();
    const { view } = toRefs(props);
    const generateYearsArray = (start, end) => {
      const yearsCount = end - start + 1;
      return Array.from(Array(yearsCount).keys()).map((i2) => createYearDate(start + i2));
    };
    const years = computed(() => generateYearsArray(props.startYear, props.endYear));
    const scrollIntoYearIndex = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      const cellSize = scrollHeight / years.value.length;
      const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
      if (relativeScrollPosition < 0) {
        rootNode.value.scrollTo({ top: currentYearOffset });
      } else if (relativeScrollPosition > rootNodeHeight) {
        rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
      }
    };
    const scrollIntoYearIndexCenter = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
    };
    onMounted(() => {
      const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
      scrollIntoYearIndexCenter(currentYearIndex);
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("year", years, props, emit);
    const isYearDisabled = (year) => props.allowedYears === void 0 ? false : !props.allowedYears(year);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 1,
      start: 0,
      end: years.value.length,
      onFocusIndex: computed(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
      onSelected: (selectedIndex) => onClick(years.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return {
      hoveredIndex,
      years,
      rootNode,
      onClick,
      isToday,
      isSelected,
      isInRange,
      isYearDisabled,
      focusedCellIndex,
      containerAttributes
    };
  }
});
function _sfc_render46(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_cell = resolveComponent("va-date-picker-cell");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "rootNode",
    class: "va-year-picker"
  }, _ctx.containerAttributes, {
    onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
    }, ["prevent"]), ["space"]))
  }), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.years, (year, index) => {
      return openBlock(), createBlock(_component_va_date_picker_cell, {
        key: year.toString(),
        "in-range": _ctx.isInRange(year),
        selected: _ctx.isSelected(year),
        disabled: _ctx.isYearDisabled(year),
        today: _ctx.isToday(year),
        focused: _ctx.focusedCellIndex === index,
        "highlight-today": _ctx.highlightToday,
        readonly: _ctx.$props.readonly,
        color: _ctx.color,
        onClick: ($event) => {
          _ctx.onClick(year);
          _ctx.focusedCellIndex = index;
        },
        onMouseenter: ($event) => _ctx.hoveredIndex = index,
        onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hoveredIndex = -1)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(year.getFullYear()), 1)
        ]),
        _: 2
      }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick", "onMouseenter"]);
    }), 128))
  ], 16);
}
var VaYearPicker = _export_sfc(_sfc_main47, [["render", _sfc_render46]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/VaDatePicker.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-date-picker/VaDatePicker.css";
var __defProp59 = Object.defineProperty;
var __defProps49 = Object.defineProperties;
var __getOwnPropDescs49 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols59 = Object.getOwnPropertySymbols;
var __hasOwnProp59 = Object.prototype.hasOwnProperty;
var __propIsEnum59 = Object.prototype.propertyIsEnumerable;
var __defNormalProp59 = (obj, key, value) => key in obj ? __defProp59(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues59 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp59.call(b2, prop))
      __defNormalProp59(a2, prop, b2[prop]);
  if (__getOwnPropSymbols59)
    for (var prop of __getOwnPropSymbols59(b2)) {
      if (__propIsEnum59.call(b2, prop))
        __defNormalProp59(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps49 = (a2, b2) => __defProps49(a2, __getOwnPropDescs49(b2));
var DEFAULT_MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var DEFAULT_WEEKDAY_NAMES = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var _sfc_main48 = defineComponent({
  name: "VaDatePicker",
  components: { VaDayPicker, VaDatePickerHeader, VaMonthPicker, VaYearPicker },
  props: __spreadProps49(__spreadValues59(__spreadValues59(__spreadValues59(__spreadValues59(__spreadValues59(__spreadValues59({}, useStatefulProps), useComponentPresetProp), extractComponentProps(VaDatePickerHeader)), extractComponentProps(VaDayPicker)), extractComponentProps(VaMonthPicker)), extractComponentProps(VaYearPicker)), {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
    weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
    view: { type: Object },
    type: { type: String, default: "day" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: void 0 },
    weekendsColor: { type: String, default: void 0 }
  }),
  emits: [
    ...useStatefulEmits,
    ...extractComponentEmits(VaDatePickerHeader),
    ...extractComponentEmits(VaYearPicker),
    ...extractComponentEmits(VaDayPicker),
    ...extractComponentEmits(VaMonthPicker)
  ],
  setup(props, { emit }) {
    const currentPicker = ref();
    const { valueComputed } = useStateful(props, emit);
    const { syncView } = useView(props, emit, { type: props.type });
    const classComputed = computed(() => ({
      "va-date-picker_without-week-days": props.hideWeekDays,
      "va-date-picker_disabled": props.disabled
    }));
    const onDayModelValueUpdate = (modelValue) => {
      if (props.readonly) {
        return;
      }
      if (props.type === "day") {
        valueComputed.value = modelValue;
      }
    };
    const onMonthClick = (date) => {
      emit("click:month", date);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (props.type !== "month") {
        syncView.value = { type: "day", year, month };
      }
    };
    const onMonthModelValueUpdate = (modelValue) => {
      if (props.type === "month") {
        valueComputed.value = modelValue;
      }
    };
    const onYearClick = (date) => {
      emit("click:year", date);
      const year = date.getFullYear();
      if (props.type !== "year") {
        syncView.value = { type: "month", year, month: syncView.value.month };
      }
    };
    const onYearModelValueUpdate = (modelValue) => {
      if (props.type === "year") {
        valueComputed.value = modelValue;
      }
    };
    const { colorsToCSSVariable } = useColors();
    const { background } = useElementBackground();
    const { textColorComputed } = useTextColor(background);
    const styleComputed = computed(() => __spreadValues59({
      color: textColorComputed.value
    }, colorsToCSSVariable({
      color: props.color,
      "weekends-color": props.weekendsColor
    }, "va-date-picker")));
    const focusCurrentPicker = () => {
      var _a;
      return (_a = currentPicker.value) == null ? void 0 : _a.$el.focus();
    };
    watch(syncView, (newValue, prevValue) => {
      if (newValue.type === prevValue.type) {
        return;
      }
      nextTick(focusCurrentPicker);
    });
    const isPickerReadonly = (pickerName) => {
      return props.readonly && props.type === pickerName;
    };
    return {
      dayPickerProps: filterComponentProps(props, extractComponentProps(VaDayPicker)),
      headerProps: filterComponentProps(props, extractComponentProps(VaDatePickerHeader)),
      monthPickerProps: filterComponentProps(props, extractComponentProps(VaMonthPicker)),
      yearPickerProps: filterComponentProps(props, extractComponentProps(VaYearPicker)),
      syncView,
      classComputed,
      valueComputed,
      onDayModelValueUpdate,
      onMonthClick,
      onMonthModelValueUpdate,
      onYearClick,
      onYearModelValueUpdate,
      styleComputed,
      currentPicker,
      textColorComputed,
      focusCurrentPicker,
      isPickerReadonly
    };
  }
});
var _hoisted_133 = { class: "va-date-picker__picker-wrapper" };
function _sfc_render47(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_date_picker_header = resolveComponent("va-date-picker-header");
  const _component_va_day_picker = resolveComponent("va-day-picker");
  const _component_va_month_picker = resolveComponent("va-month-picker");
  const _component_va_year_picker = resolveComponent("va-year-picker");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-date-picker", _ctx.classComputed]),
    style: normalizeStyle(_ctx.styleComputed)
  }, [
    createVNode(_component_va_date_picker_header, mergeProps(_ctx.headerProps, {
      view: _ctx.syncView,
      "onUpdate:view": _cache[0] || (_cache[0] = ($event) => _ctx.syncView = $event),
      textColor: _ctx.textColorComputed
    }), createSlots({ _: 2 }, [
      renderList(_ctx.$slots, (_2, name) => {
        return {
          name,
          fn: withCtx((bind) => [
            renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
          ])
        };
      })
    ]), 1040, ["view", "textColor"]),
    createBaseVNode("div", _hoisted_133, [
      _ctx.syncView.type === "day" ? (openBlock(), createBlock(_component_va_day_picker, mergeProps({
        key: 0,
        ref: "currentPicker"
      }, _ctx.dayPickerProps, {
        "model-value": _ctx.valueComputed,
        view: _ctx.syncView,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("day"),
        "onUpdate:modelValue": _ctx.onDayModelValueUpdate,
        "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit("hover:day", value)),
        "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit("click:day", value))
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["model-value", "view", "readonly", "onUpdate:modelValue"])) : createCommentVNode("", true),
      _ctx.syncView.type === "month" ? (openBlock(), createBlock(_component_va_month_picker, mergeProps({
        key: 1,
        ref: "currentPicker"
      }, _ctx.monthPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("month"),
        "onUpdate:modelValue": _ctx.onMonthModelValueUpdate,
        "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit("hover:month", value)),
        "onClick:month": _ctx.onMonthClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:month"])) : createCommentVNode("", true),
      _ctx.syncView.type === "year" ? (openBlock(), createBlock(_component_va_year_picker, mergeProps({
        key: 2,
        ref: "currentPicker"
      }, _ctx.yearPickerProps, {
        view: _ctx.syncView,
        "model-value": _ctx.valueComputed,
        readonly: _ctx.$props.disabled || _ctx.isPickerReadonly("year"),
        "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit("hover:year", value)),
        "onUpdate:modelValue": _ctx.onYearModelValueUpdate,
        "onClick:year": _ctx.onYearClick
      }), createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((bind) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
            ])
          };
        })
      ]), 1040, ["view", "model-value", "readonly", "onUpdate:modelValue", "onClick:year"])) : createCommentVNode("", true)
    ])
  ], 6);
}
var _VaDatePicker = _export_sfc(_sfc_main48, [["render", _sfc_render47]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/VaDateInput.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-date-input/VaDateInput.css";
var __defProp60 = Object.defineProperty;
var __defProps50 = Object.defineProperties;
var __getOwnPropDescs50 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols60 = Object.getOwnPropertySymbols;
var __hasOwnProp60 = Object.prototype.hasOwnProperty;
var __propIsEnum60 = Object.prototype.propertyIsEnumerable;
var __defNormalProp60 = (obj, key, value) => key in obj ? __defProp60(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues60 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp60.call(b2, prop))
      __defNormalProp60(a2, prop, b2[prop]);
  if (__getOwnPropSymbols60)
    for (var prop of __getOwnPropSymbols60(b2)) {
      if (__propIsEnum60.call(b2, prop))
        __defNormalProp60(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps50 = (a2, b2) => __defProps50(a2, __getOwnPropDescs50(b2));
var VaInputWrapperProps = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue", "disabled"]);
var VaDatePickerProps = extractComponentProps(_VaDatePicker);
var VaDropdownProps2 = extractComponentProps(VaDropdown, ["innerAnchorSelector", "stateful", "offset", "keyboardNavigation", "closeOnContentClick", "modelValue"]);
var _sfc_main49 = defineComponent({
  name: "VaDateInput",
  components: {
    VaDropdown,
    VaDropdownContent,
    VaDatePicker: _VaDatePicker,
    VaInputWrapper,
    VaIcon: VaIcon2
  },
  props: __spreadProps50(__spreadValues60(__spreadValues60(__spreadValues60(__spreadValues60(__spreadValues60(__spreadValues60({}, VaDropdownProps2), useClearableProps), VaInputWrapperProps), VaDatePickerProps), useValidationProps), useComponentPresetProp), {
    clearValue: { type: Date, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    isOpen: { type: Boolean, default: void 0 },
    format: { type: Function },
    formatDate: { type: Function, default: (d2) => d2.toLocaleDateString() },
    parse: { type: Function },
    parseDate: { type: Function },
    parseValue: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" }
  }),
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_VaDatePicker),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    "update:is-open",
    "update:text"
  ],
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const datePicker = ref();
    const { isOpen, resetOnClose } = toRefs(props);
    const { valueComputed: statefulValue } = useStateful(props, emit);
    const { syncProp: isOpenSync } = useSyncProp2(isOpen, "is-open", emit, false);
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled, props.parseValue);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d2) => props.formatDate(d2)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange2(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      throw new Error("VaDatePicker: Invalid model value. Value should be Date, Date[] or { start: Date, end: Date | null }");
    };
    const {
      text,
      value: valueWithoutText
    } = useParsable(valueComputed, parseDateInputValue, modelValueToString);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      const parsedValue = parseDateInputValue(target.value);
      if (isValid.value) {
        valueComputed.value = parsedValue;
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props.clearValue;
      emit("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a;
        return (_a = datePicker.value) == null ? void 0 : _a.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e2) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e2 == null ? void 0 : e2.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const iconProps = computed(() => ({
      role: "button",
      ariaHidden: false,
      size: "small",
      name: props.icon,
      color: props.color,
      tabindex: iconTabindexComputed.value
    }));
    const computedInputWrapperProps = computed(() => __spreadProps50(__spreadValues60({}, filterComponentProps(props, VaInputWrapperProps).value), {
      focused: isFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { t: t2 } = useTranslation();
    const inputAttributesComputed = computed(() => __spreadValues60(__spreadValues60({
      readonly: props.readonly || !props.manualInput,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || t2("selectedDate"),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    const dropdownPropsComputed = computed(() => __spreadProps50(__spreadValues60({}, filterComponentProps(props, VaDropdownProps2).value), {
      offset: [2, 0],
      stateful: false,
      keyboardNavigation: true,
      closeOnContentClick: false,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    return {
      t: t2,
      datePicker,
      valueText,
      valueWithoutText,
      valueComputed,
      isOpenSync,
      onInputTextChanged,
      isFocused,
      input,
      inputWrapperProps: computedInputWrapperProps,
      inputListeners: computedInputListeners,
      inputAttributesComputed,
      datePickerProps: filterComponentProps(props, VaDatePickerProps),
      dropdownPropsComputed,
      filterSlots,
      canBeCleared,
      clearIconProps,
      iconProps,
      cursorStyleComputed,
      hideAndFocus,
      toggleDropdown,
      showDropdown,
      focusInputOrPicker,
      focusDatePicker,
      reset,
      focus,
      blur
    };
  }
});
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_date_picker = resolveComponent("va-date-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    modelValue: _ctx.isOpenSync,
    "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.isOpenSync = $event),
    class: ["va-date-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, _ctx.dropdownPropsComputed, {
    onOpen: _ctx.focusDatePicker,
    onClose: _ctx.focus
  }), {
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "input", normalizeProps(guardReactiveProps({ valueText: _ctx.valueText, inputAttributes: _ctx.inputAttributesComputed, inputWrapperProps: _ctx.inputWrapperProps, inputListeners: _ctx.inputListeners })), () => [
        createVNode(_component_va_input_wrapper, mergeProps({
          class: "va-date-input__anchor",
          style: _ctx.cursorStyleComputed
        }, _ctx.inputWrapperProps), createSlots({
          default: withCtx(() => [
            createBaseVNode("input", mergeProps({
              ref: "input",
              class: "va-date-input__input"
            }, _ctx.inputAttributesComputed, toHandlers(_ctx.inputListeners), {
              onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
            }), null, 16)
          ]),
          icon: withCtx(() => [
            _ctx.canBeCleared ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              "aria-label": _ctx.t("resetDate")
            }, __spreadValues60(__spreadValues60({}, _ctx.iconProps), _ctx.clearIconProps), {
              onClick: withModifiers(_ctx.reset, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
              ]
            }), null, 16, ["aria-label", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 1,
              "aria-label": _ctx.t("toggleDropdown")
            }, _ctx.iconProps), null, 16, ["aria-label"])) : createCommentVNode("", true)
          ]),
          _: 2
        }, [
          renderList(_ctx.filterSlots, (name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          }),
          _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
            name: "prependInner",
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(slotScope))),
              _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
                key: 0,
                "aria-label": _ctx.t("toggleDropdown")
              }, _ctx.iconProps), null, 16, ["aria-label"])) : createCommentVNode("", true)
            ])
          } : void 0
        ]), 1040, ["style"])
      ])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, { class: "va-date-input__dropdown-content" }, {
        default: withCtx(() => [
          createVNode(_component_va_date_picker, mergeProps({ ref: "datePicker" }, _ctx.datePickerProps, {
            modelValue: _ctx.valueWithoutText,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.valueWithoutText = $event),
            "onClick:day": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:day", $event)),
            "onClick:month": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:month", $event)),
            "onClick:year": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click:year", $event)),
            "onHover:day": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:day", $event)),
            "onHover:month": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:month", $event)),
            "onHover:year": _cache[7] || (_cache[7] = ($event) => _ctx.$emit("hover:year", $event)),
            "onUpdate:view": _cache[8] || (_cache[8] = ($event) => _ctx.$emit("update:view", $event))
          }), createSlots({ _: 2 }, [
            renderList(_ctx.$slots, (_2, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["modelValue"])
        ]),
        _: 3
      })
    ]),
    _: 3
  }, 16, ["modelValue", "class", "style", "onOpen", "onClose"]);
}
var _VaDateInput = _export_sfc(_sfc_main49, [["render", _sfc_render48]]);

// node_modules/vuestic-ui/dist/es/src/components/va-date-input/index.js
var VaDateInput = withConfigTransport(_VaDateInput);

// node_modules/vuestic-ui/dist/es/src/components/va-date-picker/index.js
var VaDatePicker = withConfigTransport(_VaDatePicker);

// node_modules/vuestic-ui/dist/es/src/components/va-divider/VaDivider.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-divider/VaDivider.css";
var __defProp61 = Object.defineProperty;
var __defProps51 = Object.defineProperties;
var __getOwnPropDescs51 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols61 = Object.getOwnPropertySymbols;
var __hasOwnProp61 = Object.prototype.hasOwnProperty;
var __propIsEnum61 = Object.prototype.propertyIsEnumerable;
var __defNormalProp61 = (obj, key, value) => key in obj ? __defProp61(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues61 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp61.call(b2, prop))
      __defNormalProp61(a2, prop, b2[prop]);
  if (__getOwnPropSymbols61)
    for (var prop of __getOwnPropSymbols61(b2)) {
      if (__propIsEnum61.call(b2, prop))
        __defNormalProp61(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps51 = (a2, b2) => __defProps51(a2, __getOwnPropDescs51(b2));
var prefixClass = "va-divider";
var _sfc_main50 = defineComponent({
  name: "VaDivider",
  props: __spreadProps51(__spreadValues61({}, useComponentPresetProp), {
    vertical: { type: Boolean, default: false },
    dashed: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    orientation: {
      type: String,
      default: "center",
      validator: (value) => ["left", "right", "center"].includes(value)
    }
  }),
  setup: (props, { slots }) => ({
    hasSlot: computed(() => !!slots.default),
    classComputed: computed(() => ({
      [`${prefixClass}--vertical`]: props.vertical,
      [`${prefixClass}--inset`]: props.inset,
      [`${prefixClass}--${props.orientation}`]: props.orientation && !props.vertical,
      [`${prefixClass}--dashed`]: props.dashed
    }))
  })
});
var _hoisted_134 = ["aria-orientation"];
var _hoisted_218 = {
  key: 0,
  class: "va-divider__text"
};
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    role: "separator",
    class: normalizeClass(["va-divider", _ctx.classComputed]),
    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal"
  }, [
    _ctx.hasSlot && !_ctx.vertical ? (openBlock(), createElementBlock("div", _hoisted_218, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true)
  ], 10, _hoisted_134);
}
var _VaDivider = _export_sfc(_sfc_main50, [["render", _sfc_render49]]);

// node_modules/vuestic-ui/dist/es/src/components/va-divider/index.js
var VaDivider = withConfigTransport(_VaDivider);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUpload.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/types.js
var VaFileUploadKey = Symbol("VaFileUpload");

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaList.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-list/VaList.css";
var __defProp62 = Object.defineProperty;
var __defProps52 = Object.defineProperties;
var __getOwnPropDescs52 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols62 = Object.getOwnPropertySymbols;
var __hasOwnProp62 = Object.prototype.hasOwnProperty;
var __propIsEnum62 = Object.prototype.propertyIsEnumerable;
var __defNormalProp62 = (obj, key, value) => key in obj ? __defProp62(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues62 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp62.call(b2, prop))
      __defNormalProp62(a2, prop, b2[prop]);
  if (__getOwnPropSymbols62)
    for (var prop of __getOwnPropSymbols62(b2)) {
      if (__propIsEnum62.call(b2, prop))
        __defNormalProp62(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps52 = (a2, b2) => __defProps52(a2, __getOwnPropDescs52(b2));
var _sfc_main51 = defineComponent({
  name: "VaList",
  props: __spreadProps52(__spreadValues62({}, useComponentPresetProp), {
    fit: { type: Boolean, default: false }
  }),
  setup: (props) => ({
    computedClass: computed(() => ({ "va-list--fit": props.fit }))
  })
});
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list", _ctx.computedClass]),
    role: "list"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaList = _export_sfc(_sfc_main51, [["render", _sfc_render50]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItem.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItem.css";
var __defProp63 = Object.defineProperty;
var __defProps53 = Object.defineProperties;
var __getOwnPropDescs53 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols63 = Object.getOwnPropertySymbols;
var __hasOwnProp63 = Object.prototype.hasOwnProperty;
var __propIsEnum63 = Object.prototype.propertyIsEnumerable;
var __defNormalProp63 = (obj, key, value) => key in obj ? __defProp63(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues63 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp63.call(b2, prop))
      __defNormalProp63(a2, prop, b2[prop]);
  if (__getOwnPropSymbols63)
    for (var prop of __getOwnPropSymbols63(b2)) {
      if (__propIsEnum63.call(b2, prop))
        __defNormalProp63(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps53 = (a2, b2) => __defProps53(a2, __getOwnPropDescs53(b2));
var _sfc_main52 = defineComponent({
  name: "VaListItem",
  emits: ["focus", "click"],
  props: __spreadProps53(__spreadValues63(__spreadValues63({}, useRouterLinkProps), useComponentPresetProp), {
    tag: { type: String, default: "div" },
    disabled: { type: Boolean, default: false }
  }),
  setup(props) {
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const computedClass = useBem("va-list-item", () => __spreadValues63({}, pick_1(props, ["disabled"])));
    return __spreadProps53(__spreadValues63({}, useRouterLink(props)), {
      tabIndexComputed,
      computedClass
    });
  }
});
function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    class: normalizeClass(["va-list-item", _ctx.computedClass]),
    role: "listitem",
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    tabindex: _ctx.tabIndexComputed
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: "va-list-item__inner",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus"))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 32)
    ]),
    _: 3
  }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "tabindex"]);
}
var _VaListItem = _export_sfc(_sfc_main52, [["render", _sfc_render51]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListLabel.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-list/VaListLabel.css";
var __defProp64 = Object.defineProperty;
var __defProps54 = Object.defineProperties;
var __getOwnPropDescs54 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols64 = Object.getOwnPropertySymbols;
var __hasOwnProp64 = Object.prototype.hasOwnProperty;
var __propIsEnum64 = Object.prototype.propertyIsEnumerable;
var __defNormalProp64 = (obj, key, value) => key in obj ? __defProp64(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues64 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp64.call(b2, prop))
      __defNormalProp64(a2, prop, b2[prop]);
  if (__getOwnPropSymbols64)
    for (var prop of __getOwnPropSymbols64(b2)) {
      if (__propIsEnum64.call(b2, prop))
        __defNormalProp64(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps54 = (a2, b2) => __defProps54(a2, __getOwnPropDescs54(b2));
var _sfc_main53 = defineComponent({
  name: "VaListLabel",
  props: __spreadProps54(__spreadValues64({}, useComponentPresetProp), {
    color: { type: String, default: "primary" }
  }),
  setup: (props) => {
    const { getColor } = useColors();
    return {
      computedStyle: computed(() => ({
        color: getColor(props.color)
      }))
    };
  }
});
function _sfc_render52(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "va-list-label",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
var _VaListLabel = _export_sfc(_sfc_main53, [["render", _sfc_render52]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemLabel.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemLabel.css";
var __defProp65 = Object.defineProperty;
var __defProps55 = Object.defineProperties;
var __getOwnPropDescs55 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols65 = Object.getOwnPropertySymbols;
var __hasOwnProp65 = Object.prototype.hasOwnProperty;
var __propIsEnum65 = Object.prototype.propertyIsEnumerable;
var __defNormalProp65 = (obj, key, value) => key in obj ? __defProp65(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues65 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp65.call(b2, prop))
      __defNormalProp65(a2, prop, b2[prop]);
  if (__getOwnPropSymbols65)
    for (var prop of __getOwnPropSymbols65(b2)) {
      if (__propIsEnum65.call(b2, prop))
        __defNormalProp65(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps55 = (a2, b2) => __defProps55(a2, __getOwnPropDescs55(b2));
var _sfc_main54 = defineComponent({
  name: "VaListItemLabel",
  props: __spreadProps55(__spreadValues65({}, useComponentPresetProp), {
    caption: { type: Boolean, default: false },
    lines: { type: Number, default: 1 }
  }),
  setup: (props) => ({
    computedClass: computed(() => ({ "va-list-item-label--caption": props.caption })),
    computedStyle: computed(() => ({ "-webkit-line-clamp": props.lines }))
  })
});
function _sfc_render53(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-label", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var _VaListItemLabel = _export_sfc(_sfc_main54, [["render", _sfc_render53]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemSection.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-list/VaListItemSection.css";
var __defProp66 = Object.defineProperty;
var __defProps56 = Object.defineProperties;
var __getOwnPropDescs56 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols66 = Object.getOwnPropertySymbols;
var __hasOwnProp66 = Object.prototype.hasOwnProperty;
var __propIsEnum66 = Object.prototype.propertyIsEnumerable;
var __defNormalProp66 = (obj, key, value) => key in obj ? __defProp66(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues66 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp66.call(b2, prop))
      __defNormalProp66(a2, prop, b2[prop]);
  if (__getOwnPropSymbols66)
    for (var prop of __getOwnPropSymbols66(b2)) {
      if (__propIsEnum66.call(b2, prop))
        __defNormalProp66(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps56 = (a2, b2) => __defProps56(a2, __getOwnPropDescs56(b2));
var _sfc_main55 = defineComponent({
  name: "VaListItemSection",
  props: __spreadProps56(__spreadValues66({}, useComponentPresetProp), {
    icon: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false }
  }),
  setup: (props) => ({
    computedClass: computed(() => ({
      "va-list-item-section--main": !props.icon && !props.avatar,
      "va-list-item-section--icon": props.icon,
      "va-list-item-section--avatar": props.avatar
    }))
  })
});
function _sfc_render54(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-list-item-section", _ctx.computedClass])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var _VaListItemSection = _export_sfc(_sfc_main55, [["render", _sfc_render54]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/VaListSeparator.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-list/VaListSeparator.css";
var __defProp67 = Object.defineProperty;
var __defProps57 = Object.defineProperties;
var __getOwnPropDescs57 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols67 = Object.getOwnPropertySymbols;
var __hasOwnProp67 = Object.prototype.hasOwnProperty;
var __propIsEnum67 = Object.prototype.propertyIsEnumerable;
var __defNormalProp67 = (obj, key, value) => key in obj ? __defProp67(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues67 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp67.call(b2, prop))
      __defNormalProp67(a2, prop, b2[prop]);
  if (__getOwnPropSymbols67)
    for (var prop of __getOwnPropSymbols67(b2)) {
      if (__propIsEnum67.call(b2, prop))
        __defNormalProp67(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps57 = (a2, b2) => __defProps57(a2, __getOwnPropDescs57(b2));
var _sfc_main56 = defineComponent({
  name: "VaListSeparator",
  props: __spreadProps57(__spreadValues67({}, useComponentPresetProp), {
    fit: { type: Boolean, default: false },
    spaced: { type: Boolean, default: false }
  }),
  setup: (props) => ({
    computedClass: computed(() => ({
      "va-list-separator--offset": !props.fit,
      "va-list-separator--spaced": props.spaced
    }))
  })
});
function _sfc_render55(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    "aria-hidden": "true",
    class: normalizeClass(["va-list-separator", _ctx.computedClass])
  }, null, 2);
}
var _VaListSeparator = _export_sfc(_sfc_main56, [["render", _sfc_render55]]);

// node_modules/vuestic-ui/dist/es/src/components/va-list/index.js
var VaListItem = withConfigTransport(_VaListItem);
var VaListLabel = withConfigTransport(_VaListLabel);
var VaListItemLabel = withConfigTransport(_VaListItemLabel);
var VaListItemSection = withConfigTransport(_VaListItemSection);
var VaListSeparator = withConfigTransport(_VaListSeparator);
var VaList = withConfigTransport(_VaList);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useStrictInject.js
init_vue_runtime_esm_bundler();
var useStrictInject = (injectionSymbol, errorMessage) => {
  const strictInjection = inject(injectionSymbol);
  if (!strictInjection) {
    throw new Error(errorMessage);
  }
  return strictInjection;
};

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-progress-bar/VaProgressBar.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-progress-bar/VaProgressBar.css";
var __defProp68 = Object.defineProperty;
var __defProps58 = Object.defineProperties;
var __getOwnPropDescs58 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols68 = Object.getOwnPropertySymbols;
var __hasOwnProp68 = Object.prototype.hasOwnProperty;
var __propIsEnum68 = Object.prototype.propertyIsEnumerable;
var __defNormalProp68 = (obj, key, value) => key in obj ? __defProp68(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues68 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp68.call(b2, prop))
      __defNormalProp68(a2, prop, b2[prop]);
  if (__getOwnPropSymbols68)
    for (var prop of __getOwnPropSymbols68(b2)) {
      if (__propIsEnum68.call(b2, prop))
        __defNormalProp68(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps58 = (a2, b2) => __defProps58(a2, __getOwnPropDescs58(b2));
var _sfc_main57 = defineComponent({
  name: "VaProgressBar",
  props: __spreadProps58(__spreadValues68({}, useComponentPresetProp), {
    modelValue: { type: Number, default: 0 },
    indeterminate: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: [Number, String],
      default: "medium"
    },
    buffer: { type: Number, default: 100 },
    rounded: { type: Boolean, default: true },
    reverse: { type: Boolean, default: false },
    contentInside: { type: Boolean, default: false },
    showPercent: { type: Boolean, default: false }
  }),
  setup(props) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const colorComputed = computed(() => getColor(props.color));
    const isTextSize = computed(() => typeof props.size === "string" && ["small", "medium", "large"].includes(props.size));
    const getCSSHeight = () => {
      if (typeof props.size === "number") {
        return `${props.size}px`;
      }
      if (isTextSize.value) {
        return;
      }
      return props.size;
    };
    const { t: t2 } = useTranslation();
    return {
      rootClass: computed(() => ({
        "va-progress-bar--square": !props.rounded,
        [`va-progress-bar--${props.size}`]: isTextSize.value
      })),
      rooStyle: computed(() => ({
        "--va-progress-bar-color": colorComputed.value,
        "--va-progress-bar-background-color": getHoverColor2(colorComputed.value)
      })),
      wrapperStyle: computed(() => ({
        height: getCSSHeight()
      })),
      bufferStyle: computed(() => ({
        width: `${props.indeterminate ? 100 : clamp_1(props.buffer, 0, 100)}%`,
        color: textColorComputed.value,
        [props.reverse ? "right" : "left"]: 0
      })),
      progressStyle: computed(() => ({
        width: `${clamp_1(props.modelValue, 0, 100)}%`,
        marginLeft: props.reverse ? "auto" : void 0
      })),
      intermediateStyle: computed(() => ({
        animationDirection: props.reverse ? "reverse" : "normal"
      })),
      ariaAttributesComputed: computed(() => ({
        role: "progressbar",
        ariaLabel: t2("progressState"),
        ariaValuenow: !props.indeterminate ? props.modelValue : void 0
      }))
    };
  }
});
var _hoisted_135 = {
  key: 0,
  class: "va-progress-bar__info"
};
function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-progress-bar", _ctx.rootClass],
    style: _ctx.rooStyle
  }, _ctx.ariaAttributesComputed), [
    !_ctx.$props.contentInside ? (openBlock(), createElementBlock("div", _hoisted_135, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.$props.modelValue })), () => [
        _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: "va-progress-bar__wrapper",
      style: normalizeStyle(_ctx.wrapperStyle)
    }, [
      createBaseVNode("div", {
        class: "va-progress-bar__buffer",
        style: normalizeStyle(_ctx.bufferStyle)
      }, [
        _ctx.$props.contentInside ? renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 0 }, { value: _ctx.$props.modelValue })), () => [
          _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
          ], 64)) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ], 4),
      _ctx.indeterminate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-start",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4),
        createBaseVNode("div", {
          class: "va-progress-bar__progress--indeterminate-end",
          style: normalizeStyle(_ctx.intermediateStyle)
        }, null, 4)
      ], 64)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: "va-progress-bar__progress",
        style: normalizeStyle(_ctx.progressStyle)
      }, null, 4))
    ], 4)
  ], 16);
}
var _VaProgressBar = _export_sfc(_sfc_main57, [["render", _sfc_render56]]);

// node_modules/vuestic-ui/dist/es/src/components/va-progress-bar/index.js
var VaProgressBar = withConfigTransport(_VaProgressBar);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/VaFileUploadUndo.css";
var INJECTION_ERROR_MESSAGE = "The VaFileUploadUndo component should be used in the context of VaFileUpload component";
var __default__4 = defineComponent({
  name: "VaFileUploadUndo",
  components: {
    VaProgressBar,
    VaButton: VaButton2
  },
  props: {
    vertical: { type: Boolean, default: false }
  },
  emits: ["recover"],
  setup: (props) => {
    const progress = ref(100);
    const {
      undoDuration,
      undoButtonText,
      deletedFileMessage
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE);
    const computedClasses = useBem("va-file-upload-undo", () => ({
      vertical: props.vertical
    }));
    const undoDurationStyle = computed(() => {
      var _a;
      return `${(_a = undoDuration.value) != null ? _a : 0}ms`;
    });
    onMounted(() => {
      const timer = setTimeout(() => {
        progress.value = 0;
        clearTimeout(timer);
      }, 0);
    });
    return {
      progress,
      undoDuration,
      undoButtonText,
      computedClasses,
      undoDurationStyle,
      deletedFileMessage
    };
  }
});
var __injectCSSVars__4 = () => {
  useCssVars((_ctx) => ({
    "35ceb3fe": _ctx.undoDurationStyle
  }));
};
var __setup__4 = __default__4.setup;
__default__4.setup = __setup__4 ? (props, ctx) => {
  __injectCSSVars__4();
  return __setup__4(props, ctx);
} : __injectCSSVars__4;
var _sfc_main58 = __default__4;
var _hoisted_136 = { class: "va-file-upload-undo__text" };
function _sfc_render57(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_bar = resolveComponent("va-progress-bar");
  const _component_va_button = resolveComponent("va-button");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_va_progress_bar, {
      "model-value": _ctx.progress,
      rounded: false,
      class: "va-file-upload-undo-progress-bar"
    }, null, 8, ["model-value"]),
    createBaseVNode("div", {
      class: normalizeClass(["va-file-upload-undo", _ctx.computedClasses])
    }, [
      createBaseVNode("span", _hoisted_136, toDisplayString(_ctx.deletedFileMessage), 1),
      createVNode(_component_va_button, {
        class: "va-file-upload-undo__button",
        "aria-label": _ctx.undoButtonText,
        size: "small",
        outline: "",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("recover"))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.undoButtonText), 1)
        ]),
        _: 1
      }, 8, ["aria-label"])
    ], 2)
  ], 64);
}
var _VaFileUploadUndo = _export_sfc(_sfc_main58, [["render", _sfc_render57]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadUndo/index.js
var VaFileUploadUndo = withConfigTransport(_VaFileUploadUndo);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/VaFileUploadListItem.css";
var __defProp69 = Object.defineProperty;
var __defProps59 = Object.defineProperties;
var __getOwnPropDescs59 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols69 = Object.getOwnPropertySymbols;
var __hasOwnProp69 = Object.prototype.hasOwnProperty;
var __propIsEnum69 = Object.prototype.propertyIsEnumerable;
var __defNormalProp69 = (obj, key, value) => key in obj ? __defProp69(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues69 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp69.call(b2, prop))
      __defNormalProp69(a2, prop, b2[prop]);
  if (__getOwnPropSymbols69)
    for (var prop of __getOwnPropSymbols69(b2)) {
      if (__propIsEnum69.call(b2, prop))
        __defNormalProp69(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps59 = (a2, b2) => __defProps59(a2, __getOwnPropDescs59(b2));
var INJECTION_ERROR_MESSAGE2 = "The VaFileUploadListItem component should be used in the context of VaFileUpload component";
var _sfc_main59 = defineComponent({
  name: "VaFileUploadListItem",
  components: {
    VaListItem,
    VaListItemSection,
    VaFileUploadUndo,
    VaButton: VaButton2
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" }
  },
  setup(props, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE2);
    const { onFocus, onBlur } = useFocus();
    const removed = ref(false);
    const removeFile = () => {
      var _a;
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (removed.value) {
            emit("remove");
            removed.value = false;
          }
        }, (_a = undoDuration.value) != null ? _a : 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverFile = () => {
      removed.value = false;
    };
    const computedClasses = useBem("va-file-upload-list-item", () => ({
      undo: removed.value
    }));
    return __spreadProps59(__spreadValues69({}, useTranslation()), {
      undo,
      removed,
      disabled,
      computedClasses,
      onBlur,
      onFocus,
      removeFile,
      recoverFile
    });
  }
});
var _hoisted_137 = { class: "va-file-upload-list-item__content" };
var _hoisted_219 = {
  key: 0,
  class: "va-file-upload-list-item__name"
};
var _hoisted_38 = { class: "va-file-upload-list-item__size" };
function _sfc_render58(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    class: normalizeClass(["va-file-upload-list-item", _ctx.computedClasses]),
    tabindex: "-1",
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_list_item_section, { key: 0 }, {
        default: withCtx(() => [
          createVNode(_component_va_file_upload_undo, { onRecover: _ctx.recoverFile }, null, 8, ["onRecover"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_va_list_item_section, { key: 1 }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_137, [
            _ctx.file && _ctx.file.name ? (openBlock(), createElementBlock("div", _hoisted_219, toDisplayString(_ctx.file && _ctx.file.name), 1)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_38, toDisplayString(_ctx.file && _ctx.file.size), 1),
            !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
              key: 1,
              flat: "",
              color: "danger",
              icon: "clear",
              class: "va-file-upload-list-item__delete",
              "aria-label": _ctx.t("removeFile"),
              onClick: withModifiers(_ctx.removeFile, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["enter"]),
                withKeys(withModifiers(_ctx.removeFile, ["stop"]), ["space"])
              ],
              onFocus: _ctx.onFocus,
              onBlur: _ctx.onBlur
            }, null, 8, ["aria-label", "onClick", "onKeydown", "onFocus", "onBlur"])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["class", "disabled", "aria-disabled"]);
}
var _VaFileUploadListItem = _export_sfc(_sfc_main59, [["render", _sfc_render58]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadListItem/index.js
var VaFileUploadListItem = withConfigTransport(_VaFileUploadListItem);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadGalleryItem/VaFileUploadGalleryItem.css";
var __defProp70 = Object.defineProperty;
var __defProps60 = Object.defineProperties;
var __getOwnPropDescs60 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols70 = Object.getOwnPropertySymbols;
var __hasOwnProp70 = Object.prototype.hasOwnProperty;
var __propIsEnum70 = Object.prototype.propertyIsEnumerable;
var __defNormalProp70 = (obj, key, value) => key in obj ? __defProp70(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues70 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp70.call(b2, prop))
      __defNormalProp70(a2, prop, b2[prop]);
  if (__getOwnPropSymbols70)
    for (var prop of __getOwnPropSymbols70(b2)) {
      if (__propIsEnum70.call(b2, prop))
        __defNormalProp70(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps60 = (a2, b2) => __defProps60(a2, __getOwnPropDescs60(b2));
var INJECTION_ERROR_MESSAGE3 = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
var _sfc_main60 = defineComponent({
  name: "VaFileUploadGalleryItem",
  components: {
    VaFileUploadUndo,
    VaButton: VaButton2,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" }
  },
  setup(props, { emit }) {
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE3);
    const { isFocused, onFocus, onBlur } = useFocus();
    const previewImage = ref("");
    const removed = ref(false);
    const overlayStylesComputed = computed(() => ({
      backgroundColor: colorToRgba(props.color, 0.7)
    }));
    const classesComputed = useBem("va-file-upload-gallery-item", () => ({
      notImage: !previewImage.value,
      focused: isFocused.value,
      undo: removed.value
    }));
    const removeImage = () => {
      var _a;
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit("remove");
          removed.value = false;
        }, (_a = undoDuration.value) != null ? _a : 0);
      } else {
        emit("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props.file.name || !props.file.image) {
        return;
      }
      if (props.file.image.url) {
        previewImage.value = props.file.image.url;
      } else if (props.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props.file.image);
        reader.onload = (e2) => {
          var _a, _b;
          if (((_a = e2.target) == null ? void 0 : _a.result).includes("image")) {
            previewImage.value = (_b = e2.target) == null ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted(convertToImg);
    watch(() => props.file, convertToImg);
    return __spreadProps60(__spreadValues70(__spreadProps60(__spreadValues70({}, useTranslation()), {
      undo
    }), useTextColor(toRef(props, "color"))), {
      removed,
      disabled,
      isFocused,
      previewImage,
      classesComputed,
      overlayStylesComputed,
      onBlur,
      onFocus,
      removeImage,
      recoverImage
    });
  }
});
var _hoisted_138 = ["src", "alt"];
var _hoisted_220 = { class: "va-file-upload-gallery-item__overlay" };
var _hoisted_39 = ["title"];
function _sfc_render59(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_undo = resolveComponent("va-file-upload-undo");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    class: normalizeClass(["va-file-upload-gallery-item", _ctx.classesComputed]),
    tabindex: "-1",
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled,
    onFocus: _ctx.onFocus,
    onBlur: _ctx.onBlur
  }, {
    default: withCtx(() => [
      _ctx.removed && _ctx.undo ? (openBlock(), createBlock(_component_va_list_item_section, { key: 0 }, {
        default: withCtx(() => [
          createVNode(_component_va_file_upload_undo, {
            vertical: "",
            onRecover: _ctx.recoverImage
          }, null, 8, ["onRecover"])
        ]),
        _: 1
      })) : (openBlock(), createBlock(_component_va_list_item_section, { key: 1 }, {
        default: withCtx(() => [
          _ctx.previewImage ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.previewImage,
            alt: _ctx.file.name || "",
            class: "va-file-upload-gallery-item__image"
          }, null, 8, _hoisted_138)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_220, [
            createBaseVNode("div", {
              class: "va-file-upload-gallery-item__overlay-background",
              style: normalizeStyle(_ctx.overlayStylesComputed)
            }, null, 4),
            _ctx.file && _ctx.file.name ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-file-upload-gallery-item__name",
              title: _ctx.file.name,
              style: normalizeStyle({ color: _ctx.textColorComputed })
            }, toDisplayString(_ctx.file.name), 13, _hoisted_39)) : createCommentVNode("", true),
            !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
              key: 1,
              flat: "",
              color: "danger",
              icon: "va-delete",
              class: "va-file-upload-gallery-item__delete",
              "aria-label": _ctx.t("removeFile"),
              onClick: _ctx.removeImage,
              onFocus: _ctx.onFocus,
              onBlur: _ctx.onBlur
            }, null, 8, ["aria-label", "onClick", "onFocus", "onBlur"])) : createCommentVNode("", true)
          ])
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["class", "disabled", "aria-disabled", "onFocus", "onBlur"]);
}
var _VaFileUploadGalleryItem = _export_sfc(_sfc_main60, [["render", _sfc_render59]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadGalleryItem/index.js
var VaFileUploadGalleryItem = withConfigTransport(_VaFileUploadGalleryItem);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadSingleItem/VaFileUploadSingleItem.css";
var __defProp71 = Object.defineProperty;
var __defProps61 = Object.defineProperties;
var __getOwnPropDescs61 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols71 = Object.getOwnPropertySymbols;
var __hasOwnProp71 = Object.prototype.hasOwnProperty;
var __propIsEnum71 = Object.prototype.propertyIsEnumerable;
var __defNormalProp71 = (obj, key, value) => key in obj ? __defProp71(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues71 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp71.call(b2, prop))
      __defNormalProp71(a2, prop, b2[prop]);
  if (__getOwnPropSymbols71)
    for (var prop of __getOwnPropSymbols71(b2)) {
      if (__propIsEnum71.call(b2, prop))
        __defNormalProp71(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps61 = (a2, b2) => __defProps61(a2, __getOwnPropDescs61(b2));
var INJECTION_ERROR_MESSAGE4 = "The VaFileUploadSingleItem component should be used in the context of VaFileUpload component";
var _sfc_main61 = defineComponent({
  name: "VaFileUploadSingleItem",
  components: {
    VaButton: VaButton2,
    VaListItem,
    VaListItemSection
  },
  emits: ["remove"],
  props: {
    file: { type: Object, default: null }
  },
  setup: () => __spreadProps61(__spreadValues71({}, useTranslation()), {
    disabled: useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE4).disabled
  })
});
var _hoisted_139 = { class: "va-file-upload-single-item__name" };
var _hoisted_221 = createTextVNode(" Delete ");
function _sfc_render60(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_list_item_section = resolveComponent("va-list-item-section");
  const _component_va_list_item = resolveComponent("va-list-item");
  return openBlock(), createBlock(_component_va_list_item, {
    disabled: _ctx.disabled,
    "aria-disabled": _ctx.disabled,
    class: "va-file-upload-single-item",
    tabindex: "-1"
  }, {
    default: withCtx(() => [
      createVNode(_component_va_list_item_section, { class: "va-file-upload-single-item__content" }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_139, toDisplayString(_ctx.file && _ctx.file.name), 1),
          !_ctx.disabled ? (openBlock(), createBlock(_component_va_button, {
            key: 0,
            class: "va-file-upload-single-item__button",
            "aria-label": _ctx.t("removeFile"),
            size: "small",
            color: "danger",
            flat: "",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove"))
          }, {
            default: withCtx(() => [
              _hoisted_221
            ]),
            _: 1
          }, 8, ["aria-label"])) : createCommentVNode("", true)
        ]),
        _: 1
      })
    ]),
    _: 1
  }, 8, ["disabled", "aria-disabled"]);
}
var _VaFileUploadSingleItem = _export_sfc(_sfc_main61, [["render", _sfc_render60]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadSingleItem/index.js
var VaFileUploadSingleItem = withConfigTransport(_VaFileUploadSingleItem);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/VaFileUploadList.css";
var _sfc_main62 = defineComponent({
  name: "VaFileUploadList",
  components: {
    VaList,
    VaFileUploadListItem,
    VaFileUploadGalleryItem,
    VaFileUploadSingleItem
  },
  emits: ["remove", "removeSingle"],
  props: {
    type: { type: String, default: "" },
    files: { type: Array, default: null },
    color: { type: String, default: "success" }
  },
  setup(props) {
    const filesList = computed(() => props.files.map(convertFile));
    const convertFile = (file) => ({
      name: file.name || file.url || "",
      size: formatSize(file.size),
      date: formatDate(new Date()),
      image: file
    });
    const formatSize = (bytes) => {
      if (bytes === 0) {
        return "0 Bytes";
      }
      if (!bytes) {
        return "";
      }
      const k2 = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i2 = Math.floor(Math.log(bytes) / Math.log(k2));
      return parseFloat((bytes / Math.pow(k2, i2)).toFixed(2)) + " " + sizes[i2];
    };
    const formatDate = (date = new Date()) => {
      return date.toLocaleDateString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    };
    return {
      filesList
    };
  }
});
function _sfc_render61(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_file_upload_list_item = resolveComponent("va-file-upload-list-item");
  const _component_va_file_upload_gallery_item = resolveComponent("va-file-upload-gallery-item");
  const _component_va_file_upload_single_item = resolveComponent("va-file-upload-single-item");
  const _component_va_list = resolveComponent("va-list");
  return openBlock(), createBlock(_component_va_list, {
    class: normalizeClass(["va-file-upload-list", `va-file-upload-list--${_ctx.type}`]),
    role: _ctx.type !== "single" ? "list" : void 0
  }, {
    default: withCtx(() => [
      _ctx.type === "list" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.filesList, (file, index) => {
        return openBlock(), createBlock(_component_va_file_upload_list_item, {
          key: file.name,
          file,
          color: _ctx.color,
          role: "listitem",
          onRemove: ($event) => _ctx.$emit("remove", index)
        }, null, 8, ["file", "color", "onRemove"]);
      }), 128)) : createCommentVNode("", true),
      _ctx.type === "gallery" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.filesList, (file, index) => {
        return openBlock(), createBlock(_component_va_file_upload_gallery_item, {
          key: file.name,
          file,
          color: _ctx.color,
          role: "listitem",
          onRemove: ($event) => _ctx.$emit("remove", index)
        }, null, 8, ["file", "color", "onRemove"]);
      }), 128)) : createCommentVNode("", true),
      _ctx.type === "single" && _ctx.filesList.length ? (openBlock(), createBlock(_component_va_file_upload_single_item, {
        key: 2,
        file: _ctx.filesList[_ctx.filesList.length - 1],
        onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("removeSingle"))
      }, null, 8, ["file"])) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["role", "class"]);
}
var _VaFileUploadList = _export_sfc(_sfc_main62, [["render", _sfc_render61]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUploadList/index.js
var VaFileUploadList = withConfigTransport(_VaFileUploadList);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUpload.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-file-upload/VaFileUpload.css";
var __defProp72 = Object.defineProperty;
var __defProps62 = Object.defineProperties;
var __getOwnPropDescs62 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols72 = Object.getOwnPropertySymbols;
var __hasOwnProp72 = Object.prototype.hasOwnProperty;
var __propIsEnum72 = Object.prototype.propertyIsEnumerable;
var __defNormalProp72 = (obj, key, value) => key in obj ? __defProp72(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues72 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp72.call(b2, prop))
      __defNormalProp72(a2, prop, b2[prop]);
  if (__getOwnPropSymbols72)
    for (var prop of __getOwnPropSymbols72(b2)) {
      if (__propIsEnum72.call(b2, prop))
        __defNormalProp72(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps62 = (a2, b2) => __defProps62(a2, __getOwnPropDescs62(b2));
var _sfc_main63 = defineComponent({
  name: "VaFileUpload",
  components: {
    VaModal,
    VaButton: VaButton2,
    VaFileUploadList
  },
  props: __spreadProps62(__spreadValues72({}, useComponentPresetProp), {
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: Number, default: 3e3 },
    undoButtonText: { type: String, default: "$t:undo" },
    dropZoneText: { type: String, default: "$t:dropzone" },
    uploadButtonText: { type: String, default: "$t:uploadFile" },
    deletedFileMessage: { type: String, default: "$t:fileDeleted" },
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  }),
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(props, { emit }) {
    const fileInputRef = shallowRef();
    const modal = ref(false);
    const dropzoneHighlight = ref(false);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      backgroundColor: props.dropzone ? shiftHSLAColor2(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const computedClasses = useBem("va-file-upload", () => ({
      dropzone: props.dropzone,
      disabled: props.disabled
    }));
    const files = computed({
      get() {
        return Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue];
      },
      set(files2) {
        if (props.type === "single") {
          emit("update:modelValue", files2[0]);
        } else {
          emit("update:modelValue", files2);
        }
      }
    });
    const validateFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t2) => props.fileTypes.includes(t2));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e2) => {
      var _a, _b;
      const f2 = ((_a = e2.target) == null ? void 0 : _a.files) || ((_b = e2.dataTransfer) == null ? void 0 : _b.files);
      if (!f2) {
        return;
      }
      const validatedFiles = props.fileTypes ? validateFiles(Array.from(f2)) : f2;
      files.value = props.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit("file-added", validatedFiles);
    };
    const changeFieldValue = (e2) => {
      uploadFile(e2);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted(() => {
      if (Array.isArray(files.value)) {
        files.value = validateFiles(files.value);
      }
    });
    const { tp } = useTranslation();
    provide(VaFileUploadKey, {
      undo: toRef(props, "undo"),
      disabled: toRef(props, "disabled"),
      undoDuration: toRef(props, "undoDuration"),
      undoButtonText: computed(() => tp(props.undoButtonText)),
      deletedFileMessage: computed(() => tp(props.deletedFileMessage))
    });
    return {
      modal,
      dropzoneHighlight,
      fileInputRef,
      colorComputed,
      computedStyle,
      computedClasses,
      files,
      tp,
      uploadFile,
      changeFieldValue,
      removeFile,
      removeSingleFile,
      callFileDialogue
    };
  }
});
var _hoisted_140 = { class: "va-file-upload__field" };
var _hoisted_222 = {
  key: 0,
  class: "va-file-upload__field__text"
};
var _hoisted_310 = ["accept", "multiple", "disabled"];
function _sfc_render62(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_file_upload_list = resolveComponent("va-file-upload-list");
  const _component_va_modal = resolveComponent("va-modal");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-file-upload", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createBaseVNode("div", _hoisted_140, [
        _ctx.dropzone ? (openBlock(), createElementBlock("div", _hoisted_222, toDisplayString(_ctx.tp(_ctx.dropZoneText)), 1)) : createCommentVNode("", true),
        createVNode(_component_va_button, {
          class: "va-file-upload__field__button",
          disabled: _ctx.disabled,
          "aria-disabled": _ctx.disabled,
          color: _ctx.colorComputed,
          style: normalizeStyle({ "pointer-events": _ctx.dropzoneHighlight ? "none" : void 0 }),
          onChange: _ctx.changeFieldValue,
          onClick: _ctx.callFileDialogue
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.tp(_ctx.uploadButtonText)), 1)
          ]),
          _: 1
        }, 8, ["disabled", "aria-disabled", "color", "style", "onChange", "onClick"])
      ])
    ]),
    createBaseVNode("input", {
      ref: "fileInputRef",
      type: "file",
      class: "va-file-upload__field__input",
      tabindex: -1,
      "aria-hidden": "true",
      accept: _ctx.fileTypes,
      multiple: _ctx.type !== "single",
      disabled: _ctx.disabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.changeFieldValue && _ctx.changeFieldValue(...args)),
      onDragenter: _cache[1] || (_cache[1] = ($event) => _ctx.dropzoneHighlight = true),
      onDragleave: _cache[2] || (_cache[2] = ($event) => _ctx.dropzoneHighlight = false)
    }, null, 40, _hoisted_310),
    _ctx.files.length && !_ctx.$props.hideFileList ? (openBlock(), createBlock(_component_va_file_upload_list, {
      key: 0,
      type: _ctx.type,
      files: _ctx.files,
      color: _ctx.colorComputed,
      onRemove: _ctx.removeFile,
      onRemoveSingle: _ctx.removeSingleFile
    }, null, 8, ["type", "files", "color", "onRemove", "onRemoveSingle"])) : createCommentVNode("", true),
    createVNode(_component_va_modal, {
      modelValue: _ctx.modal,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.modal = $event),
      "hide-default-actions": "",
      title: "File validation",
      message: "File type is incorrect!"
    }, null, 8, ["modelValue"])
  ], 6);
}
var _VaFileUpload = _export_sfc(_sfc_main63, [["render", _sfc_render62]]);

// node_modules/vuestic-ui/dist/es/src/components/va-file-upload/index.js
var VaFileUpload = withConfigTransport(_VaFileUpload);

// node_modules/vuestic-ui/dist/es/src/components/va-form/VaForm.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-form/VaForm.css";
var __defProp73 = Object.defineProperty;
var __defProps63 = Object.defineProperties;
var __getOwnPropDescs63 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols73 = Object.getOwnPropertySymbols;
var __hasOwnProp73 = Object.prototype.hasOwnProperty;
var __propIsEnum73 = Object.prototype.propertyIsEnumerable;
var __defNormalProp73 = (obj, key, value) => key in obj ? __defProp73(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues73 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp73.call(b2, prop))
      __defNormalProp73(a2, prop, b2[prop]);
  if (__getOwnPropSymbols73)
    for (var prop of __getOwnPropSymbols73(b2)) {
      if (__propIsEnum73.call(b2, prop))
        __defNormalProp73(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps63 = (a2, b2) => __defProps63(a2, __getOwnPropDescs63(b2));
var isVaForm = (value) => !!value.focusInvalid;
var _sfc_main64 = defineComponent({
  name: "VaForm",
  emits: ["validation"],
  props: __spreadProps63(__spreadValues73({}, useComponentPresetProp), {
    autofocus: { type: Boolean, default: false },
    tag: { type: String, default: "div" }
  }),
  setup(props, { emit }) {
    const nestedFormElements = ref([]);
    const parentFormProvider = () => inject(FormServiceKey, void 0);
    provide(FormServiceKey, {
      onChildMounted: (child) => childMountedHandler(child),
      onChildUnmounted: (removableChild) => childUnmountedHandler(removableChild)
    });
    const childMountedHandler = (child) => {
      nestedFormElements.value.push(child);
    };
    const childUnmountedHandler = (removableChild) => {
      nestedFormElements.value = nestedFormElements.value.filter((child) => child !== removableChild);
    };
    const reset = () => {
      nestedFormElements.value.filter(({ reset: reset2 }) => reset2).forEach((item) => {
        item.reset();
      });
    };
    const resetValidation = () => {
      nestedFormElements.value.filter(({ resetValidation: resetValidation2 }) => resetValidation2).forEach((item) => {
        item.resetValidation();
      });
    };
    const focus = () => {
      var _a;
      (_a = nestedFormElements.value.find(({ focus: focus2 }) => focus2)) == null ? void 0 : _a.focus();
    };
    const focusInvalid = () => {
      const invalidComponent = nestedFormElements.value.find((item) => !isVaForm(item) && item.hasError());
      if (invalidComponent) {
        invalidComponent.focus();
      } else {
        nestedFormElements.value.forEach((item) => isVaForm(item) && item.focusInvalid());
      }
    };
    const validate = () => {
      const formValid = nestedFormElements.value.filter(({ validate: validate2 }) => validate2).map((child) => child.validate()).every((isValid) => isValid);
      emit("validation", formValid);
      return formValid;
    };
    const publicMethods = {
      reset,
      resetValidation,
      focus,
      focusInvalid,
      validate
    };
    onMounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) == null ? void 0 : _a.onChildMounted) == null ? void 0 : _b.call(_a, publicMethods);
      if (props.autofocus) {
        nextTick(focus);
      }
    });
    onUnmounted(() => {
      var _a, _b;
      (_b = (_a = parentFormProvider()) == null ? void 0 : _a.onChildUnmounted) == null ? void 0 : _b.call(_a, publicMethods);
    });
    return publicMethods;
  }
});
function _sfc_render63(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), { class: "va-form" }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  });
}
var _VaForm = _export_sfc(_sfc_main64, [["render", _sfc_render63]]);

// node_modules/vuestic-ui/dist/es/src/components/va-form/index.js
var VaForm = withConfigTransport(_VaForm);

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/VaInfiniteScroll.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/hooks/useScroll.js
init_vue_runtime_esm_bundler();
var useScroll = (props, element, handler) => {
  const addScrollListener = () => {
    var _a;
    (_a = element.value) == null ? void 0 : _a.addEventListener("scroll", handler.value, { passive: true });
  };
  const removeScrollListener = () => {
    var _a;
    (_a = element.value) == null ? void 0 : _a.removeEventListener("scroll", handler.value);
  };
  onMounted(() => {
    if (!element.value) {
      return;
    }
    element.value.style.overflowY = "scroll";
    if (props.reverse) {
      element.value.scrollTop = element.value.scrollHeight;
    }
    addScrollListener();
  });
  onBeforeUnmount(removeScrollListener);
  return {
    addScrollListener,
    removeScrollListener
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/VaInfiniteScroll.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/VaInfiniteScroll.css";
var __defProp74 = Object.defineProperty;
var __defProps64 = Object.defineProperties;
var __getOwnPropDescs64 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols74 = Object.getOwnPropertySymbols;
var __hasOwnProp74 = Object.prototype.hasOwnProperty;
var __propIsEnum74 = Object.prototype.propertyIsEnumerable;
var __defNormalProp74 = (obj, key, value) => key in obj ? __defProp74(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues74 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp74.call(b2, prop))
      __defNormalProp74(a2, prop, b2[prop]);
  if (__getOwnPropSymbols74)
    for (var prop of __getOwnPropSymbols74(b2)) {
      if (__propIsEnum74.call(b2, prop))
        __defNormalProp74(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps64 = (a2, b2) => __defProps64(a2, __getOwnPropDescs64(b2));
var _sfc_main65 = defineComponent({
  name: "VaInfiniteScroll",
  components: { VaProgressCircle },
  props: __spreadProps64(__spreadValues74({}, useComponentPresetProp), {
    load: { type: Function, required: true },
    offset: { type: Number, default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: void 0 },
    debounce: { type: Number, default: 100 },
    tag: { type: String, default: "div" }
  }),
  emits: ["onload", "onerror"],
  setup(props, { emit }) {
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a = element.value) == null ? void 0 : _a.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props, scrollTargetElement, debouncedLoad);
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a;
      return ((_a = spinnerSlotContainer.value) == null ? void 0 : _a.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return props.offset + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => props.debounce, (value) => {
      debouncedLoad.value = debounce_1(onLoad, value);
    }, { immediate: true });
    watch(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return {
      element,
      spinnerSlotContainer,
      spinnerColor,
      fetching
    };
  }
});
var _hoisted_141 = { class: "va-infinite-scroll__spinner__default" };
function _sfc_render64(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
    ref: "element",
    role: "feed",
    class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
    "aria-busy": _ctx.fetching
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      createBaseVNode("div", {
        ref: "spinnerSlotContainer",
        class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !_ctx.fetching }])
      }, [
        !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
          createBaseVNode("div", _hoisted_141, [
            createVNode(_component_va_progress_circle, {
              size: "small",
              thickness: 0.15,
              color: _ctx.spinnerColor,
              indeterminate: ""
            }, null, 8, ["thickness", "color"])
          ])
        ]) : createCommentVNode("", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["class", "aria-busy"]);
}
var _VaInfiniteScroll = _export_sfc(_sfc_main65, [["render", _sfc_render64]]);

// node_modules/vuestic-ui/dist/es/src/components/va-infinite-scroll/index.js
var VaInfiniteScroll = withConfigTransport(_VaInfiniteScroll);

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbar.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbar.css";
var __defProp75 = Object.defineProperty;
var __defProps65 = Object.defineProperties;
var __getOwnPropDescs65 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols75 = Object.getOwnPropertySymbols;
var __hasOwnProp75 = Object.prototype.hasOwnProperty;
var __propIsEnum75 = Object.prototype.propertyIsEnumerable;
var __defNormalProp75 = (obj, key, value) => key in obj ? __defProp75(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues75 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp75.call(b2, prop))
      __defNormalProp75(a2, prop, b2[prop]);
  if (__getOwnPropSymbols75)
    for (var prop of __getOwnPropSymbols75(b2)) {
      if (__propIsEnum75.call(b2, prop))
        __defNormalProp75(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps65 = (a2, b2) => __defProps65(a2, __getOwnPropDescs65(b2));
var _sfc_main66 = defineComponent({
  name: "VaNavbar",
  props: __spreadProps65(__spreadValues75(__spreadValues75({}, useFixedBarProps), useComponentPresetProp), {
    color: { type: String, default: "background-secondary" },
    textColor: { type: String },
    shape: { type: Boolean, default: false }
  }),
  setup(props) {
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const color = computed(() => getColor(props.color));
    const shapeStyleComputed = computed(() => ({
      borderTopColor: shiftHSLAColor2(color.value, { h: -1, s: -11, l: 10 })
    }));
    const computedStyle = computed(() => __spreadProps65(__spreadValues75({}, fixedBarStyleComputed.value), {
      backgroundColor: color.value,
      color: textColorComputed.value,
      fill: textColorComputed.value
    }));
    return { computedStyle, shapeStyleComputed, scrollRoot };
  }
});
var _hoisted_143 = { class: "va-navbar__content" };
var _hoisted_223 = {
  key: 0,
  class: "va-navbar__left"
};
var _hoisted_311 = {
  key: 1,
  class: "va-navbar__center"
};
var _hoisted_48 = {
  key: 2,
  class: "va-navbar__right"
};
function _sfc_render65(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    ref: "scrollRoot",
    class: "va-navbar",
    style: normalizeStyle(_ctx.computedStyle)
  }, [
    createBaseVNode("div", _hoisted_143, [
      _ctx.$slots.left ? (openBlock(), createElementBlock("div", _hoisted_223, [
        renderSlot(_ctx.$slots, "left")
      ])) : createCommentVNode("", true),
      _ctx.$slots.center ? (openBlock(), createElementBlock("div", _hoisted_311, [
        renderSlot(_ctx.$slots, "center")
      ])) : createCommentVNode("", true),
      _ctx.$slots.right ? (openBlock(), createElementBlock("div", _hoisted_48, [
        renderSlot(_ctx.$slots, "right")
      ])) : createCommentVNode("", true)
    ]),
    _ctx.shape ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "va-navbar__background-shape",
      style: normalizeStyle(_ctx.shapeStyleComputed)
    }, null, 4)) : createCommentVNode("", true)
  ], 4);
}
var _VaNavbar = _export_sfc(_sfc_main66, [["render", _sfc_render65]]);

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbarItem/VaNavbarItem.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-navbar/VaNavbarItem/VaNavbarItem.css";
var _sfc_main67 = defineComponent({
  name: "VaNavbarItem"
});
var _hoisted_144 = { class: "va-navbar__item" };
function _sfc_render66(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_144, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaNavbarItem = _export_sfc(_sfc_main67, [["render", _sfc_render66]]);

// node_modules/vuestic-ui/dist/es/src/components/va-navbar/index.js
var VaNavbar = withConfigTransport(_VaNavbar);
var VaNavbarItem = withConfigTransport(_VaNavbarItem);

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/VaOptionList.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useArrayRefs.js
init_vue_runtime_esm_bundler();
var useArrayRefs = () => {
  const itemRefs = shallowRef([]);
  const setItemRef = (el) => {
    if (!el) {
      return;
    }
    itemRefs.value.push(el);
  };
  const setItemRefByIndex = (index) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[index] = el;
  };
  onBeforeUpdate(() => {
    itemRefs.value = [];
  });
  return {
    itemRefs,
    setItemRef,
    setItemRefByIndex
  };
};

// node_modules/vuestic-ui/dist/es/src/composables/useSelectableList.js
var useSelectableListProps = {
  options: { type: Array, default: () => [] },
  textBy: { type: [String, Function], default: "text" },
  valueBy: { type: [String, Function], default: "" },
  trackBy: { type: [String, Function], default: "" },
  disabledBy: { type: [String, Function], default: "disabled" },
  groupBy: { type: [String, Function], default: "group" }
};
function useSelectableList(props) {
  const isStringOrNumber = (option) => {
    const typeOfOption = typeof option;
    return typeOfOption === "string" || typeOfOption === "number";
  };
  const getOptionProperty = (option, selector) => {
    return !selector || isStringOrNumber(option) ? option : getValueByKey(option, selector);
  };
  const getValue2 = (option) => getOptionProperty(option, props.valueBy);
  const getOptionByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.options.find((option) => value === getValue2(option)) || value;
  };
  const getText = (option) => getOptionProperty(option, props.textBy);
  const getDisabled = (option) => isStringOrNumber(option) ? false : getOptionProperty(option, props.disabledBy);
  const getTrackBy = (option) => {
    if (props.trackBy) {
      return getOptionProperty(option, props.trackBy);
    }
    return getValue2(option);
  };
  const getGroupBy = (option) => getOptionProperty(option, props.groupBy);
  return {
    getValue: getValue2,
    getOptionByValue,
    getText,
    getDisabled,
    getTrackBy,
    getGroupBy
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-radio/VaRadio.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-radio/VaRadio.css";
var __defProp76 = Object.defineProperty;
var __defProps66 = Object.defineProperties;
var __getOwnPropDescs66 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols76 = Object.getOwnPropertySymbols;
var __hasOwnProp76 = Object.prototype.hasOwnProperty;
var __propIsEnum76 = Object.prototype.propertyIsEnumerable;
var __defNormalProp76 = (obj, key, value) => key in obj ? __defProp76(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues76 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp76.call(b2, prop))
      __defNormalProp76(a2, prop, b2[prop]);
  if (__getOwnPropSymbols76)
    for (var prop of __getOwnPropSymbols76(b2)) {
      if (__propIsEnum76.call(b2, prop))
        __defNormalProp76(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps66 = (a2, b2) => __defProps66(a2, __getOwnPropDescs66(b2));
var _sfc_main68 = defineComponent({
  name: "VaRadio",
  emits: ["update:modelValue", "focus"],
  props: __spreadProps66(__spreadValues76(__spreadValues76({}, useFormProps), useComponentPresetProp), {
    modelValue: { type: [Boolean, Array, String, Object, Number], default: null },
    option: { type: [String, Boolean, Object, Number], default: null },
    name: { type: String, default: "" },
    label: { type: String, default: "" },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    tabindex: { type: Number, default: 0 }
  }),
  setup(props, { emit }) {
    const { getColor } = useColors();
    const isActive = computed(() => props.modelValue === props.option);
    const { computedClasses } = useForm("va-radio", props);
    const computedClass = computed(() => __spreadValues76({
      "va-radio--left-label": props.leftLabel
    }, computedClasses));
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return {
        borderColor: getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return { borderColor: getColor(props.color) };
    });
    const computedLabel = computed(() => props.label || props.option);
    const onClick = (e2) => {
      if (props.readonly || props.disabled) {
        return;
      }
      emit("update:modelValue", props.option, e2);
    };
    const onFocus = (e2) => emit("focus", e2);
    return {
      computedClass,
      isActive,
      iconBackgroundComputedStyles,
      iconDotComputedStyles,
      iconComputedStyles,
      computedLabel,
      onClick,
      onFocus,
      computedName: computed(() => props.name || generateUniqueId()),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
var _hoisted_145 = ["checked", "disabled", "readonly", "name", "value", "aria-checked", "tabindex"];
var _hoisted_224 = { class: "va-radio__text" };
function _sfc_render67(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["va-radio", _ctx.computedClass])
  }, [
    createBaseVNode("input", {
      class: "va-radio__input",
      type: "radio",
      checked: _ctx.isActive,
      disabled: _ctx.$props.disabled,
      readonly: _ctx.$props.readonly,
      name: _ctx.computedName,
      value: _ctx.computedLabel,
      "aria-checked": _ctx.isActive,
      tabindex: _ctx.tabIndexComputed,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args))
    }, null, 40, _hoisted_145),
    createBaseVNode("span", {
      "aria-hidden": "true",
      class: "va-radio__icon",
      style: normalizeStyle(_ctx.iconComputedStyles)
    }, [
      createBaseVNode("span", {
        class: "va-radio__icon__background",
        style: normalizeStyle(_ctx.iconBackgroundComputedStyles)
      }, null, 4),
      createBaseVNode("span", {
        class: "va-radio__icon__dot",
        style: normalizeStyle(_ctx.iconDotComputedStyles)
      }, null, 4)
    ], 4),
    createBaseVNode("span", _hoisted_224, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.computedLabel), 1)
      ])
    ])
  ], 2);
}
var _VaRadio = _export_sfc(_sfc_main68, [["render", _sfc_render67]]);

// node_modules/vuestic-ui/dist/es/src/components/va-radio/index.js
var VaRadio = withConfigTransport(_VaRadio);

// node_modules/vuestic-ui/dist/es/src/components/va-switch/VaSwitch.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-switch/VaSwitch.css";
var __defProp77 = Object.defineProperty;
var __defProps67 = Object.defineProperties;
var __getOwnPropDescs67 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols77 = Object.getOwnPropertySymbols;
var __hasOwnProp77 = Object.prototype.hasOwnProperty;
var __propIsEnum77 = Object.prototype.propertyIsEnumerable;
var __defNormalProp77 = (obj, key, value) => key in obj ? __defProp77(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues77 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp77.call(b2, prop))
      __defNormalProp77(a2, prop, b2[prop]);
  if (__getOwnPropSymbols77)
    for (var prop of __getOwnPropSymbols77(b2)) {
      if (__propIsEnum77.call(b2, prop))
        __defNormalProp77(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps67 = (a2, b2) => __defProps67(a2, __getOwnPropDescs67(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp77.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols77)
    for (var prop of __getOwnPropSymbols77(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum77.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var _sfc_main69 = defineComponent({
  name: "VaSwitch",
  components: { VaProgressCircle, VaMessageListWrapper },
  emits: [
    ...useSelectableEmits,
    "focus",
    "blur",
    "update:modelValue"
  ],
  props: __spreadProps67(__spreadValues77(__spreadValues77({}, useSelectableProps), useComponentPresetProp), {
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    modelValue: {
      type: [Boolean, Array, String, Object],
      default: false
    },
    trueLabel: { type: String, default: null },
    falseLabel: { type: String, default: null },
    trueInnerLabel: { type: String, default: null },
    falseInnerLabel: { type: String, default: null },
    color: { type: String, default: "primary" },
    offColor: { type: String, default: "background-element" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  }),
  setup(props, { emit, slots }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const _a = useSelectable(props, emit, elements), {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes
    } = _a, selectable = __objRest(_a, [
      "isChecked",
      "computedError",
      "isIndeterminate",
      "computedErrorMessages",
      "validationAriaAttributes"
    ]);
    const computedBackground = computed(() => getColor(isChecked.value ? props.color : props.offColor));
    const { textColorComputed } = useTextColor(computedBackground);
    const computedInnerLabel = computed(() => {
      if (props.trueInnerLabel && isChecked.value) {
        return props.trueInnerLabel;
      }
      if (props.falseInnerLabel && !isChecked.value) {
        return props.falseInnerLabel;
      }
      return "";
    });
    const computedLabel = computed(() => {
      if (props.trueLabel && isChecked.value) {
        return props.trueLabel;
      }
      if (props.falseLabel && !isChecked.value) {
        return props.falseLabel;
      }
      return props.label;
    });
    const computedClass = useBem("va-switch", () => __spreadProps67(__spreadValues77({}, pick_1(props, ["readonly", "disabled", "leftLabel"])), {
      checked: isChecked.value,
      indeterminate: isIndeterminate.value,
      small: props.size === "small",
      large: props.size === "large",
      error: computedError.value,
      keyboardFocus: hasKeyboardFocus.value
    }));
    const styleComputed = computed(() => ({
      lineHeight: computedErrorMessages.value.length ? 1 : 0
    }));
    const progressCircleSize = computed(() => {
      const size = { small: "15px", medium: "20px", large: "25px" };
      return size[props.size];
    });
    const trackStyle = computed(() => ({
      borderColor: props.error ? getColor("danger") : "",
      backgroundColor: computedBackground.value
    }));
    const labelStyle = computed(() => ({
      color: props.error ? getColor("danger") : ""
    }));
    const trackLabelStyle = computed(() => ({
      color: textColorComputed.value
    }));
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const inputAttributesComputed = computed(() => __spreadValues77({
      id: props.id || void 0,
      name: props.name || void 0,
      disabled: props.disabled,
      readonly: props.readonly,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ariaChecked: !!props.modelValue,
      "aria-labelledby": computedLabel.value || slots.default ? ariaLabelIdComputed.value : void 0
    }, validationAriaAttributes.value));
    return __spreadProps67(__spreadValues77({}, selectable), {
      computedErrorMessages,
      isChecked,
      computedError,
      isIndeterminate,
      keyboardFocusListeners,
      computedInnerLabel,
      computedLabel,
      computedClass,
      styleComputed,
      progressCircleSize,
      trackStyle,
      labelStyle,
      trackLabelStyle,
      ariaLabelIdComputed,
      inputAttributesComputed
    });
  }
});
var _hoisted_146 = { class: "va-switch__checker-wrapper" };
var _hoisted_225 = { class: "va-switch__checker" };
var _hoisted_312 = ["id"];
function _sfc_render68(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_progress_circle = resolveComponent("va-progress-circle");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-switch", _ctx.computedClass]),
    style: normalizeStyle(_ctx.styleComputed),
    disabled: _ctx.$props.disabled,
    success: _ctx.$props.success,
    messages: _ctx.$props.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "container",
        class: "va-switch__container",
        tabindex: "-1",
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createBaseVNode("div", {
          class: "va-switch__inner",
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args))
        }, [
          createBaseVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-switch__input",
            role: "switch"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onKeypress: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]), ["enter"]))
          }), null, 16),
          createBaseVNode("div", {
            class: "va-switch__track",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.trackStyle)
          }, [
            _ctx.computedInnerLabel || _ctx.$slots.innerLabel ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-switch__track-label",
              style: normalizeStyle(_ctx.trackLabelStyle)
            }, [
              renderSlot(_ctx.$slots, "innerLabel", {}, () => [
                createTextVNode(toDisplayString(_ctx.computedInnerLabel), 1)
              ])
            ], 4)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_146, [
              createBaseVNode("span", _hoisted_225, [
                _ctx.$props.loading ? (openBlock(), createBlock(_component_va_progress_circle, {
                  key: 0,
                  indeterminate: "",
                  size: _ctx.progressCircleSize,
                  color: _ctx.trackStyle.backgroundColor
                }, null, 8, ["size", "color"])) : createCommentVNode("", true)
              ])
            ])
          ], 4)
        ]),
        _ctx.computedLabel || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "label",
          class: "va-switch__label",
          style: normalizeStyle(_ctx.labelStyle),
          id: _ctx.ariaLabelIdComputed,
          onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
          onClick: _cache[5] || (_cache[5] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
          onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["stop"]), ["enter"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.computedLabel), 1)
          ])
        ], 44, _hoisted_312)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "style", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
var _VaSwitch = _export_sfc(_sfc_main69, [["render", _sfc_render68]]);

// node_modules/vuestic-ui/dist/es/src/components/va-switch/index.js
var VaSwitch = withConfigTransport(_VaSwitch);

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/VaOptionList.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-option-list/VaOptionList.css";
var __defProp78 = Object.defineProperty;
var __defProps68 = Object.defineProperties;
var __getOwnPropDescs68 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols78 = Object.getOwnPropertySymbols;
var __hasOwnProp78 = Object.prototype.hasOwnProperty;
var __propIsEnum78 = Object.prototype.propertyIsEnumerable;
var __defNormalProp78 = (obj, key, value) => key in obj ? __defProp78(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues78 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp78.call(b2, prop))
      __defNormalProp78(a2, prop, b2[prop]);
  if (__getOwnPropSymbols78)
    for (var prop of __getOwnPropSymbols78(b2)) {
      if (__propIsEnum78.call(b2, prop))
        __defNormalProp78(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps68 = (a2, b2) => __defProps68(a2, __getOwnPropDescs68(b2));
var _sfc_main70 = defineComponent({
  name: "VaOptionList",
  components: {
    VaRadio,
    VaCheckbox,
    VaSwitch,
    VaMessageListWrapper
  },
  emits: [...useStatefulEmits],
  props: __spreadProps68(__spreadValues78(__spreadValues78(__spreadValues78(__spreadValues78({}, useComponentPresetProp), useSelectableListProps), useValidationProps), useStatefulProps), {
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Object, Array] }
  }),
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit, "modelValue", { defaultValue: props.defaultValue });
    const { getValue: getValue2, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue2(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue2) : [value ? getValue2(value) : value];
        }
      }
    });
    const getKey = (option) => getTrackBy(option);
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => withoutValidation(() => {
      valueComputed.value = null;
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const computedProps = computed(() => pick_1(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
    });
    return {
      selectedValue,
      computedError,
      computedErrorMessages,
      getValue: getValue2,
      getText,
      getKey,
      isDisabled,
      reset,
      focus,
      setItemRef,
      computedProps
    };
  }
});
var _hoisted_147 = { class: "va-option-list__list" };
function _sfc_render69(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_radio = resolveComponent("va-radio");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_switch = resolveComponent("va-switch");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.$props.errorCount
  }, {
    default: withCtx(() => [
      createBaseVNode("ul", _hoisted_147, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
          return openBlock(), createElementBlock("li", {
            key: _ctx.getKey(option)
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ option, selectedValue: _ctx.selectedValue, isDisabled: _ctx.isDisabled, getText: _ctx.getText, getValue: _ctx.getValue })), () => [
              _ctx.$props.type === "radio" ? (openBlock(), createBlock(_component_va_radio, mergeProps({
                key: 0,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                option: _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock(), createBlock(_component_va_checkbox, mergeProps({
                key: 1,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock(), createBlock(_component_va_switch, mergeProps({
                key: 2,
                ref_for: true,
                ref: _ctx.setItemRef,
                modelValue: _ctx.selectedValue,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.selectedValue = $event),
                label: _ctx.getText(option),
                disabled: _ctx.isDisabled(option),
                "array-value": _ctx.getValue(option)
              }, _ctx.computedProps), null, 16, ["modelValue", "label", "disabled", "array-value"]))
            ])
          ]);
        }), 128))
      ])
    ]),
    _: 3
  }, 8, ["error", "error-messages", "error-count"]);
}
var _VaOptionList = _export_sfc(_sfc_main70, [["render", _sfc_render69]]);

// node_modules/vuestic-ui/dist/es/src/components/va-option-list/index.js
var VaOptionList = withConfigTransport(_VaOptionList);

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/VaPagination.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/setPaginationRange.js
var setPaginationRange = (currentPage = 1, visiblePages, pages, includeBoundary = false) => {
  let start = 0;
  if (pages === 0) {
    pages = 1;
  }
  if (visiblePages > pages) {
    visiblePages = pages;
  }
  if (visiblePages === 0) {
    start = 1;
    visiblePages = pages > 10 ? 10 : pages;
  } else {
    const paginationMiddlePage = visiblePages / 2;
    if (currentPage - paginationMiddlePage <= 0 || currentPage > pages) {
      start = 1;
    } else {
      start = currentPage + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(currentPage - paginationMiddlePage);
    }
  }
  const range = [];
  for (let i2 = 0; i2 < visiblePages; i2++) {
    range.push(start + i2);
  }
  if (includeBoundary && visiblePages < 7)
    ;
  else if (includeBoundary) {
    start !== 1 && range.splice(0, 2, 1, "...");
    range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
  }
  return range;
};

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/VaPagination.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-pagination/VaPagination.css";
var __defProp79 = Object.defineProperty;
var __defProps69 = Object.defineProperties;
var __getOwnPropDescs69 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols79 = Object.getOwnPropertySymbols;
var __hasOwnProp79 = Object.prototype.hasOwnProperty;
var __propIsEnum79 = Object.prototype.propertyIsEnumerable;
var __defNormalProp79 = (obj, key, value) => key in obj ? __defProp79(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues79 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp79.call(b2, prop))
      __defNormalProp79(a2, prop, b2[prop]);
  if (__getOwnPropSymbols79)
    for (var prop of __getOwnPropSymbols79(b2)) {
      if (__propIsEnum79.call(b2, prop))
        __defNormalProp79(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps69 = (a2, b2) => __defProps69(a2, __getOwnPropDescs69(b2));
var _sfc_main71 = defineComponent({
  name: "VaPagination",
  components: { VaButton: VaButton2 },
  emits: useStatefulEmits,
  props: __spreadProps69(__spreadValues79(__spreadValues79({}, useStatefulProps), useComponentPresetProp), {
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: Number, default: 0 },
    pages: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v2) => ["medium", "small", "large"].includes(v2)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    total: { type: Number, default: null },
    pageSize: { type: Number, default: null },
    boundaryIconLeft: { type: String, default: "va-arrow-first" },
    boundaryIconRight: { type: String, default: "va-arrow-last" },
    directionIconLeft: { type: String, default: "va-arrow-left" },
    directionIconRight: { type: String, default: "va-arrow-right" },
    gapped: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    rounded: { type: Boolean, default: false },
    activePageColor: { type: String, default: "" },
    buttonsPreset: { type: String, default: "primary" }
  }),
  setup(props, { emit }) {
    const htmlInput = shallowRef();
    const inputValue = ref("");
    const usesTotal = computed(() => !!((props.total || props.total === 0) && props.pageSize));
    const { valueComputed } = useStateful(props, emit);
    const currentValue = computed({
      get: () => usesTotal.value ? Math.ceil(valueComputed.value / props.pageSize) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const paginationRange = computed(() => {
      const { visiblePages, total, pageSize, boundaryNumbers, pages } = props;
      const value = currentValue.value || 1;
      const totalPages = usesTotal.value ? Math.ceil(total / pageSize) : pages;
      return setPaginationRange(value, visiblePages, totalPages, boundaryNumbers);
    });
    const lastPage = computed(() => usesTotal.value ? Math.ceil(props.total / props.pageSize) || 1 : +props.pages);
    const isLastPageNotVisible = computed(() => !!props.visiblePages && lastPage.value > props.visiblePages || props.input);
    const showBoundaryLinks = computed(() => {
      const { boundaryLinks, boundaryNumbers } = props;
      return isLastPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed(() => isLastPageNotVisible.value && props.directionLinks);
    const showPagination = computed(() => lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = String(currentValue.value);
      nextTick(() => {
        var _a;
        return (_a = htmlInput.value) == null ? void 0 : _a.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const { setItemRefByIndex, itemRefs } = useArrayRefs();
    const onUserInput = (pageNum) => {
      var _a;
      if (pageNum === "..." || pageNum === currentValue.value) {
        return;
      }
      const limitedPageNum = clamp_1(pageNum, 1, lastPage.value);
      currentValue.value = usesTotal.value ? (limitedPageNum - 1) * props.pageSize + 1 : limitedPageNum;
      (_a = itemRefs.value[pageNum - 1]) == null ? void 0 : _a.focus();
    };
    const resetInput = () => {
      var _a;
      inputValue.value = "";
      (_a = htmlInput.value) == null ? void 0 : _a.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor, colorToRgba: colorToRgba2 } = useColors();
    const inputBorderColorComputed = computed(() => {
      const { color, buttonsPreset } = toRefs(props);
      if (!color.value) {
        return "transparent";
      }
      switch (buttonsPreset.value) {
        case "default":
          return getColor(color.value);
        case void 0:
        case "primary":
          return colorToRgba2(getColor(color.value), 0.1);
        default:
          return "transparent";
      }
    });
    const inputStyleComputed = computed(() => ({
      cursor: "default",
      color: getColor(props.color),
      opacity: props.disabled ? 0.4 : 1,
      borderColor: inputBorderColorComputed.value
    }));
    watch([usesTotal, () => props.pages], () => {
    });
    const inputAttributesComputed = computed(() => ({
      disabled: props.disabled,
      placeholder: `${currentValue.value}/${lastPage.value}`
    }));
    const buttonPropsComputed = computed(() => ({
      size: props.size,
      preset: props.buttonsPreset,
      color: props.color,
      borderColor: props.borderColor
    }));
    const currentPageButtonProps = computed(() => ({
      preset: props.buttonsPreset === "default" ? "primary" : "default",
      color: props.activePageColor || props.color
    }));
    const getPageButtonProps = (n2) => {
      if (!isNaN(+n2) && n2 === currentValue.value) {
        return Object.assign({}, buttonPropsComputed.value, currentPageButtonProps.value);
      }
      return buttonPropsComputed.value;
    };
    const inputClassComputed = useBem("va-pagination__input", () => ({
      sm: props.size === "small",
      md: props.size === "medium",
      lg: props.size === "large"
    }));
    const classComputed = useBem("va-pagination", () => __spreadProps69(__spreadValues79({}, pick_1(props, ["gapped", "rounded", "disabled"])), {
      bordered: !!props.borderColor
    }));
    const goNextPage = () => onUserInput(currentValue.value + 1);
    const goPrevPage = () => onUserInput(currentValue.value - 1);
    return __spreadProps69(__spreadValues79({}, useTranslation()), {
      getPageButtonProps,
      inputClassComputed,
      classComputed,
      currentValue,
      lastPage,
      changeValue,
      inputValue,
      showPagination,
      showBoundaryLinks,
      onUserInput,
      showDirectionLinks,
      paginationRange,
      focusInput,
      inputStyleComputed,
      inputAttributesComputed,
      goNextPage,
      goPrevPage,
      buttonPropsComputed,
      htmlInput,
      setItemRefByIndex
    });
  }
});
var _hoisted_148 = ["aria-label"];
var _hoisted_226 = ["aria-label"];
function _sfc_render70(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  return _ctx.showPagination ? (openBlock(), createElementBlock("nav", {
    key: 0,
    class: normalizeClass(["va-pagination", _ctx.classComputed]),
    "aria-label": _ctx.t("pagination"),
    onKeydown: [
      _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.goPrevPage && _ctx.goPrevPage(...args), ["stop"]), ["left"])),
      _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.goNextPage && _ctx.goNextPage(...args), ["stop"]), ["right"])),
      _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.goPrevPage && _ctx.goPrevPage(...args), ["stop"]), ["up"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.goNextPage && _ctx.goNextPage(...args), ["stop"]), ["down"]))
    ]
  }, [
    _ctx.showBoundaryLinks ? renderSlot(_ctx.$slots, "firstPageLink", normalizeProps(mergeProps({ key: 0 }, { onClick: () => _ctx.onUserInput(1), disabled: _ctx.$props.disabled || _ctx.currentValue === 1 })), () => [
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.t("goToTheFirstPage"),
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.boundaryIconLeft
      }, _ctx.buttonPropsComputed, {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onUserInput(1))
      }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    _ctx.showDirectionLinks ? renderSlot(_ctx.$slots, "prevPageLink", normalizeProps(mergeProps({ key: 1 }, { onClick: _ctx.goPrevPage, disabled: _ctx.$props.disabled || _ctx.currentValue === 1 })), () => [
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.t("goToPreviousPage"),
        disabled: _ctx.$props.disabled || _ctx.currentValue === 1,
        icon: _ctx.$props.directionIconLeft
      }, _ctx.buttonPropsComputed, { onClick: _ctx.goPrevPage }), null, 16, ["aria-label", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    !_ctx.$props.input ? renderSlot(_ctx.$slots, "default", { key: 2 }, () => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.paginationRange, (n2, i2) => {
        return openBlock(), createBlock(_component_va_button, mergeProps({
          key: i2,
          ref_for: true,
          ref: _ctx.setItemRefByIndex(i2),
          class: { "va-button--ellipsis": n2 === "...", "va-button--current": n2 === _ctx.currentValue },
          "aria-label": _ctx.t(`goToSpecificPage`, { page: n2 }),
          "aria-current": n2 === _ctx.currentValue,
          disabled: _ctx.$props.disabled || n2 === "..."
        }, _ctx.getPageButtonProps(n2), {
          onClick: ($event) => _ctx.onUserInput(n2)
        }), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(n2), 1)
          ]),
          _: 2
        }, 1040, ["class", "aria-label", "aria-current", "disabled", "onClick"]);
      }), 128))
    ]) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
      key: 3,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.inputValue = $event),
      ref: "htmlInput",
      class: ["va-pagination__input va-button", _ctx.inputClassComputed],
      "aria-label": _ctx.t("goToSpecificPageInput"),
      style: _ctx.inputStyleComputed
    }, _ctx.inputAttributesComputed, {
      onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.changeValue && _ctx.changeValue(...args), ["enter"])),
      onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.focusInput && _ctx.focusInput(...args)),
      onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.changeValue && _ctx.changeValue(...args))
    }), null, 16, _hoisted_226)), [
      [vModelDynamic, _ctx.inputValue]
    ]),
    _ctx.showDirectionLinks ? renderSlot(_ctx.$slots, "nextPageLink", normalizeProps(mergeProps({ key: 4 }, { onClick: _ctx.goNextPage, disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage })), () => [
      _ctx.showDirectionLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.t("goNextPage"),
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.directionIconRight
      }, _ctx.buttonPropsComputed, { onClick: _ctx.goNextPage }), null, 16, ["aria-label", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true),
    _ctx.showBoundaryLinks ? renderSlot(_ctx.$slots, "lastPageLink", normalizeProps(mergeProps({ key: 5 }, { onClick: () => _ctx.onUserInput(_ctx.lastPage), disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage })), () => [
      _ctx.showBoundaryLinks ? (openBlock(), createBlock(_component_va_button, mergeProps({
        key: 0,
        "aria-label": _ctx.t("goLastPage"),
        disabled: _ctx.$props.disabled || _ctx.currentValue === _ctx.lastPage,
        icon: _ctx.$props.boundaryIconRight
      }, _ctx.buttonPropsComputed, {
        onClick: _cache[5] || (_cache[5] = ($event) => _ctx.onUserInput(_ctx.lastPage))
      }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
    ]) : createCommentVNode("", true)
  ], 42, _hoisted_148)) : createCommentVNode("", true);
}
var _VaPagination = _export_sfc(_sfc_main71, [["render", _sfc_render70]]);

// node_modules/vuestic-ui/dist/es/src/components/va-pagination/index.js
var VaPagination = withConfigTransport(_VaPagination);

// node_modules/vuestic-ui/dist/es/src/components/va-parallax/VaParallax.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-parallax/VaParallax.css";
var __defProp80 = Object.defineProperty;
var __defProps70 = Object.defineProperties;
var __getOwnPropDescs70 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols80 = Object.getOwnPropertySymbols;
var __hasOwnProp80 = Object.prototype.hasOwnProperty;
var __propIsEnum80 = Object.prototype.propertyIsEnumerable;
var __defNormalProp80 = (obj, key, value) => key in obj ? __defProp80(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues80 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp80.call(b2, prop))
      __defNormalProp80(a2, prop, b2[prop]);
  if (__getOwnPropSymbols80)
    for (var prop of __getOwnPropSymbols80(b2)) {
      if (__propIsEnum80.call(b2, prop))
        __defNormalProp80(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps70 = (a2, b2) => __defProps70(a2, __getOwnPropDescs70(b2));
var _sfc_main72 = defineComponent({
  name: "VaParallax",
  props: __spreadProps70(__spreadValues80({}, useComponentPresetProp), {
    target: { type: [Object, String] },
    src: { type: String, default: "", required: true },
    alt: { type: String, default: "parallax" },
    height: { type: Number, default: 400 },
    reversed: { type: Boolean, default: false },
    speed: {
      type: Number,
      default: 0.5,
      validator: (value) => value >= 0 && value <= 1
    }
  }),
  setup(props) {
    const rootElement = shallowRef();
    const img = shallowRef();
    const elOffsetTop = ref(0);
    const parallax = ref(0);
    const parallaxDist = ref(0);
    const percentScrolled = ref(0);
    const scrollTop = ref(0);
    const windowHeight = ref(0);
    const windowBottom = ref(0);
    const isLoaded = ref(false);
    const computedWrapperStyles = computed(() => ({ height: props.height + "px" }));
    const computedImgStyles = computed(() => ({
      display: "block",
      transform: `translate(-50%, ${parallax.value}px)`,
      opacity: isLoaded.value ? 1 : 0,
      top: props.reversed ? 0 : "auto"
    }));
    const targetElement = computed(() => {
      var _a;
      if (!props.target) {
        return getScrollableParent((_a = rootElement.value) == null ? void 0 : _a.parentElement);
      }
      if (props.target instanceof HTMLElement) {
        return props.target;
      }
      const element = document.querySelector(props.target);
      if (element) {
        return element;
      }
      return null;
    });
    const getScrollableParent = (element) => {
      if (!element) {
        return document.body;
      }
      if (element.scrollHeight > element.clientHeight) {
        return element;
      }
      return getScrollableParent(element.parentElement);
    };
    const imgHeight = computed(() => {
      var _a;
      return ((_a = img.value) == null ? void 0 : _a.naturalHeight) || 0;
    });
    const calcDimensions = () => {
      var _a, _b;
      const offset = ((_a = rootElement.value) == null ? void 0 : _a.getBoundingClientRect()) || { top: 0 };
      scrollTop.value = ((_b = targetElement.value) == null ? void 0 : _b.scrollTop) || 0;
      parallaxDist.value = imgHeight.value - props.height;
      elOffsetTop.value = offset.top + scrollTop.value;
      windowHeight.value = window.innerHeight;
      windowBottom.value = scrollTop.value + windowHeight.value;
    };
    const translate = () => {
      calcDimensions();
      percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (props.height + windowHeight.value);
      parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * props.speed;
      if (props.reversed) {
        parallax.value = -parallax.value;
      }
    };
    const addEventListeners = () => {
      var _a, _b;
      (_a = targetElement.value) == null ? void 0 : _a.addEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.addEventListener("resize", translate);
    };
    const removeEventListeners = () => {
      var _a, _b;
      (_a = targetElement.value) == null ? void 0 : _a.removeEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.removeEventListener("resize", translate);
    };
    const initImage = () => {
      var _a, _b;
      if ((_a = img.value) == null ? void 0 : _a.complete) {
        translate();
        addEventListeners();
      } else {
        (_b = img.value) == null ? void 0 : _b.addEventListener("load", () => {
          translate();
          addEventListeners();
        }, false);
      }
      isLoaded.value = true;
    };
    onMounted(initImage);
    onBeforeUnmount(removeEventListeners);
    return {
      img,
      rootElement,
      computedWrapperStyles,
      computedImgStyles
    };
  }
});
var _hoisted_149 = { class: "va-parallax__image-container" };
var _hoisted_227 = ["src", "alt"];
var _hoisted_313 = { class: "va-parallax__item-container" };
function _sfc_render71(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    class: "va-parallax",
    style: normalizeStyle(_ctx.computedWrapperStyles)
  }, [
    createBaseVNode("div", _hoisted_149, [
      createBaseVNode("img", {
        ref: "img",
        class: "va-parallax__image",
        src: _ctx.$props.src,
        alt: _ctx.$props.alt,
        style: normalizeStyle(_ctx.computedImgStyles)
      }, null, 12, _hoisted_227)
    ]),
    createBaseVNode("div", _hoisted_313, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 4);
}
var _VaParallax = _export_sfc(_sfc_main72, [["render", _sfc_render71]]);

// node_modules/vuestic-ui/dist/es/src/components/va-parallax/index.js
var VaParallax = withConfigTransport(_VaParallax);

// node_modules/vuestic-ui/dist/es/src/components/va-popover/VaPopover.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-popover/VaPopover.css";
var __defProp81 = Object.defineProperty;
var __defProps71 = Object.defineProperties;
var __getOwnPropDescs71 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols81 = Object.getOwnPropertySymbols;
var __hasOwnProp81 = Object.prototype.hasOwnProperty;
var __propIsEnum81 = Object.prototype.propertyIsEnumerable;
var __defNormalProp81 = (obj, key, value) => key in obj ? __defProp81(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues81 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp81.call(b2, prop))
      __defNormalProp81(a2, prop, b2[prop]);
  if (__getOwnPropSymbols81)
    for (var prop of __getOwnPropSymbols81(b2)) {
      if (__propIsEnum81.call(b2, prop))
        __defNormalProp81(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps71 = (a2, b2) => __defProps71(a2, __getOwnPropDescs71(b2));
var VaDropdownProps3 = extractComponentProps(VaDropdown, ["closeOnClickOutside"]);
var _sfc_main73 = defineComponent({
  name: "VaPopover",
  components: { VaDropdown, VaIcon: VaIcon2 },
  props: __spreadProps71(__spreadValues81(__spreadValues81({}, VaDropdownProps3), useComponentPresetProp), {
    trigger: { default: "hover" },
    color: { type: String, default: "#1b1a1f" },
    textColor: { type: String },
    icon: { type: String, default: "" },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    autoHide: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 4 }
  }),
  setup(props, { slots }) {
    const VaDropdownPropValues = filterComponentProps(props, VaDropdownProps3);
    const { getColor, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const { textColorComputed } = useTextColor();
    const showIconComputed = computed(() => props.icon || slots.icon);
    const showTitleComputed = computed(() => props.title || slots.title);
    const showBodyComputed = computed(() => props.message || slots.body);
    const showPopoverContentComputed = computed(() => showTitleComputed.value || showBodyComputed.value);
    const computedPopoverStyle = computed(() => ({
      boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor2(getColor(props.color))}`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    return {
      textColorComputed,
      VaDropdownPropValues,
      showBodyComputed,
      showIconComputed,
      showTitleComputed,
      computedPopoverStyle,
      showPopoverContentComputed
    };
  }
});
var _hoisted_150 = {
  key: 0,
  "aria-hidden": "true",
  class: "va-popover__icon"
};
var _hoisted_228 = { key: 1 };
var _hoisted_314 = {
  key: 0,
  class: "va-popover__title"
};
var _hoisted_49 = {
  key: 1,
  class: "va-popover__body"
};
function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps(_ctx.VaDropdownPropValues, {
    "model-value": _ctx.modelValue,
    "close-on-click-outside": _ctx.autoHide,
    offset: _ctx.$props.offset,
    class: "va-popover"
  }), {
    default: withCtx(() => [
      createBaseVNode("div", {
        style: normalizeStyle(_ctx.computedPopoverStyle),
        class: "va-popover__content",
        role: "tooltip"
      }, [
        _ctx.showIconComputed ? (openBlock(), createElementBlock("div", _hoisted_150, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_va_icon, {
              name: _ctx.$props.icon,
              color: _ctx.textColorComputed
            }, null, 8, ["name", "color"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.showPopoverContentComputed ? (openBlock(), createElementBlock("div", _hoisted_228, [
          _ctx.showTitleComputed ? (openBlock(), createElementBlock("div", _hoisted_314, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.title), 1)
            ])
          ])) : createCommentVNode("", true),
          _ctx.showBodyComputed ? (openBlock(), createElementBlock("div", _hoisted_49, [
            renderSlot(_ctx.$slots, "body", {}, () => [
              createTextVNode(toDisplayString(_ctx.$props.message), 1)
            ])
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 4)
    ]),
    anchor: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["model-value", "close-on-click-outside", "offset"]);
}
var _VaPopover = _export_sfc(_sfc_main73, [["render", _sfc_render72]]);

// node_modules/vuestic-ui/dist/es/src/components/va-popover/index.js
var VaPopover = withConfigTransport(_VaPopover);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/VaRating.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-rating/hooks/useRating.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-rating/types.js
var RatingValue = ((RatingValue2) => {
  RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
  RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
  RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
  return RatingValue2;
})(RatingValue || {});

// node_modules/vuestic-ui/dist/es/src/components/va-rating/hooks/useRating.js
var __defProp82 = Object.defineProperty;
var __defProps72 = Object.defineProperties;
var __getOwnPropDescs72 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols82 = Object.getOwnPropertySymbols;
var __hasOwnProp82 = Object.prototype.hasOwnProperty;
var __propIsEnum82 = Object.prototype.propertyIsEnumerable;
var __defNormalProp82 = (obj, key, value) => key in obj ? __defProp82(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues82 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp82.call(b2, prop))
      __defNormalProp82(a2, prop, b2[prop]);
  if (__getOwnPropSymbols82)
    for (var prop of __getOwnPropSymbols82(b2)) {
      if (__propIsEnum82.call(b2, prop))
        __defNormalProp82(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps72 = (a2, b2) => __defProps72(a2, __getOwnPropDescs72(b2));
var getContext = () => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useRating hooks must be used on top of setup function");
  }
  return {
    props: instance.props,
    emit: instance.emit
  };
};
var useRatingProps = __spreadProps72(__spreadValues82({}, useStatefulProps), {
  modelValue: { type: Number, default: 0 },
  clearable: { type: Boolean, default: false },
  hover: { type: Boolean, default: false }
});
var useRating = (props) => {
  const { emit } = getContext();
  const { isHovered, onMouseEnter, onMouseLeave } = useHover();
  const { valueComputed: modelValue } = useStateful(props, emit);
  const hoveredValue = ref(0);
  const visibleValue = computed(() => !props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
  const onItemValueUpdate = (itemIndex, newValue) => {
    const newModelValue = itemIndex + newValue;
    if (props.clearable) {
      if (modelValue.value === newModelValue) {
        modelValue.value = 0;
        return;
      }
    }
    modelValue.value = newModelValue;
  };
  const onItemHoveredValueUpdate = (itemIndex, newValue) => {
    if (!props.hover) {
      return;
    }
    hoveredValue.value = itemIndex + newValue;
  };
  const getItemValue = (itemIndex) => {
    const itemValue = visibleValue.value - itemIndex;
    return clamp_1(itemValue, RatingValue.EMPTY, RatingValue.FULL);
  };
  return {
    visibleValue,
    modelValue,
    hoveredValue,
    isHovered,
    onMouseEnter,
    onMouseLeave,
    onItemValueUpdate,
    onItemHoveredValueUpdate,
    getItemValue
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/hooks/useVaRatingColors.js
init_vue_runtime_esm_bundler();
var useVaRatingColorsProps = {
  unselectedColor: { type: String },
  color: { type: String, default: "primary" },
  modelValue: { type: Number }
};
var useVaRatingColors = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getTextColor } = useColors();
  const computedColor = computed(() => getColor(props.color));
  const backgroundColor = computed(() => {
    if (props.unselectedColor) {
      return getColor(props.unselectedColor);
    }
    return getFocusColor2(getColor(props.color));
  });
  const backgroundComputed = computed(() => {
    if (props.modelValue === RatingValue.HALF) {
      return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
    }
    if (props.modelValue === RatingValue.EMPTY) {
      return backgroundColor.value;
    }
    return computedColor.value;
  });
  const textColorComputed = computed(() => {
    if (props.modelValue === RatingValue.FULL) {
      return getTextColor(computedColor.value);
    }
    return getTextColor(backgroundColor.value);
  });
  return {
    computedColor,
    backgroundComputed,
    textColorComputed
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItem/VaRatingItem.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItem/VaRatingItem.css";
var _sfc_main74 = defineComponent({
  name: "VaRatingItem",
  components: { VaIcon: VaIcon2 },
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(props, { emit }) {
    const rootEl = shallowRef();
    const [modelValue] = useSyncProp("modelValue", props, emit, RatingValue.EMPTY);
    const hoveredValue = ref(null);
    const visibleValue = computed(() => {
      if (props.hover && !props.disabled && !props.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed(() => getColor(props.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props.unselectedColor : props.color));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onEnter = () => {
      modelValue.value = 1;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit("click", hoveredValue.value || RatingValue.FULL);
    };
    watch(hoveredValue, () => emit("hover", hoveredValue.value || RatingValue.EMPTY));
    return {
      computedColor,
      rootEl,
      onEnter,
      onClick,
      onMouseMove,
      onMouseLeave,
      visibleValue,
      computedIconName: computed(() => {
        if (props.halves && visibleValue.value === RatingValue.HALF) {
          return props.halfIcon;
        }
        if (visibleValue.value === RatingValue.EMPTY) {
          return props.emptyIcon;
        }
        return props.icon;
      }),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
var _hoisted_151 = ["tabindex"];
function _sfc_render73(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    ref: "rootEl",
    role: "button",
    class: "va-rating-item",
    tabindex: _ctx.tabIndexComputed,
    onKeyup: [
      _cache[0] || (_cache[0] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["enter"])),
      _cache[1] || (_cache[1] = withKeys((...args) => _ctx.onClick && _ctx.onClick(...args), ["space"]))
    ],
    onMousemove: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseMove && _ctx.onMouseMove(...args)),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps({ value: _ctx.visibleValue, onClick: _ctx.onClick })), () => [
      createVNode(_component_va_icon, {
        class: "va-rating-item__wrapper",
        tabindex: "-1",
        tag: "button",
        name: _ctx.computedIconName,
        size: _ctx.$props.size,
        color: _ctx.computedColor,
        onClick: _ctx.onClick
      }, null, 8, ["name", "size", "color", "onClick"])
    ])
  ], 40, _hoisted_151);
}
var _VaRatingItem = _export_sfc(_sfc_main74, [["render", _sfc_render73]]);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItemNumberButton.js
init_vue_runtime_esm_bundler();
var __defProp83 = Object.defineProperty;
var __defProps73 = Object.defineProperties;
var __getOwnPropDescs73 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols83 = Object.getOwnPropertySymbols;
var __hasOwnProp83 = Object.prototype.hasOwnProperty;
var __propIsEnum83 = Object.prototype.propertyIsEnumerable;
var __defNormalProp83 = (obj, key, value) => key in obj ? __defProp83(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues83 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp83.call(b2, prop))
      __defNormalProp83(a2, prop, b2[prop]);
  if (__getOwnPropSymbols83)
    for (var prop of __getOwnPropSymbols83(b2)) {
      if (__propIsEnum83.call(b2, prop))
        __defNormalProp83(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps73 = (a2, b2) => __defProps73(a2, __getOwnPropDescs73(b2));
var _sfc_main75 = defineComponent({
  name: "VaRatingItemNumberButton",
  props: __spreadProps73(__spreadValues83(__spreadValues83({}, useVaRatingColorsProps), useSizeProps), {
    itemNumber: { type: Number, required: true },
    modelValue: { type: Number, required: true }
  }),
  setup(props) {
    return __spreadValues83(__spreadValues83({}, useVaRatingColors(props)), useSize(props, "VaRating"));
  }
});
function _sfc_render74(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: "va-rating__number-item",
    tabindex: "-1",
    "aria-hidden": "true",
    style: normalizeStyle({
      background: _ctx.backgroundComputed,
      color: _ctx.textColorComputed,
      width: _ctx.sizeComputed,
      height: _ctx.sizeComputed,
      fontSize: _ctx.fontSizeComputed,
      borderRadius: `${parseInt(_ctx.fontSizeComputed) * 0.125}rem`
    })
  }, toDisplayString(_ctx.itemNumber), 5);
}
var VaRatingItemNumberButton = _export_sfc(_sfc_main75, [["render", _sfc_render74]]);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/VaRating.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-rating/VaRating.css";
var __defProp84 = Object.defineProperty;
var __defProps74 = Object.defineProperties;
var __getOwnPropDescs74 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols84 = Object.getOwnPropertySymbols;
var __hasOwnProp84 = Object.prototype.hasOwnProperty;
var __propIsEnum84 = Object.prototype.propertyIsEnumerable;
var __defNormalProp84 = (obj, key, value) => key in obj ? __defProp84(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues84 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp84.call(b2, prop))
      __defNormalProp84(a2, prop, b2[prop]);
  if (__getOwnPropSymbols84)
    for (var prop of __getOwnPropSymbols84(b2)) {
      if (__propIsEnum84.call(b2, prop))
        __defNormalProp84(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps74 = (a2, b2) => __defProps74(a2, __getOwnPropDescs74(b2));
var VaRatingItemProps = extractComponentProps(_VaRatingItem);
var VaRatingItemNumberButtonProps = extractComponentProps(VaRatingItemNumberButton, ["modelValue", "itemNumber"]);
var _sfc_main76 = defineComponent({
  name: "VaRating",
  props: __spreadProps74(__spreadValues84(__spreadValues84(__spreadValues84(__spreadValues84(__spreadValues84(__spreadValues84({}, useRatingProps), useVaRatingColorsProps), useFormProps), VaRatingItemProps), VaRatingItemNumberButtonProps), useComponentPresetProp), {
    numbers: { type: Boolean, default: false },
    halves: { type: Boolean, default: false },
    max: { type: Number, default: 5 },
    texts: { type: Array, default: () => [] }
  }),
  emits: ["update:modelValue"],
  components: { VaRatingItem: _VaRatingItem, VaRatingItemNumberButton },
  setup(props) {
    const { computedClasses: rootClass } = useForm("va-rating", props);
    const rating = useRating(props);
    const isInteractionsEnabled = computed(() => !props.disabled && !props.readonly);
    return __spreadProps74(__spreadValues84(__spreadValues84(__spreadValues84({}, useTranslation()), useVaRatingColors(props)), rating), {
      rootClass,
      VaRatingItemProps: filterComponentProps(props, VaRatingItemProps),
      VaRatingItemNumberButtonProps: filterComponentProps(props, VaRatingItemNumberButtonProps),
      isInteractionsEnabled,
      tabIndexComputed: computed(() => isInteractionsEnabled.value ? 0 : void 0),
      onArrowKeyPress: (direction) => {
        const step = props.halves ? RatingValue.HALF : RatingValue.FULL;
        rating.onItemValueUpdate(rating.visibleValue.value, step * direction);
      }
    });
  }
});
var _hoisted_153 = ["aria-label"];
function _sfc_render75(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaRatingItemNumberButton = resolveComponent("VaRatingItemNumberButton");
  const _component_va_rating_item = resolveComponent("va-rating-item");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-rating", _ctx.rootClass]),
    "aria-label": _ctx.t("currentRating", { max: _ctx.$props.max, value: _ctx.$props.modelValue })
  }, [
    createBaseVNode("div", {
      class: "va-rating__item-wrapper",
      onKeyup: [
        _cache[0] || (_cache[0] = withKeys(($event) => _ctx.onArrowKeyPress(-1), ["left"])),
        _cache[1] || (_cache[1] = withKeys(($event) => _ctx.onArrowKeyPress(1), ["right"]))
      ],
      onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.max, (itemNumber) => {
        return openBlock(), createBlock(_component_va_rating_item, mergeProps({
          key: itemNumber,
          class: "va-rating__item"
        }, _ctx.VaRatingItemProps, {
          "aria-label": _ctx.t("voteRating", { max: _ctx.$props.max, value: _ctx.$props.modelValue }),
          "model-value": _ctx.getItemValue(itemNumber - 1),
          tabindex: _ctx.tabIndexComputed,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onHover: ($event) => _ctx.isInteractionsEnabled && _ctx.onItemHoveredValueUpdate(itemNumber - 1, $event),
          "onUpdate:modelValue": ($event) => _ctx.isInteractionsEnabled && _ctx.onItemValueUpdate(itemNumber - 1, $event)
        }), {
          default: withCtx(({ value, onClick }) => [
            renderSlot(_ctx.$slots, "item", normalizeProps(guardReactiveProps({ value, onClick, index: itemNumber })), () => [
              _ctx.$props.numbers ? (openBlock(), createBlock(_component_VaRatingItemNumberButton, mergeProps({ key: 0 }, _ctx.VaRatingItemNumberButtonProps, {
                "model-value": value,
                "item-number": itemNumber
              }), null, 16, ["model-value", "item-number"])) : createCommentVNode("", true)
            ])
          ]),
          _: 2
        }, 1040, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]);
      }), 128))
    ], 32),
    _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "va-rating__text-wrapper",
      style: normalizeStyle({ color: _ctx.computedColor })
    }, toDisplayString(_ctx.$props.texts[Math.round(_ctx.visibleValue) - 1]), 5)) : createCommentVNode("", true)
  ], 10, _hoisted_153);
}
var _VaRating = _export_sfc(_sfc_main76, [["render", _sfc_render75]]);

// node_modules/vuestic-ui/dist/es/src/components/va-rating/index.js
var VaRating = withConfigTransport(_VaRating);

// node_modules/vuestic-ui/dist/es/src/components/va-select/VaSelect.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useMaxSelections.js
var useMaxSelectionsProps = {
  maxSelections: {
    type: [Number, String],
    default: void 0
  }
};
function useMaxSelections(selections, maxSelections) {
  const exceedsMaxSelections = () => {
    if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) {
      return false;
    }
    return selections.value.length >= maxSelections.value;
  };
  const addOption = (optionToAdd) => {
    return [...selections.value, optionToAdd];
  };
  return {
    exceedsMaxSelections,
    addOption
  };
}

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/composables/useObjectRefs.js
init_vue_runtime_esm_bundler();
var useObjectRefs = () => {
  const itemRefs = shallowRef({});
  const setItemRef = (key) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[key] = el;
    return String(key);
  };
  onBeforeUpdate(() => {
    itemRefs.value = {};
  });
  return { itemRefs, setItemRef };
};

// node_modules/vuestic-ui/dist/es/src/utils/scroll-to-element.js
var getTopCoordinate = (element) => element.offsetTop;
var getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
var getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
var getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
var scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOption/VaSelectOption.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOption/VaSelectOption.css";
var __defProp85 = Object.defineProperty;
var __defProps75 = Object.defineProperties;
var __getOwnPropDescs75 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols85 = Object.getOwnPropertySymbols;
var __hasOwnProp85 = Object.prototype.hasOwnProperty;
var __propIsEnum85 = Object.prototype.propertyIsEnumerable;
var __defNormalProp85 = (obj, key, value) => key in obj ? __defProp85(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues85 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp85.call(b2, prop))
      __defNormalProp85(a2, prop, b2[prop]);
  if (__getOwnPropSymbols85)
    for (var prop of __getOwnPropSymbols85(b2)) {
      if (__propIsEnum85.call(b2, prop))
        __defNormalProp85(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps75 = (a2, b2) => __defProps75(a2, __getOwnPropDescs75(b2));
var _sfc_main77 = defineComponent({
  name: "VaSelectOption",
  components: { VaIcon: VaIcon2 },
  props: __spreadProps75(__spreadValues85({}, useColorProps), {
    option: { type: [Number, String, Object], default: () => ({}) },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    currentOption: { type: [String, Number, Object], default: null },
    getSelectedState: { type: Function, required: true }
  }),
  setup(props) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const optionIcon = computed(() => typeof props.option === "object" ? props.option.icon : void 0);
    const optionIconColor = computed(() => getColor(props.color));
    const optionText = computed(() => props.getText(props.option));
    const isSelected = computed(() => props.getSelectedState(props.option));
    const isFocused = computed(() => {
      if (!props.currentOption) {
        return false;
      }
      if (typeof props.option === "string") {
        return props.option === props.currentOption;
      }
      if (!props.getTrackBy) {
        return false;
      }
      return props.getTrackBy(props.currentOption) === props.getTrackBy(props.option);
    });
    const optionClass = useBem("va-select-option", () => ({
      selected: isSelected.value
    }));
    const optionStyle = computed(() => ({
      color: isSelected.value ? getColor(props.color) : "inherit",
      backgroundColor: isFocused.value ? getHoverColor2(getColor(props.color)) : "transparent"
    }));
    return {
      getColor,
      isFocused,
      optionIcon,
      isSelected,
      optionText,
      optionStyle,
      optionClass,
      optionIconColor
    };
  }
});
var _hoisted_154 = ["aria-selected"];
function _sfc_render76(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", {
    role: "option",
    class: normalizeClass(["va-select-option", _ctx.optionClass]),
    style: normalizeStyle(_ctx.optionStyle),
    "aria-selected": _ctx.isSelected
  }, [
    _ctx.optionIcon ? (openBlock(), createBlock(_component_va_icon, {
      key: 0,
      size: "small",
      class: "va-select-option__icon",
      name: _ctx.optionIcon
    }, null, 8, ["name"])) : createCommentVNode("", true),
    createTextVNode(" " + toDisplayString(_ctx.optionText) + " ", 1),
    withDirectives(createVNode(_component_va_icon, {
      class: "va-select-option__selected-icon",
      size: "small",
      name: "va-check",
      color: _ctx.optionIconColor
    }, null, 8, ["color"]), [
      [vShow, _ctx.isSelected]
    ])
  ], 14, _hoisted_154);
}
var _VaSelectOption = _export_sfc(_sfc_main77, [["render", _sfc_render76]]);

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOption/index.js
var VaSelectOption = withConfigTransport(_VaSelectOption);

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/VaSelectOptionList.css";
var __defProp86 = Object.defineProperty;
var __defProps76 = Object.defineProperties;
var __getOwnPropDescs76 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols86 = Object.getOwnPropertySymbols;
var __hasOwnProp86 = Object.prototype.hasOwnProperty;
var __propIsEnum86 = Object.prototype.propertyIsEnumerable;
var __defNormalProp86 = (obj, key, value) => key in obj ? __defProp86(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues86 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp86.call(b2, prop))
      __defNormalProp86(a2, prop, b2[prop]);
  if (__getOwnPropSymbols86)
    for (var prop of __getOwnPropSymbols86(b2)) {
      if (__propIsEnum86.call(b2, prop))
        __defNormalProp86(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps76 = (a2, b2) => __defProps76(a2, __getOwnPropDescs76(b2));
var _sfc_main78 = defineComponent({
  name: "VaSelectOptionList",
  components: { VaVirtualScroller, VaSelectOption },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: __spreadProps76(__spreadValues86(__spreadValues86({}, useColorProps), useComponentPresetProp), {
    options: { type: Array, default: () => [] },
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    getGroupBy: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hoveredOption: { type: [String, Number, Object], default: null },
    virtualScroller: { type: Boolean, default: true }
  }),
  setup(props, { emit, slots }) {
    const root2 = shallowRef();
    const focus = () => {
      var _a;
      (_a = root2.value) == null ? void 0 : _a.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a, _b;
      return (_b = (_a = root2.value) == null ? void 0 : _a.clientHeight) != null ? _b : 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => props.hoveredOption || null);
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const filteredOptions = computed(() => {
      if (!props.search) {
        return props.options;
      }
      return props.options.filter((option) => {
        const optionText = props.getText(option).toString().toUpperCase();
        const search = props.search.toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      if (typeof option !== "object" || !props.getGroupBy(option)) {
        groups._noGroup.push(option);
      } else {
        const groupBy = props.getGroupBy(option);
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value) {
        return;
      }
      updateCurrentOption(option || null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option || null, "keyboard");
    };
    const selectOption = (option) => emit("select-option", option);
    const currentOptionIndex = computed(() => filteredOptions.value.findIndex((option) => {
      return !!currentOptionComputed.value && props.getTrackBy(option) === props.getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => pick_1(props, ["getSelectedState", "getText", "getTrackBy", "color"]));
    const isSlotContentPassed = computed(() => checkSlotChildrenDeep(slots.default));
    const focusPreviousOption = () => {
      if (!currentOptionComputed.value) {
        filteredOptions.value.length && updateFocusedOption(filteredOptions.value.at(-1));
        return;
      }
      if (filteredOptions.value[currentOptionIndex.value - 1]) {
        updateFocusedOption(filteredOptions.value[currentOptionIndex.value - 1]);
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!currentOptionComputed.value) {
        filteredOptions.value.length && updateFocusedOption(filteredOptions.value[0]);
        return;
      }
      if (filteredOptions.value[currentOptionIndex.value + 1]) {
        updateFocusedOption(filteredOptions.value[currentOptionIndex.value + 1]);
      }
    };
    const focusFirstOption = () => {
      var _a;
      return updateFocusedOption((_a = filteredOptions.value) == null ? void 0 : _a[0]);
    };
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a;
      if (!option) {
        return;
      }
      const element = itemRefs.value[props.getTrackBy(option)];
      if (element) {
        scrollToElement(extractHTMLElement(element));
      }
      if (props.virtualScroller) {
        (_a = virtualScrollerRef.value) == null ? void 0 : _a[0].virtualScrollTo(currentOptionIndex.value);
      }
    };
    const publicMethods = {
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    };
    watch(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && newOption && scrollToOption(newOption);
    });
    return __spreadValues86({
      root: root2,
      virtualScrollerRef,
      rootHeight,
      optionGroups,
      filteredOptions,
      selectOptionProps,
      isSlotContentPassed,
      currentOptionComputed,
      onScroll,
      setItemRef,
      selectOption,
      updateHoveredOption,
      handleScrollToBottom
    }, publicMethods);
  }
});
var _hoisted_155 = ["tabindex"];
var _hoisted_229 = {
  key: 0,
  class: "va-select-option-list__group-name"
};
var _hoisted_315 = {
  key: 0,
  class: "va-select-option-list--empty"
};
function _sfc_render77(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_select_option = resolveComponent("va-select-option");
  const _component_va_virtual_scroller = resolveComponent("va-virtual-scroller");
  return openBlock(), createElementBlock("div", {
    ref: "root",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["right"]))
    ],
    onScrollPassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return openBlock(), createElementBlock(Fragment, { key: groupName }, [
        groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_229, toDisplayString(groupName), 1)) : createCommentVNode("", true),
        _ctx.$props.virtualScroller ? (openBlock(), createBlock(_component_va_virtual_scroller, {
          key: 1,
          ref_for: true,
          ref: "virtualScrollerRef",
          items: options,
          "track-by": _ctx.$props.getTrackBy,
          "wrapper-size": _ctx.rootHeight,
          "onScroll:bottom": _ctx.handleScrollToBottom
        }, {
          default: withCtx(({ item: option, index }) => [
            !_ctx.isSlotContentPassed ? (openBlock(), createBlock(_component_va_select_option, mergeProps({
              key: 0,
              option,
              "current-option": _ctx.currentOptionComputed
            }, _ctx.selectOptionProps, {
              onClick: ($event) => _ctx.selectOption(option),
              onMousemove: ($event) => _ctx.updateHoveredOption(option)
            }), null, 16, ["option", "current-option", "onClick", "onMousemove"])) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, { option, index, selectOption: _ctx.selectOption })))
          ]),
          _: 2
        }, 1032, ["items", "track-by", "wrapper-size", "onScroll:bottom"])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(options, (option, index) => {
          return openBlock(), createElementBlock(Fragment, {
            key: _ctx.$props.getTrackBy(option)
          }, [
            !_ctx.isSlotContentPassed ? (openBlock(), createBlock(_component_va_select_option, mergeProps({
              key: 0,
              ref_for: true,
              ref: _ctx.setItemRef(_ctx.$props.getTrackBy(option)),
              "current-option": _ctx.currentOptionComputed,
              option
            }, _ctx.selectOptionProps, {
              onClick: ($event) => _ctx.selectOption(option),
              onMousemove: ($event) => _ctx.updateHoveredOption(option)
            }), null, 16, ["current-option", "option", "onClick", "onMousemove"])) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, { option, index, selectOption: _ctx.selectOption })))
          ], 64);
        }), 128))
      ], 64);
    }), 128)),
    !_ctx.filteredOptions.length ? (openBlock(), createElementBlock("div", _hoisted_315, toDisplayString(_ctx.noOptionsText), 1)) : createCommentVNode("", true)
  ], 40, _hoisted_155);
}
var _VaSelectOptionList = _export_sfc(_sfc_main78, [["render", _sfc_render77]]);

// node_modules/vuestic-ui/dist/es/src/components/va-select/components/VaSelectOptionList/index.js
var VaSelectOptionList = withConfigTransport(_VaSelectOptionList);

// node_modules/vuestic-ui/dist/es/src/components/va-select/VaSelect.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-select/VaSelect.css";
var __defProp87 = Object.defineProperty;
var __defProps77 = Object.defineProperties;
var __getOwnPropDescs77 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols87 = Object.getOwnPropertySymbols;
var __hasOwnProp87 = Object.prototype.hasOwnProperty;
var __propIsEnum87 = Object.prototype.propertyIsEnumerable;
var __defNormalProp87 = (obj, key, value) => key in obj ? __defProp87(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues87 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp87.call(b2, prop))
      __defNormalProp87(a2, prop, b2[prop]);
  if (__getOwnPropSymbols87)
    for (var prop of __getOwnPropSymbols87(b2)) {
      if (__propIsEnum87.call(b2, prop))
        __defNormalProp87(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps77 = (a2, b2) => __defProps77(a2, __getOwnPropDescs77(b2));
var VaDropdownProps4 = extractComponentProps(VaDropdown, ["keyboardNavigation", "offset", "stateful", "keepAnchorWidth", "closeOnContentClick", "innerAnchorSelector", "modelValue"]);
var _sfc_main79 = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectOptionList,
    VaIcon: VaIcon2,
    VaDropdown,
    VaDropdownContent,
    VaInput,
    VaInputWrapper
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: __spreadProps77(__spreadValues87(__spreadValues87(__spreadValues87(__spreadValues87(__spreadValues87(__spreadValues87(__spreadValues87(__spreadValues87({}, VaDropdownProps4), useSelectableListProps), useValidationProps), useLoadingProps), useMaxSelectionsProps), useClearableProps), useFormProps), useComponentPresetProp), {
    modelValue: {
      type: [String, Number, Array, Object],
      default: ""
    },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => ["top", "bottom"].includes(placement)
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    separator: { type: String, default: ", " },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "$t:noOptions" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    dropdownIcon: {
      type: [String, Object],
      default: () => ({
        open: "va-arrow-down",
        close: "va-arrow-up"
      }),
      validator: (value) => {
        if (typeof value === "string") {
          return true;
        }
        const isOpenIconString = typeof value.open === "string";
        const isCloseIconString = typeof value.close === "string";
        return isOpenIconString && isCloseIconString;
      }
    },
    virtualScroller: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    searchPlaceholderText: { type: String, default: "$t:search" },
    requiredMark: { type: Boolean, default: false }
  }),
  setup(props, { emit }) {
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const isFocused = computed(() => isInputFocused.value || showDropdownContent.value);
    const { getHoverColor: getHoverColor2, getColor } = useColors();
    const { getOptionByValue, getValue: getValue2, getText, getTrackBy, getGroupBy } = useSelectableList(props);
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchInput.value = "";
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      var _a;
      if (props.disabled) {
        return;
      }
      (_a = input.value) == null ? void 0 : _a.focus();
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const colorComputed = computed(() => getColor(props.color));
    const toggleIconColor = computed(() => props.readonly ? getHoverColor2(colorComputed.value) : colorComputed.value);
    const onScrollBottom = () => emit("scroll-bottom");
    const searchInput = ref("");
    const showSearchInput = computed(() => props.searchable || props.allowCreate);
    watch(searchInput, (value) => {
      emit("update-search", value);
      hoveredOption.value = null;
    });
    const valueComputed = computed({
      get() {
        if (props.multiple) {
          if (!props.modelValue) {
            return [];
          }
          if (!Array.isArray(props.modelValue)) {
            return [getOptionByValue(props.modelValue)];
          }
          return props.modelValue.map(getOptionByValue);
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          if (value.length) {
            return value[value.length - 1];
          }
        }
        return value;
      },
      set(value) {
        if (Array.isArray(value)) {
          emit("update:modelValue", value.map(getValue2));
        } else {
          emit("update:modelValue", getValue2(value));
        }
      }
    });
    const valueComputedString = computed(() => {
      if (!valueComputed.value) {
        return props.clearValue;
      }
      if (typeof valueComputed.value === "string" || typeof valueComputed.value === "number") {
        return valueComputed.value;
      }
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => getText(value)).join(props.separator) || props.clearValue;
      }
      return getText(valueComputed.value);
    });
    const isPlaceholder = computed(() => props.placeholder && !valueComputedString.value);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const toggleIcon = computed(() => {
      if (!props.dropdownIcon) {
        return "";
      }
      if (typeof props.dropdownIcon === "string") {
        return props.dropdownIcon;
      }
      return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const checkIsOptionSelected = (option) => {
      if (!valueComputed.value) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.find((valueItem) => compareOptions(valueItem, option));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue2(option1);
      const two = getValue2(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v2) => Array.isArray(v2.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchInput.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections));
        const isSelected = checkIsOptionSelected(getValue2(option));
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(getValue2(option), getValue2(optionSelected)));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = typeof option === "string" || typeof option === "number" ? option : __spreadValues87({}, option);
        hideAndFocus();
      }
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option) => getText(option) === searchInput.value);
      if (!(props.allowCreate === "unique" && hasAddedOption)) {
        emit("create-new", searchInput.value);
        searchInput.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!hoveredOption.value) {
        return;
      }
      if (!showDropdownContent.value) {
        showDropdown();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && searchInput.value !== "";
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const hoverPreviousOption = () => {
      var _a;
      (_a = optionList.value) == null ? void 0 : _a.hoverPreviousOption();
    };
    const hoverNextOption = () => {
      var _a;
      (_a = optionList.value) == null ? void 0 : _a.hoverNextOption();
    };
    const showDropdownContent = ref(false);
    const showDropdownContentComputed = computed({
      get: () => showDropdownContent.value,
      set: (show) => {
        show ? showDropdown() : hideDropdown();
      }
    });
    const closeOnContentClick = computed(() => {
      return !(props.multiple || props.searchable || props.allowCreate);
    });
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContent.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const hideDropdown = () => {
      showDropdownContent.value = false;
      searchInput.value = "";
      validate();
    };
    const toggleDropdown = () => {
      if (showDropdownContent.value) {
        hideAndFocus();
      } else {
        showDropdown();
      }
    };
    const onSelectClick = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      toggleDropdown();
    };
    const hideAndFocus = () => {
      hideDropdown();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) == null ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) == null ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = () => nextTick(() => {
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    });
    const onInputFocus = () => {
      isInputFocused.value = true;
      onFocus();
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const blur = () => {
      var _a;
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick((_a = input.value) == null ? void 0 : _a.blur);
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchInput.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const { tp, t: t2 } = useTranslation();
    const dropdownPropsComputed = computed(() => __spreadProps77(__spreadValues87({}, filterComponentProps(props, VaDropdownProps4).value), {
      closeOnContentClick: closeOnContentClick.value,
      stateful: false,
      offset: [1, 0],
      keepAnchorWidth: true,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field",
      "aria-label": props.modelValue ? `${t2("selectedOption")}: ${props.modelValue}` : t2("noSelectedOption")
    }));
    return __spreadProps77(__spreadValues87({}, useTranslation()), {
      isFocused,
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      tp,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      onSelectClick,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueComputed,
      valueComputedString,
      showClearIcon,
      toggleIcon,
      computedErrorMessages,
      computedError,
      filteredOptions,
      checkIsOptionSelected,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      hoverPreviousOption,
      hoverNextOption,
      showDropdownContentComputed,
      showDropdown,
      hideDropdown,
      hideAndFocus,
      toggleDropdown,
      toggleIconColor,
      onHintedSearch,
      getText,
      getTrackBy,
      getGroupBy,
      onScrollBottom,
      clearIconProps,
      isPlaceholder,
      dropdownPropsComputed
    });
  }
});
var _hoisted_156 = {
  key: 0,
  class: "va-select-anchor__placeholder"
};
function _sfc_render78(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    ref: "dropdown",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.showDropdownContentComputed = $event),
    class: "va-select va-select__dropdown va-select-dropdown"
  }, _ctx.dropdownPropsComputed, { onClose: _ctx.focus }), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, {
        ref: "input",
        class: "va-select__anchor va-select-anchor__input",
        "model-value": _ctx.valueComputedString,
        success: _ctx.$props.success,
        error: _ctx.computedError,
        color: _ctx.$props.color,
        label: _ctx.$props.label,
        loading: _ctx.$props.loading,
        outline: _ctx.$props.outline,
        bordered: _ctx.$props.bordered,
        "required-mark": _ctx.$props.requiredMark,
        messages: _ctx.$props.messages,
        "error-messages": _ctx.computedErrorMessages,
        focused: _ctx.isFocused,
        tabindex: _ctx.tabIndexComputed,
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur
      }, createSlots({
        icon: withCtx(() => [
          _ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": _ctx.t("reset"),
            tabindex: "0"
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ]),
        appendInner: withCtx(() => [
          _ctx.$slots.appendInner ? renderSlot(_ctx.$slots, "appendInner", { key: 0 }) : createCommentVNode("", true),
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon
          }, null, 8, ["color", "name"])
        ]),
        default: withCtx(() => [
          _ctx.isPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_156, toDisplayString(_ctx.$props.placeholder), 1)) : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, {
            valueString: _ctx.valueComputedString,
            value: _ctx.valueComputed,
            tabindex: _ctx.tabIndexComputed
          })), () => [
            createTextVNode(toDisplayString(_ctx.valueComputedString), 1)
          ])
        ]),
        _: 2
      }, [
        _ctx.$slots.prepend ? {
          name: "prepend",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prepend")
          ])
        } : void 0,
        _ctx.$slots.append ? {
          name: "append",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "append")
          ])
        } : void 0,
        _ctx.$slots.prependInner ? {
          name: "prependInner",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prependInner")
          ])
        } : void 0
      ]), 1032, ["model-value", "success", "error", "color", "label", "loading", "outline", "bordered", "required-mark", "messages", "error-messages", "focused", "tabindex", "onFocus", "onBlur"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width })
      }, {
        default: withCtx(() => [
          _ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input, {
            key: 0,
            ref: "searchBar",
            class: "va-select-dropdown__content-search-input",
            "aria-label": _ctx.t("optionsFilter"),
            tabindex: _ctx.tabIndexComputed,
            bordered: true,
            placeholder: _ctx.tp(_ctx.$props.searchPlaceholderText),
            modelValue: _ctx.searchInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchInput = $event),
            onKeydown: [
              withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop", "prevent"]), ["up"]),
              withKeys(withModifiers(_ctx.hoverPreviousOption, ["stop", "prevent"]), ["left"]),
              withKeys(withModifiers(_ctx.hoverNextOption, ["stop", "prevent"]), ["down"]),
              withKeys(withModifiers(_ctx.hoverNextOption, ["stop", "prevent"]), ["right"]),
              withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
            ],
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.hoveredOption = null)
          }, null, 8, ["aria-label", "tabindex", "placeholder", "modelValue", "onKeydown"])) : createCommentVNode("", true),
          createVNode(_component_va_select_option_list, {
            ref: "optionList",
            class: "va-select-dropdown__options-wrapper",
            hoveredOption: _ctx.hoveredOption,
            "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => _ctx.hoveredOption = $event),
            style: normalizeStyle({ maxHeight: _ctx.$props.maxHeight }),
            options: _ctx.filteredOptions,
            "selected-value": _ctx.valueComputed,
            "get-selected-state": _ctx.checkIsOptionSelected,
            "get-text": _ctx.getText,
            "get-track-by": _ctx.getTrackBy,
            "get-group-by": _ctx.getGroupBy,
            search: _ctx.searchInput,
            "no-options-text": _ctx.tp(_ctx.$props.noOptionsText),
            color: _ctx.$props.color,
            tabindex: _ctx.tabIndexComputed,
            "virtual-scroller": _ctx.$props.virtualScroller,
            onSelectOption: _ctx.selectOption,
            onNoPreviousOptionToHover: _ctx.focusSearchBar,
            onKeydown: [
              withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["enter"]),
              withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["space"]),
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.searchBar && _ctx.searchBar.focus(), ["stop", "prevent"]), ["tab"])),
              _ctx.onHintedSearch
            ],
            onScrollBottom: _ctx.onScrollBottom
          }, {
            default: withCtx((slotData) => [
              renderSlot(_ctx.$slots, "option", normalizeProps(guardReactiveProps(slotData || {})))
            ]),
            _: 3
          }, 8, ["hoveredOption", "style", "options", "selected-value", "get-selected-state", "get-text", "get-track-by", "get-group-by", "search", "no-options-text", "color", "tabindex", "virtual-scroller", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
        ]),
        _: 3
      }, 8, ["style"])
    ]),
    _: 3
  }, 16, ["modelValue", "onClose"]);
}
var _VaSelect = _export_sfc(_sfc_main79, [["render", _sfc_render78]]);

// node_modules/vuestic-ui/dist/es/src/components/va-select/index.js
var VaSelect = withConfigTransport(_VaSelect);

// node_modules/vuestic-ui/dist/es/src/components/va-separator/VaSeparator.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-separator/VaSeparator.css";
var _sfc_main80 = defineComponent({
  name: "VaSeparator"
});
var _hoisted_157 = {
  class: "va-separator",
  "aria-hidden": "true"
};
function _sfc_render79(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_157);
}
var VaSeparator = _export_sfc(_sfc_main80, [["render", _sfc_render79]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebar.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/hooks/useSidebar.js
init_vue_runtime_esm_bundler();
var VaSidebarKey = Symbol("VaSidebar");
var useSidebar = (props) => {
  provide(VaSidebarKey, props);
};
var useSidebarItem = () => {
  return inject(VaSidebarKey, {
    color: "background-element"
  });
};

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebar.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebar.css";
var __defProp88 = Object.defineProperty;
var __defProps78 = Object.defineProperties;
var __getOwnPropDescs78 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols88 = Object.getOwnPropertySymbols;
var __hasOwnProp88 = Object.prototype.hasOwnProperty;
var __propIsEnum88 = Object.prototype.propertyIsEnumerable;
var __defNormalProp88 = (obj, key, value) => key in obj ? __defProp88(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues88 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp88.call(b2, prop))
      __defNormalProp88(a2, prop, b2[prop]);
  if (__getOwnPropSymbols88)
    for (var prop of __getOwnPropSymbols88(b2)) {
      if (__propIsEnum88.call(b2, prop))
        __defNormalProp88(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps78 = (a2, b2) => __defProps78(a2, __getOwnPropDescs78(b2));
var _sfc_main81 = defineComponent({
  name: "VaSidebar",
  props: __spreadProps78(__spreadValues88({}, useComponentPresetProp), {
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    borderColor: { type: String, default: void 0 },
    color: { type: String, default: "background-element" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    position: {
      type: String,
      default: "left",
      validator: (v2) => ["left", "right"].includes(v2)
    },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: Boolean, default: true }
  }),
  setup(props) {
    const { getColor } = useColors();
    useSidebar(props);
    const isHovered = ref(false);
    const isMinimized = computed(() => props.minimized || props.hoverable && !isHovered.value);
    const computedWidth = computed(() => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    });
    const { textColorComputed } = useTextColor();
    const computedStyle = computed(() => {
      const backgroundColor = getColor(props.color);
      const color = textColorComputed.value;
      return {
        color,
        backgroundColor,
        backgroundImage: props.gradient ? getGradientBackground(backgroundColor) : void 0
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      right: props.position === "right",
      animated: props.animated
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    return {
      computedWidth,
      computedClass,
      computedStyle,
      updateHoverState,
      vaSidebarItemProps: computed(() => ({
        textColor: props.textColor,
        activeColor: props.activeColor,
        hoverColor: props.hoverColor,
        borderColor: props.borderColor
      }))
    };
  }
});
function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("aside", {
    class: normalizeClass(["va-sidebar", _ctx.computedClass]),
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.updateHoverState(false))
  }, [
    createBaseVNode("div", {
      class: "va-sidebar__menu",
      style: normalizeStyle(`width: ${_ctx.computedWidth};`)
    }, [
      createVNode(_component_va_config, {
        components: { VaSidebarItem: _ctx.vaSidebarItemProps }
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["components"])
    ], 4)
  ], 38);
}
var _VaSidebar = _export_sfc(_sfc_main81, [["render", _sfc_render80]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/index.js
var VaSidebar = withConfigTransport(_VaSidebar);

// node_modules/vuestic-ui/dist/es/src/components/va-slider/VaSlider.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-slider/validateSlider.js
var validateSlider = (value, step, min, max, range) => {
  const inRange = (v2) => {
  };
  if (Array.isArray(value)) {
    value.map(inRange);
  }
  return true;
};

// node_modules/vuestic-ui/dist/es/src/components/va-slider/VaSlider.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-slider/VaSlider.css";
var __defProp89 = Object.defineProperty;
var __defProps79 = Object.defineProperties;
var __getOwnPropDescs79 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols89 = Object.getOwnPropertySymbols;
var __hasOwnProp89 = Object.prototype.hasOwnProperty;
var __propIsEnum89 = Object.prototype.propertyIsEnumerable;
var __defNormalProp89 = (obj, key, value) => key in obj ? __defProp89(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues89 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp89.call(b2, prop))
      __defNormalProp89(a2, prop, b2[prop]);
  if (__getOwnPropSymbols89)
    for (var prop of __getOwnPropSymbols89(b2)) {
      if (__propIsEnum89.call(b2, prop))
        __defNormalProp89(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps79 = (a2, b2) => __defProps79(a2, __getOwnPropDescs79(b2));
var _sfc_main82 = defineComponent({
  name: "VaSlider",
  components: { VaIcon: VaIcon2 },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  props: __spreadProps79(__spreadValues89({}, useComponentPresetProp), {
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 100 },
    step: { type: Number, default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true }
  }),
  setup(props, { emit, slots }) {
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset = ref(0);
    const size = ref(0);
    const currentValue = ref(Array.isArray(props.modelValue) ? [...props.modelValue] : props.modelValue);
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - props.step < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + props.step > val.value[1]);
    const sliderClass = useBem("va-slider", () => __spreadProps79(__spreadValues89({}, pick_1(props, ["disabled", "readonly", "vertical"])), {
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor2(getColor(props.color))
    }));
    const processedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [trackSizeStyle.value]: `${val2}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      const validatedValue = limitValue(props.modelValue);
      if (Array.isArray(validatedValue)) {
        const val0 = (validatedValue[0] - props.min) / (props.max - props.min) * 100;
        const val1 = (validatedValue[1] - props.min) / (props.max - props.min) * 100;
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val2 = (validatedValue - props.min) / (props.max - props.min) * 100;
        return {
          [pinPositionStyle.value]: `${val2}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range && index !== void 0 ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => props.modelValue,
      set: (val2) => {
        if (!props.range) {
          val2 = limitValue(val2);
        }
        if (!flag.value) {
          emit("change", val2);
        }
        emit("update:modelValue", val2);
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (props.max - props.min) / props.step;
      return size.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${props.step}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (props.max - props.min) / props.step - 1);
    const position = computed(() => {
      return Array.isArray(props.modelValue) ? [(props.modelValue[0] - props.min) / props.step * gap.value, (props.modelValue[1] - props.min) / props.step * gap.value] : (props.modelValue - props.min) / props.step * gap.value;
    });
    const limit = computed(() => [0, size.value]);
    const valueLimit = computed(() => [props.min, props.max]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e2, index = currentSliderDotIndex.value) => {
      var _a, _b;
      e2.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e2 ? e2.touches[0] : e2;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(props.modelValue)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(props.modelValue) ? (_a = dots.value[index]) == null ? void 0 : _a.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit("drag-start");
    };
    const moving = (e2) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e2.preventDefault();
      if ("touches" in e2) {
        setValueOnPos(getPos(e2.touches[0]));
      } else {
        setValueOnPos(getPos(e2));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit("drag-end");
          emit("change", props.modelValue);
        } else {
          return false;
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const moveWithKeys = (event) => {
      var _a, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (isRange3, where, which) => {
        if (isRange3 && Array.isArray(val.value)) {
          if (!props.pins) {
            return val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = val.value[which] / onePinInterval | 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value[which] !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value.splice(which, 1, nearestPinVal);
          } else {
            val.value.splice(which, 1, val.value[which] + (where ? props.step : -props.step));
          }
        } else {
          if (!props.pins && !Array.isArray(val.value)) {
            val.value += where ? props.step : -props.step;
            return;
          }
          const onePinInterval = (props.max - props.min) / (pinsCol.value + 1);
          const fullPinsNow = !Array.isArray(val.value) ? val.value / onePinInterval | 0 : 0;
          let nearestPinVal = fullPinsNow * onePinInterval;
          if (val.value !== nearestPinVal) {
            nearestPinVal += where ? onePinInterval : 0;
            val.value = nearestPinVal;
          } else {
            val.value += where ? props.step : -props.step;
          }
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== props.min):
            (_a = dots.value[0]) == null ? void 0 : _a.focus();
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== props.max):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== props.min):
            moveDot(true, 0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== props.max):
            moveDot(true, 1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== props.min):
            moveDot(true, 0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== props.max):
            moveDot(true, 1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(false, 1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(false, 0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(false, 1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * props.step > val.value[0] && pin * props.step < val.value[1];
      } else {
        return pin * props.step < val.value;
      }
    };
    const pinPositionStep = computed(() => props.step / (props.max - props.min) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor2(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e2) => {
      getStaticData();
      return props.vertical ? offset.value - e2.clientY : e2.clientX - offset.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (props.step * multiple.value * index + props.min * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value) && Array.isArray(currentValue.value) && Array.isArray(props.modelValue)) {
        if (isDiff(currentValue.value[slider], newValue)) {
          currentValue.value.splice(slider, 1, newValue);
          if (slider === 0) {
            val.value = [currentValue.value.splice(slider, 1, newValue)[0], props.modelValue[1]];
            currentValue.value = [...val.value];
          } else {
            val.value = [props.modelValue[0], currentValue.value.splice(slider, 1, newValue)[0]];
            currentValue.value = [...val.value];
          }
        }
      } else {
        if (newValue < props.min || newValue > props.max) {
          return false;
        }
        if (isDiff(currentValue.value, newValue)) {
          currentValue.value = newValue;
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(props.modelValue) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value[1] = val.value[0];
            currentSliderDotIndex.value = 0;
          }
          const v2 = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v2);
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value[0] = val.value[1];
            currentSliderDotIndex.value = 1;
          }
          const v2 = getValueByIndex(Math.round(pixelPosition / gap.value));
          setCurrentValue(v2);
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const limitValue = (val2) => {
      const inRange = (v2) => {
        if (v2 < props.min) {
          return props.min;
        } else if (v2 > props.max) {
          return props.max;
        }
        return v2;
      };
      if (Array.isArray(val2)) {
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 0) {
          const v2 = inRange(val2[1]);
          return [v2, v2];
        }
        if (val2[0] >= val2[1] && currentSliderDotIndex.value === 1) {
          const v2 = inRange(val2[0]);
          return [v2, v2];
        }
        return val2.map((v2) => inRange(v2));
      } else {
        return inRange(val2);
      }
    };
    const isDiff = (a2, b2) => JSON.stringify(a2) !== JSON.stringify(b2);
    const clickOnContainer = (e2) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e2 ? getPos(e2.touches[0]) : getPos(e2);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e2, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const ariaLabelIdComputed = computed(() => `aria-label-id-${generateUniqueId()}`);
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      "aria-valuemin": props.min,
      "aria-valuemax": props.max,
      "aria-label": !slots.label && !props.label ? `current slider value is ${String(props.modelValue)}` : void 0,
      "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
      ariaOrientation: props.vertical ? "vertical" : "horizontal",
      ariaDisabled: props.disabled,
      "aria-readonly": props.readonly,
      "aria-valuenow": !Array.isArray(props.modelValue) ? props.modelValue : void 0,
      "aria-valuetext": Array.isArray(props.modelValue) ? String(props.modelValue) : void 0
    }));
    onMounted(() => {
      if (validateSlider(props.modelValue, props.step, props.min, props.max, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => props.step,
      () => props.min,
      () => props.max,
      () => props.range
    ], ([value, step, min, max, range]) => {
      validateSlider(value);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return {
      getColor,
      dot,
      dots,
      setItemRefByIndex,
      orders,
      sliderContainer,
      val,
      getValueByOrder,
      sliderClass,
      dotClass,
      labelStyles,
      processedStyles,
      getPinStyles,
      dottedStyles,
      getDottedStyles,
      clickOnContainer,
      hasMouseDown,
      trackStyles,
      pinsCol,
      checkActivePin,
      isFocused,
      isActiveDot,
      getTrackLabel,
      currentSliderDotIndex,
      ariaLabelIdComputed,
      ariaAttributesComputed
    };
  }
});
var _hoisted_158 = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
var _hoisted_230 = ["id"];
var _hoisted_316 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
var _hoisted_410 = ["tabindex", "onFocus"];
var _hoisted_57 = ["tabindex"];
var _hoisted_66 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
var _hoisted_74 = ["id"];
var _hoisted_83 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
function _sfc_render81(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-slider", _ctx.sliderClass]
  }, _ctx.ariaAttributesComputed), [
    (_ctx.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_158, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "append" : "prepend")
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && !_ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: "va-input__label",
      id: _ctx.ariaLabelIdComputed,
      style: normalizeStyle(_ctx.labelStyles)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_230)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_316, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconAppend : _ctx.iconPrepend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      ref: "sliderContainer",
      class: "va-slider__container",
      onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args)),
      onMouseup: _cache[4] || (_cache[4] = ($event) => _ctx.hasMouseDown = false),
      onTouchstart: _cache[5] || (_cache[5] = (...args) => _ctx.clickOnContainer && _ctx.clickOnContainer(...args))
    }, [
      createBaseVNode("div", {
        class: "va-slider__track",
        "aria-hidden": "true",
        style: normalizeStyle(_ctx.trackStyles)
      }, null, 4),
      _ctx.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.pinsCol, (pin, i2) => {
        return openBlock(), createElementBlock("div", {
          key: i2,
          class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": _ctx.checkActivePin(pin) }]),
          style: normalizeStyle(_ctx.getPinStyles(pin))
        }, null, 6);
      }), 128)) : createCommentVNode("", true),
      _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("div", {
          ref: "process",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          "aria-hidden": "true",
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.orders, (order) => {
          return openBlock(), createElementBlock("div", {
            key: "dot" + order,
            ref_for: true,
            ref: _ctx.setItemRefByIndex(order),
            class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
            style: normalizeStyle(_ctx.getDottedStyles(order)),
            tabindex: _ctx.disabled || _ctx.readonly ? void 0 : 0,
            onFocus: ($event) => (_ctx.isFocused = true, _ctx.currentSliderDotIndex = order),
            onBlur: _cache[0] || (_cache[0] = ($event) => _ctx.isFocused = false)
          }, [
            _ctx.isActiveDot(order) ? (openBlock(), createElementBlock("div", {
              key: 0,
              style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) }),
              class: "va-slider__handler__dot--focus"
            }, null, 4)) : createCommentVNode("", true),
            _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
              key: 1,
              style: normalizeStyle(_ctx.labelStyles),
              class: "va-slider__handler__dot--value"
            }, [
              renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder(order), order })), () => [
                createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder(order), order)), 1)
              ])
            ], 4)) : createCommentVNode("", true)
          ], 46, _hoisted_410);
        }), 128))
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createBaseVNode("div", {
          ref: "process",
          "aria-hidden": "true",
          class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": _ctx.isFocused }]),
          style: normalizeStyle(_ctx.processedStyles)
        }, null, 6),
        createBaseVNode("div", {
          ref: "dot",
          class: normalizeClass(["va-slider__handler", _ctx.dotClass]),
          style: normalizeStyle(_ctx.dottedStyles),
          tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
          onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.isFocused = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.isFocused = false)
        }, [
          _ctx.isActiveDot(0) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-slider__handler__dot--focus",
            style: normalizeStyle({ backgroundColor: _ctx.getColor(_ctx.$props.color) })
          }, null, 4)) : createCommentVNode("", true),
          _ctx.trackLabelVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-slider__handler__dot--value",
            style: normalizeStyle(_ctx.labelStyles)
          }, [
            renderSlot(_ctx.$slots, "trackLabel", normalizeProps(guardReactiveProps({ value: _ctx.getValueByOrder() })), () => [
              createTextVNode(toDisplayString(_ctx.getTrackLabel(_ctx.getValueByOrder())), 1)
            ])
          ], 4)) : createCommentVNode("", true)
        ], 46, _hoisted_57)
      ], 64))
    ], 544),
    (_ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_66, [
      createVNode(_component_va_icon, {
        name: _ctx.vertical ? _ctx.iconPrepend : _ctx.iconAppend,
        color: _ctx.getColor(_ctx.$props.color),
        size: 16
      }, null, 8, ["name", "color"])
    ])) : createCommentVNode("", true),
    (_ctx.$slots.label || _ctx.label) && _ctx.invertLabel ? (openBlock(), createElementBlock("span", {
      key: 4,
      class: "va-input__label va-input__label--inverse",
      style: normalizeStyle(_ctx.labelStyles),
      id: _ctx.ariaLabelIdComputed
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 12, _hoisted_74)) : createCommentVNode("", true),
    (_ctx.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_83, [
      renderSlot(_ctx.$slots, _ctx.vertical ? "prepend" : "append")
    ])) : createCommentVNode("", true)
  ], 16);
}
var _VaSlider = _export_sfc(_sfc_main82, [["render", _sfc_render81]]);

// node_modules/vuestic-ui/dist/es/src/components/va-slider/index.js
var VaSlider = withConfigTransport(_VaSlider);

// node_modules/vuestic-ui/dist/es/src/components/va-spacer/VaSpacer.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-spacer/VaSpacer.css";
var _sfc_main83 = defineComponent({
  name: "VaSpacer"
});
var _hoisted_159 = {
  class: "va-spacer",
  "aria-hidden": "true"
};
function _sfc_render82(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_159);
}
var VaSpacer = _export_sfc(_sfc_main83, [["render", _sfc_render82]]);

// node_modules/vuestic-ui/dist/es/src/components/va-split/VaSplit.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-split/useSplitDragger.js
init_vue_runtime_esm_bundler();
var useSplitDraggerProps = {
  vertical: { type: Boolean, default: false },
  disabled: { type: Boolean, default: false }
};
var useSplitDragger = (containerSizeComputed, splitterPositionComputed, props) => {
  const isDragging = ref(false);
  const dragStartPosition = ref(0);
  const dragStartSplitterPosition = ref(0);
  const currentSplitterPosition = ref(0);
  const getEventPosition = (e2, eventName) => {
    const event = e2.type === eventName ? e2 : e2.changedTouches[0];
    return props.vertical ? event.pageY : event.pageX;
  };
  const startDragging = (e2) => {
    if (props.disabled || !containerSizeComputed.value) {
      return;
    }
    isDragging.value = true;
    dragStartPosition.value = getEventPosition(e2, "mousedown");
    dragStartSplitterPosition.value = splitterPositionComputed.value;
  };
  const processDragging = (e2) => {
    if (!isDragging.value) {
      return;
    }
    const currentPosition = getEventPosition(e2, "mousemove");
    const distance = currentPosition - dragStartPosition.value;
    currentSplitterPosition.value = dragStartSplitterPosition.value + Math.floor(distance / containerSizeComputed.value * 100);
  };
  const stopDragging = () => {
    isDragging.value = false;
  };
  useEvent(["mousemove", "touchmove"], processDragging);
  useEvent(["mouseup", "touchcancel"], stopDragging);
  return { isDragging, startDragging, currentSplitterPosition };
};

// node_modules/vuestic-ui/dist/es/src/components/va-split/VaSplit.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-split/VaSplit.css";
var __defProp90 = Object.defineProperty;
var __defProps80 = Object.defineProperties;
var __getOwnPropDescs80 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols90 = Object.getOwnPropertySymbols;
var __hasOwnProp90 = Object.prototype.hasOwnProperty;
var __propIsEnum90 = Object.prototype.propertyIsEnumerable;
var __defNormalProp90 = (obj, key, value) => key in obj ? __defProp90(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues90 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp90.call(b2, prop))
      __defNormalProp90(a2, prop, b2[prop]);
  if (__getOwnPropSymbols90)
    for (var prop of __getOwnPropSymbols90(b2)) {
      if (__propIsEnum90.call(b2, prop))
        __defNormalProp90(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps80 = (a2, b2) => __defProps80(a2, __getOwnPropDescs80(b2));
var _sfc_main84 = defineComponent({
  name: "VaSplit",
  components: { VaDivider },
  props: __spreadProps80(__spreadValues90(__spreadValues90(__spreadValues90({}, useComponentPresetProp), useSplitDraggerProps), useStatefulProps), {
    modelValue: {
      type: Number,
      default: 50,
      validator: (v2) => v2 <= 100
    },
    maximization: { type: Boolean, default: false },
    maximizeStart: { type: Boolean, default: false },
    limits: {
      type: Array,
      default: () => [0, 0]
    },
    snapping: {
      type: Array,
      default: void 0
    },
    snappingRange: { type: [Number, String], default: 4 }
  }),
  emits: useStatefulEmits,
  setup: (props, { emit }) => {
    const splitPanelsContainer = shallowRef();
    const { valueComputed } = useStateful(props, emit);
    const containerSize = ref();
    const bodyFontSize = ref(16);
    const handleContainerResize = () => {
      var _a;
      const { width, height } = ((_a = splitPanelsContainer.value) == null ? void 0 : _a.getBoundingClientRect()) || { width: 0, height: 0 };
      containerSize.value = props.vertical ? height : width;
      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    onMounted(handleContainerResize);
    useResizeObserver([splitPanelsContainer], handleContainerResize);
    const convertToPercents = (v2, type) => {
      let numberValue = "";
      let measureValue = "";
      if (isNumber_1(v2)) {
        return v2;
      }
      v2.split("").filter((char) => char && char !== " ").forEach((char) => {
        !isNaN(+char) ? numberValue += char : measureValue += char;
      });
      switch (measureValue) {
        case "%":
          return +numberValue;
        case "px":
          return +numberValue / containerSize.value * 100;
        case "rem":
          return +numberValue * bodyFontSize.value / containerSize.value * 100;
        case "any":
          return ["min", "snapping"].includes(type) ? 0 : 100;
        case "":
          return 100;
        default:
          return 0;
      }
    };
    const getPanelMinMax = (v2) => {
      if (v2 === "undefined" || !containerSize.value) {
        return;
      }
      let minPercents = 0;
      let maxPercents = 100;
      if (isString_1(v2) || isNumber_1(v2)) {
        minPercents = convertToPercents(v2, "min");
      }
      if (Array.isArray(v2)) {
        minPercents = convertToPercents(v2[0], "min");
        maxPercents = convertToPercents(v2[1], "max");
      }
      if (minPercents > maxPercents) {
        maxPercents = minPercents;
      }
      return { min: minPercents != null ? minPercents : 0, max: maxPercents != null ? maxPercents : 100 };
    };
    const startPanelMinMax = computed(() => {
      var _a;
      return (_a = getPanelMinMax(props.limits[0])) != null ? _a : { min: 0, max: 100 };
    });
    const endPanelMinMax = computed(() => {
      var _a;
      return (_a = getPanelMinMax(props.limits[1])) != null ? _a : { min: 0, max: 100 };
    });
    const endPanelMinChecked = computed(() => {
      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
    });
    const panelsMinMax = computed(() => {
      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100)
        ;
      return {
        start: {
          min: startPanelMinMax.value.min,
          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
        },
        end: {
          min: endPanelMinChecked.value,
          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
        }
      };
    });
    const checkSnappingLimitsCondition = (el) => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
    const snappingMarksPosition = computed(() => {
      if (!Array.isArray(props.snapping) || !containerSize.value) {
        return;
      }
      let result = props.snapping.map((el) => convertToPercents(el, "snapping"));
      if (!result.every(checkSnappingLimitsCondition)) {
        const filteredMarks = result.filter(checkSnappingLimitsCondition);
        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
        result = filteredMarks;
      }
      const checkSnappingRange = () => {
        return result.every((el, index, array) => {
          if (!array[index + 1]) {
            return true;
          }
          return Math.abs(el - array[index + 1]) > props.snappingRange;
        });
      };
      if (!checkSnappingRange())
        ;
      return result;
    });
    const snappingRangeParsed = computed(() => convertToPercents(props.snappingRange, "snapping"));
    const splitterPosition = ref(valueComputed.value);
    const splitterPositionComputed = computed(() => {
      if (snappingMarksPosition.value) {
        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {
          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
        });
        if (nearestSnappingMark) {
          return nearestSnappingMark;
        }
      }
      return clamp_1(splitterPosition.value, Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max), Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min));
    });
    const {
      isDragging,
      startDragging,
      currentSplitterPosition
    } = useSplitDragger(containerSize, splitterPositionComputed, props);
    const maximizePanel = () => {
      if (!props.maximization || props.disabled) {
        return;
      }
      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
    };
    watch(valueComputed, (v2) => {
      if (v2 < panelsMinMax.value.start.min || v2 > 100 - panelsMinMax.value.end.min)
        ;
      splitterPosition.value = v2;
    }, { immediate: true });
    watch(currentSplitterPosition, (v2) => {
      splitterPosition.value = v2;
    });
    watch(isDragging, (v2) => {
      if (!v2) {
        valueComputed.value = splitterPositionComputed.value;
      }
      document.documentElement.style.cursor = v2 ? "var(--va-split-dragging-cursor)" : "";
    });
    const sizePropertyComputed = computed(() => props.vertical ? "height" : "width");
    const getPanelStyle = (position) => {
      let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
      if (sizeValue < 0) {
        sizeValue = 0;
      }
      if (sizeValue > 100) {
        sizeValue = 100;
      }
      return { [sizePropertyComputed.value]: `${sizeValue}%` };
    };
    const draggerStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (isDragging.value) {
        return { cursor: "var(--va-split-dragging-cursor)" };
      }
      return { cursor: props.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)" };
    });
    const classComputed = useBem("va-split", () => ({
      horizontal: !props.vertical,
      vertical: props.vertical,
      dragging: isDragging.value
    }));
    return __spreadProps80(__spreadValues90({}, useTranslation()), {
      splitPanelsContainer,
      containerSize,
      startDragging,
      getPanelStyle,
      maximizePanel,
      classComputed,
      draggerStyleComputed
    });
  }
});
var _hoisted_160 = ["aria-label"];
var _hoisted_231 = { class: "va-split__dragger" };
function _sfc_render83(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_divider = resolveComponent("va-divider");
  return openBlock(), createElementBlock("section", {
    ref: "splitPanelsContainer",
    class: normalizeClass(["va-split", _ctx.classComputed]),
    "aria-label": _ctx.t("splitPanels")
  }, [
    createBaseVNode("div", {
      class: "va-split__panel",
      style: normalizeStyle(_ctx.getPanelStyle("start"))
    }, [
      renderSlot(_ctx.$slots, "start", normalizeProps(guardReactiveProps({ containerSize: _ctx.containerSize })))
    ], 4),
    createBaseVNode("div", _hoisted_231, [
      createBaseVNode("div", {
        class: "va-split__dragger__overlay",
        style: normalizeStyle(_ctx.draggerStyleComputed),
        onMousedown: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.startDragging && _ctx.startDragging(...args), ["prevent"])),
        onTouchstart: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.startDragging && _ctx.startDragging(...args), ["prevent"])),
        onDblclick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.maximizePanel && _ctx.maximizePanel(...args), ["prevent"])),
        onContextmenu: _cache[3] || (_cache[3] = withModifiers(() => {
        }, ["prevent"])),
        onDragstart: _cache[4] || (_cache[4] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "grabber", {}, () => [
          createVNode(_component_va_divider, {
            class: "va-split__dragger__default",
            vertical: !_ctx.$props.vertical
          }, null, 8, ["vertical"])
        ])
      ], 36)
    ]),
    createBaseVNode("div", {
      class: "va-split__panel",
      style: normalizeStyle(_ctx.getPanelStyle("end"))
    }, [
      renderSlot(_ctx.$slots, "end", normalizeProps(guardReactiveProps({ containerSize: _ctx.containerSize })))
    ], 4)
  ], 10, _hoisted_160);
}
var _VaSplit = _export_sfc(_sfc_main84, [["render", _sfc_render83]]);

// node_modules/vuestic-ui/dist/es/src/components/va-split/index.js
var VaSplit = withConfigTransport(_VaSplit);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/VaTabs.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/types.js
var TabsViewKey = Symbol("TabsView");

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/VaTabs.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-tabs/VaTabs.css";
var __defProp91 = Object.defineProperty;
var __defProps81 = Object.defineProperties;
var __getOwnPropDescs81 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols91 = Object.getOwnPropertySymbols;
var __hasOwnProp91 = Object.prototype.hasOwnProperty;
var __propIsEnum91 = Object.prototype.propertyIsEnumerable;
var __defNormalProp91 = (obj, key, value) => key in obj ? __defProp91(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues91 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp91.call(b2, prop))
      __defNormalProp91(a2, prop, b2[prop]);
  if (__getOwnPropSymbols91)
    for (var prop of __getOwnPropSymbols91(b2)) {
      if (__propIsEnum91.call(b2, prop))
        __defNormalProp91(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps81 = (a2, b2) => __defProps81(a2, __getOwnPropDescs81(b2));
var getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
var _sfc_main85 = defineComponent({
  name: "VaTabs",
  components: { VaButton: VaButton2, VaConfig },
  emits: ["update:modelValue", "click:next", "click:prev"],
  props: __spreadProps81(__spreadValues91(__spreadValues91({}, useStatefulProps), useComponentPresetProp), {
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "va-arrow-left" },
    nextIcon: { type: String, default: "va-arrow-right" }
  }),
  setup: (props, { emit }) => {
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props, emit);
    const tabConfig = reactive({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const sliderStyles = computed(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : ""
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (showPagination.value && leftSidePosition + containerClientWidth <= tabsClientWidth) {
        tabsContentOffset.value = leftSidePosition;
      } else if (showPagination.value && rightSidePosition >= containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
      } else {
        tabsContentOffset.value = 0;
      }
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a;
        tab.updateSidePositions();
        const isTabSelected = (((_a = tab.name) == null ? void 0 : _a.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (tabsContentOffset.value + containerClientWidth > tabsClientWidth && tabsList.value) {
        moveToTab(tabsList.value[0]);
      }
      updateStartingXPoint();
    };
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
    };
    const movePaginationLeft = () => {
      var _a, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      if (tabsList.value) {
        for (let i2 = 0; i2 < tabsList.value.length - 1; i2++) {
          const currentTabLeftSidePosition = unref((_a = tabsList.value[i2]) == null ? void 0 : _a.leftSidePosition);
          const nextTabLeftSidePosition = unref((_b = tabsList.value[i2 + 1]) == null ? void 0 : _b.leftSidePosition);
          if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
            offsetToSet = currentTabLeftSidePosition;
            break;
          }
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:prev");
    };
    const movePaginationRight = () => {
      var _a;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      if (tabsList.value) {
        for (let i2 = 0; i2 < tabsList.value.length - 1; i2++) {
          const rightSidePosition2 = unref(tabsList.value[i2].rightSidePosition);
          if (rightSidePosition2 > containerRightSide) {
            offsetToSet = unref(tabsList.value[i2].leftSidePosition);
            if (tabsContentOffset.value < offsetToSet) {
              break;
            }
          }
        }
      }
      const rightSidePosition = unref((_a = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit("click:next");
    };
    const updateSlider = (tab) => {
      var _a;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a = container.value) == null ? void 0 : _a.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const redrawTabs = () => {
      const oldShowPaginationValue = showPagination.value;
      updatePagination();
      if (oldShowPaginationValue === showPagination.value) {
        updateTabsState();
        includeAnimation();
      } else {
        requestAnimationFrame(() => {
          updateTabsState();
          includeAnimation();
        });
      }
    };
    const selectTab = (tab) => {
      var _a;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a = tab.name) == null ? void 0 : _a.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a = tab.name) == null ? void 0 : _a.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a;
        tabListItem.id = ((_a = tabListItem.name) == null ? void 0 : _a.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper, tabs], redrawTabs);
    return __spreadProps81(__spreadValues91({}, useTranslation()), {
      wrapper,
      container,
      tabs,
      tabsList,
      sliderHeight,
      sliderWidth,
      sliderOffsetX,
      sliderOffsetY,
      showPagination,
      tabsContentOffset,
      startingXPoint,
      animationIncluded,
      colorComputed,
      tabConfig,
      computedClass,
      computedTabsClass,
      tabSelected,
      sliderStyles,
      paginationControlledStyles,
      disablePaginationLeft,
      disablePaginationRight,
      resetSliderSizes,
      moveToTab,
      updateStartingXPoint,
      updateTabsState,
      updatePagination,
      movePaginationLeft,
      movePaginationRight,
      updateSlider,
      includeAnimation,
      redrawTabs,
      selectTab
    });
  }
});
var _hoisted_161 = ["aria-disabled"];
var _hoisted_232 = createBaseVNode("div", { class: "va-tabs__slider" }, null, -1);
var _hoisted_317 = [
  _hoisted_232
];
var _hoisted_411 = { class: "va-tabs__tabs-items" };
var _hoisted_58 = { class: "va-tabs__content" };
function _sfc_render84(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_button = resolveComponent("va-button");
  const _component_va_config = resolveComponent("va-config");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tabs", _ctx.computedTabsClass])
  }, [
    createBaseVNode("div", {
      ref: "wrapper",
      class: "va-tabs__wrapper",
      role: "tablist",
      "aria-disabled": _ctx.$props.disabled
    }, [
      _ctx.showPagination ? (openBlock(), createBlock(_component_va_button, {
        key: 0,
        class: "va-tabs__pagination",
        "aria-label": _ctx.t("movePaginationLeft"),
        size: "medium",
        disabled: _ctx.disablePaginationLeft,
        color: _ctx.color,
        flat: "",
        icon: _ctx.$props.prevIcon,
        onClick: _ctx.movePaginationLeft
      }, null, 8, ["aria-label", "disabled", "color", "icon", "onClick"])) : createCommentVNode("", true),
      createBaseVNode("div", {
        ref: "container",
        class: normalizeClass(["va-tabs__container", _ctx.computedClass])
      }, [
        createBaseVNode("div", {
          ref: "tabs",
          class: "va-tabs__tabs",
          style: normalizeStyle(_ctx.paginationControlledStyles)
        }, [
          createBaseVNode("div", {
            class: "va-tabs__slider-wrapper",
            "aria-hidden": "true",
            style: normalizeStyle(_ctx.sliderStyles)
          }, _hoisted_317, 4),
          createVNode(_component_va_config, { components: _ctx.tabConfig }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_411, [
                renderSlot(_ctx.$slots, "tabs")
              ])
            ]),
            _: 3
          }, 8, ["components"])
        ], 4)
      ], 2),
      _ctx.showPagination ? (openBlock(), createBlock(_component_va_button, {
        key: 1,
        class: "va-tabs__pagination",
        "aria-label": _ctx.t("movePaginationRight"),
        size: "medium",
        color: _ctx.color,
        disabled: _ctx.disablePaginationRight,
        flat: "",
        icon: _ctx.$props.nextIcon,
        onClick: _ctx.movePaginationRight
      }, null, 8, ["aria-label", "color", "disabled", "icon", "onClick"])) : createCommentVNode("", true)
    ], 8, _hoisted_161),
    createBaseVNode("div", _hoisted_58, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2);
}
var _VaTabs = _export_sfc(_sfc_main85, [["render", _sfc_render84]]);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/index.js
var VaTabs = withConfigTransport(_VaTabs);

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/VaTimeInput.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/hooks/time-text-parser.js
init_vue_runtime_esm_bundler();
var parse = (text) => {
  const m2 = text.match(/[0-9]{1,2}/g);
  if (!m2) {
    return [];
  }
  return m2.map((s2) => Number(s2));
};
var parsePeriod = (text) => {
  const m2 = text.match(/pm|am/i);
  if (!m2) {
    return null;
  }
  return Number(m2[0].toLowerCase() === "pm");
};
var defaultParseDateFunction2 = (text) => {
  const d2 = new Date();
  const [h3, m2, s2] = parse(text);
  const period = parsePeriod(text);
  if (!h3) {
    return null;
  }
  const is12format = period !== null && h3 <= 12;
  const isPM = is12format && !!period;
  const fh = is12format ? h3 === 12 ? 0 : h3 : h3;
  d2.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
  d2.setMinutes(Math.min(m2 || 0, 60));
  d2.setSeconds(Math.min(s2 || 0, 60));
  return d2;
};
var useTimeParser = (props) => {
  const getParseDateFn = () => props.parse || defaultParseDateFunction2;
  const isValid = ref(true);
  const parseDate = (text) => {
    const parse3 = getParseDateFn();
    const result = parse3(text);
    if (!result) {
      isValid.value = false;
    }
    return result;
  };
  const parse2 = (text) => {
    isValid.value = true;
    return parseDate(text);
  };
  return {
    parse: parse2,
    isValid
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/hooks/time-text-formatter.js
var useTimeFormatter = (props) => {
  const formatDate = (date) => {
    if (!date) {
      return "";
    }
    if (props.ampm) {
      return date.toLocaleTimeString("en-US");
    }
    return date.toLocaleTimeString("en-GB");
  };
  const sliceTime = (time, start, end) => time.split(":").slice(start, end).join(":");
  const formatWithView = (date) => {
    if (props.view === "seconds") {
      return formatDate(date);
    }
    const [time, period] = formatDate(date).split(" ");
    if (props.view === "minutes") {
      if (!period) {
        return sliceTime(time, 0, 2);
      }
      return [sliceTime(time, 0, 2), period].join(" ");
    }
    if (props.view === "hours") {
      if (!period) {
        return sliceTime(time, 0, 1);
      }
      return [sliceTime(time, 0, 1), period].join(" ");
    }
    return "";
  };
  return {
    format: (date) => props.format ? props.format(date) : formatWithView(date)
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/VaTimePicker.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/hooks/useTimePicker.js
init_vue_runtime_esm_bundler();
var safeModelValue = (m2) => m2.value ? m2.value : new Date(new Date().setHours(0, 0, 0, 0));
var createNumbersArray = (length) => Array.from(Array(length).keys());
var from24to12 = (h3) => (h3 === 0 ? 12 : h3) - Number(h3 > 12) * 12;
var from12to24 = (h3, isAM = false) => (h3 === 12 ? 0 : h3) + Number(isAM) * 12;
var createHoursColumn = (props, modelValue, isPM) => {
  const computedSize = computed(() => props.ampm ? 12 : 24);
  const items2 = computed(() => {
    let array = createNumbersArray(computedSize.value);
    if (props.hoursFilter) {
      array = array.filter((i2) => props.hoursFilter(props.ampm ? i2 + 12 * Number(isPM.value) : i2));
    }
    return array.map((n2) => {
      return props.ampm ? from24to12(n2) : n2;
    });
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      if (props.ampm) {
        const h22 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
        return items2.value.findIndex((i2) => i2 === h22);
      }
      const h3 = modelValue.value.getHours();
      return items2.value.findIndex((i2) => i2 === h3);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const hours = props.ampm ? from12to24(items2.value[newIndex], isPM.value) : items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createMinutesColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.minutesFilter) {
      return array;
    }
    return array.filter(props.minutesFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const m2 = modelValue.value.getMinutes();
      return items2.value.findIndex((i2) => i2 === m2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v2 = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v2));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createSecondsColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.secondsFilter) {
      return array;
    }
    return array.filter(props.secondsFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const s2 = modelValue.value.getSeconds();
      return items2.value.findIndex((i2) => i2 === s2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v2 = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v2));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
var createPeriodColumn = (props, modelValue, isPM) => {
  return computed(() => ({
    items: ["AM", "PM"],
    activeItem: computed({
      get: () => {
        if (!modelValue.value) {
          return -1;
        }
        return Number(isPM.value);
      },
      set: (val) => {
        isPM.value = Boolean(val);
        const h3 = safeModelValue(modelValue).getHours();
        let h24 = isPM.value ? h3 + 12 : h3;
        if (isPM.value && h3 <= 12) {
          h24 = h3 + 12;
        }
        if (!isPM.value && h3 >= 12) {
          h24 = h3 - 12;
        }
        const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
        if (props.periodUpdatesModelValue && isValidFilteredHour) {
          modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
        }
      }
    })
  }));
};
var useTimePicker = (props, modelValue) => {
  const { view } = toRefs(props);
  const isPM = ref(false);
  watch(modelValue, () => {
    isPM.value = safeModelValue(modelValue).getHours() >= 12;
  }, { immediate: true });
  const hoursColumn = createHoursColumn(props, modelValue, isPM);
  const minutesColumn = createMinutesColumn(props, modelValue);
  const secondsColumn = createSecondsColumn(props, modelValue);
  const periodColumn = createPeriodColumn(props, modelValue, isPM);
  const columns = computed(() => {
    const array = [];
    if (view.value === "hours") {
      array.push(hoursColumn.value);
    } else if (view.value === "minutes") {
      array.push(hoursColumn.value, minutesColumn.value);
    } else if (view.value === "seconds") {
      array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
    }
    if (props.ampm && !props.hidePeriodSwitch) {
      array.push(periodColumn.value);
    }
    return array;
  });
  return {
    columns,
    isPM
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumnCell.js
init_vue_runtime_esm_bundler();
var _sfc_main86 = defineComponent({
  name: "VaTimePickerColumnCell",
  setup() {
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const { getTextColor, getColor } = useColors();
    const styleComputed = computed(() => isHovered.value ? {
      color: getColor(getTextColor(getColor("background-secondary"))),
      background: getColor("background-secondary")
    } : void 0);
    return {
      onMouseEnter,
      onMouseLeave,
      styleComputed
    };
  }
});
function _sfc_render85(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
    style: normalizeStyle(_ctx.styleComputed)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 36);
}
var VaTimePickerColumnCell = _export_sfc(_sfc_main86, [["render", _sfc_render85]]);

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/VaTimePickerColumn.css";
var _sfc_main87 = defineComponent({
  name: "VaTimePickerColumn",
  components: { VaTimePickerColumnCell },
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: Number, default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { focus, blur } = useFocus(rootElement, emit);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props, emit);
    watch(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick(() => {
        var _a, _b;
        (_b = (_a = rootElement.value) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
          behavior: animated ? "smooth" : "auto",
          top: index * props.cellHeight
        });
      });
    };
    const makeActiveByIndex = (index) => {
      syncActiveItemIndex.value = index;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - (times || 1) + props.items.length) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n2) => {
      if (!Number.isInteger(n2)) {
        return n2;
      }
      return n2 < 10 ? `0${n2}` : `${n2}`;
    };
    const { background } = useElementBackground(rootElement);
    const { textColorComputed } = useTextColor(background);
    const styleComputed = computed(() => ({
      color: textColorComputed.value
    }));
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max((scrollTop - scrollTop % props.cellHeight) / props.cellHeight, scrollTop / props.cellHeight);
      if (syncActiveItemIndex.value * props.cellHeight < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * props.cellHeight > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce_1(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    return {
      rootElement,
      makeActiveNext,
      makeActivePrev,
      makeActiveByIndex,
      onScroll,
      onCellClick,
      formatCell,
      styleComputed,
      focus,
      blur
    };
  }
});
var _hoisted_163 = ["onClick"];
function _sfc_render86(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumnCell = resolveComponent("VaTimePickerColumnCell");
  return openBlock(), createElementBlock("div", {
    ref: "rootElement",
    tabindex: "0",
    class: "va-time-picker-column",
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(), ["stop", "prevent"]), ["down"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.makeActiveNext(5), ["stop", "prevent"]), ["space"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.makeActivePrev(), ["stop", "prevent"]), ["up"]))
    ],
    style: normalizeStyle(_ctx.styleComputed)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item, index) => {
      return openBlock(), createBlock(_component_VaTimePickerColumnCell, {
        key: item,
        onScrollPassive: _ctx.onScroll,
        onTouchmovePassive: _ctx.onScroll,
        onMousewheelPassive: _ctx.onScroll
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(["va-time-picker-cell", { "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex }]),
            onClick: ($event) => _ctx.onCellClick(index)
          }, [
            renderSlot(_ctx.$slots, "cell", normalizeProps(guardReactiveProps({ item, index, activeItemIndex: _ctx.activeItemIndex, items: _ctx.items, formattedItem: _ctx.formatCell(item) })), () => [
              createTextVNode(toDisplayString(_ctx.formatCell(item)), 1)
            ])
          ], 10, _hoisted_163)
        ]),
        _: 2
      }, 1032, ["onScrollPassive", "onTouchmovePassive", "onMousewheelPassive"]);
    }), 128))
  ], 36);
}
var _VaTimePickerColumn = _export_sfc(_sfc_main87, [["render", _sfc_render86]]);

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/components/VaTimePickerColumn/index.js
var VaTimePickerColumn = withConfigTransport(_VaTimePickerColumn);

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/VaTimePicker.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-time-picker/VaTimePicker.css";
var __defProp92 = Object.defineProperty;
var __defProps82 = Object.defineProperties;
var __getOwnPropDescs82 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols92 = Object.getOwnPropertySymbols;
var __hasOwnProp92 = Object.prototype.hasOwnProperty;
var __propIsEnum92 = Object.prototype.propertyIsEnumerable;
var __defNormalProp92 = (obj, key, value) => key in obj ? __defProp92(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues92 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp92.call(b2, prop))
      __defNormalProp92(a2, prop, b2[prop]);
  if (__getOwnPropSymbols92)
    for (var prop of __getOwnPropSymbols92(b2)) {
      if (__propIsEnum92.call(b2, prop))
        __defNormalProp92(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps82 = (a2, b2) => __defProps82(a2, __getOwnPropDescs82(b2));
var _sfc_main88 = defineComponent({
  name: "VaTimePicker",
  components: { VaTimePickerColumn },
  props: __spreadProps82(__spreadValues92(__spreadValues92(__spreadValues92({}, useStatefulProps), useFormProps), useComponentPresetProp), {
    modelValue: { type: Date, required: false },
    ampm: { type: Boolean, default: false },
    hidePeriodSwitch: { type: Boolean, default: false },
    periodUpdatesModelValue: { type: Boolean, default: true },
    view: { type: String, default: "minutes" },
    hoursFilter: { type: Function },
    minutesFilter: { type: Function },
    secondsFilter: { type: Function },
    framed: { type: Boolean, default: false },
    cellHeight: { type: Number, default: 30 },
    visibleCellsCount: { type: Number, default: 7 }
  }),
  emits: useStatefulEmits,
  setup(props, { emit }) {
    const { valueComputed } = useStateful(props, emit);
    const { columns, isPM } = useTimePicker(props, valueComputed);
    const { setItemRef, itemRefs: pickers } = useArrayRefs();
    const activeColumnIndex = ref();
    const focus = (idx = 0) => {
      var _a;
      (_a = pickers.value[idx]) == null ? void 0 : _a.focus();
    };
    const blur = (idx) => {
      var _a;
      idx ? (_a = pickers.value[idx]) == null ? void 0 : _a.blur() : pickers.value.forEach((el) => el == null ? void 0 : el.blur());
    };
    const { computedClasses: computedFormClasses } = useForm("va-time-picker", props);
    const focusNext = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) + 1;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const focusPrev = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const computedClasses = computed(() => __spreadProps82(__spreadValues92({}, computedFormClasses), {
      "va-time-picker--framed": props.framed
    }));
    const computedStyles = useCSSVariables("va-time-picker", () => {
      const gapHeight = (props.visibleCellsCount - 1) / 2 * props.cellHeight;
      return {
        height: `${props.cellHeight * props.visibleCellsCount}px`,
        "cell-height": `${props.cellHeight}px`,
        "column-gap-height": `${gapHeight}px`
      };
    });
    return {
      columns,
      computedStyles,
      computedClasses,
      isPM,
      pickers,
      setItemRef,
      focusNext,
      focusPrev,
      activeColumnIndex,
      focus,
      blur
    };
  }
});
function _sfc_render87(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaTimePickerColumn = resolveComponent("VaTimePickerColumn");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-time-picker", _ctx.computedClasses]),
    style: normalizeStyle(_ctx.computedStyles)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (column, idx) => {
      return openBlock(), createBlock(_component_VaTimePickerColumn, {
        key: idx,
        ref_for: true,
        ref: _ctx.setItemRef,
        items: column.items,
        tabindex: _ctx.disabled ? -1 : 0,
        "cell-height": _ctx.$props.cellHeight,
        activeItemIndex: column.activeItem.value,
        "onUpdate:activeItemIndex": ($event) => column.activeItem.value = $event,
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["stop", "prevent"]), ["right"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.focusNext(), ["exact", "stop", "prevent"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["stop", "prevent"]), ["left"])),
          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.focusPrev(), ["shift", "stop", "prevent"]), ["tab"]))
        ],
        onFocus: ($event) => _ctx.activeColumnIndex = idx
      }, null, 8, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]);
    }), 128))
  ], 6);
}
var _VaTimePicker = _export_sfc(_sfc_main88, [["render", _sfc_render87]]);

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/VaTimeInput.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-time-input/VaTimeInput.css";
var __defProp93 = Object.defineProperty;
var __defProps83 = Object.defineProperties;
var __getOwnPropDescs83 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols93 = Object.getOwnPropertySymbols;
var __hasOwnProp93 = Object.prototype.hasOwnProperty;
var __propIsEnum93 = Object.prototype.propertyIsEnumerable;
var __defNormalProp93 = (obj, key, value) => key in obj ? __defProp93(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues93 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp93.call(b2, prop))
      __defNormalProp93(a2, prop, b2[prop]);
  if (__getOwnPropSymbols93)
    for (var prop of __getOwnPropSymbols93(b2)) {
      if (__propIsEnum93.call(b2, prop))
        __defNormalProp93(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps83 = (a2, b2) => __defProps83(a2, __getOwnPropDescs83(b2));
var VaInputWrapperProps2 = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue", "disabled"]);
var VaDropdownProps5 = extractComponentProps(VaDropdown, ["keyboardNavigation", "offset", "placement", "closeOnContentClick", "innerAnchorSelector", "modelValue"]);
var _sfc_main89 = defineComponent({
  name: "VaTimeInput",
  components: { VaDropdown, VaDropdownContent, VaTimePicker: _VaTimePicker, VaIcon, VaInputWrapper },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    "update:modelValue",
    "update:isOpen"
  ],
  props: __spreadProps83(__spreadValues93(__spreadValues93(__spreadValues93(__spreadValues93(__spreadValues93(__spreadValues93({}, VaDropdownProps5), useComponentPresetProp), useClearableProps), VaInputWrapperProps2), extractComponentProps(_VaTimePicker)), useValidationProps), {
    isOpen: { type: Boolean, default: void 0 },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: void 0 },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" }
  }),
  inheritAttrs: false,
  setup(props, { emit, slots, attrs }) {
    const input = shallowRef();
    const timePicker = shallowRef();
    const [isOpenSync] = useSyncProp("isOpen", props, emit, false);
    const [modelValueSync] = useSyncProp("modelValue", props, emit);
    const { parse: parse2, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(modelValueSync.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v2) {
        isOpenSync.value = v2;
        if (v2) {
          nextTick(() => {
            var _a;
            return (_a = timePicker.value) == null ? void 0 : _a.focus();
          });
        } else {
          nextTick(() => {
            var _a;
            return (_a = input.value) == null ? void 0 : _a.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e2) => {
      var _a;
      const val = (_a = e2.target) == null ? void 0 : _a.value;
      if (!val) {
        return reset();
      }
      const v2 = parse2(val);
      if (isValid.value && v2) {
        modelValueSync.value = v2;
      } else {
        modelValueSync.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit("update:modelValue", props.clearValue);
      emit("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const computedInputWrapperProps = computed(() => __spreadProps83(__spreadValues93({}, filterComponentProps(props, VaInputWrapperProps2).value), {
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
        listeners.onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e2) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      return props.manualInput && (e2 == null ? void 0 : e2.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => props.disabled || props.readonly ? -1 : 0);
    const iconProps = computed(() => ({
      role: "button",
      ariaHidden: false,
      size: "small",
      name: props.icon,
      color: props.color,
      tabindex: iconTabindexComputed.value
    }));
    const { t: t2 } = useTranslation();
    const inputAttributesComputed = computed(() => __spreadValues93(__spreadValues93({
      readonly: props.readonly || !props.manualInput,
      tabindex: props.disabled ? -1 : 0,
      value: valueText.value,
      ariaLabel: props.label || t2("selectedTime"),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly
    }, validationAriaAttributes.value), omit_1(attrs, ["class", "style"])));
    const dropdownPropsComputed = computed(() => __spreadProps83(__spreadValues93({}, filterComponentProps(props, VaDropdownProps5).value), {
      closeOnContentClick: false,
      offset: [2, 0],
      keyboardNavigation: true,
      placement: "bottom-start",
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    return {
      t: t2,
      input,
      timePicker,
      timePickerProps: filterComponentProps(props, extractComponentProps(_VaTimePicker)),
      dropdownPropsComputed,
      computedInputWrapperProps,
      computedInputListeners,
      isOpenSync,
      doShowDropdown,
      modelValueSync,
      valueText,
      onInputTextChanged,
      canBeClearedComputed,
      iconProps,
      clearIconProps,
      filteredSlots,
      inputAttributesComputed,
      cursorStyleComputed,
      hideDropdown,
      showDropdown,
      toggleDropdown,
      reset,
      focus,
      blur
    };
  }
});
function _sfc_render88(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_time_picker = resolveComponent("va-time-picker");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    modelValue: _ctx.doShowDropdown,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.doShowDropdown = $event),
    class: ["va-time-input", _ctx.$attrs.class],
    style: _ctx.$attrs.style
  }, _ctx.dropdownPropsComputed), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, mergeProps({
        class: "va-time-input__anchor",
        style: _ctx.cursorStyleComputed
      }, _ctx.computedInputWrapperProps), createSlots({
        default: withCtx(() => [
          createBaseVNode("input", mergeProps({
            ref: "input",
            class: "va-time-input__input"
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.computedInputListeners), {
            onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onInputTextChanged && _ctx.onInputTextChanged(...args))
          }), null, 16)
        ]),
        icon: withCtx(() => [
          _ctx.canBeClearedComputed ? (openBlock(), createBlock(_component_va_icon, mergeProps({ key: 0 }, __spreadValues93(__spreadValues93({}, _ctx.iconProps), _ctx.clearIconProps), {
            "aria-label": _ctx.t("resetTime"),
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : !_ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 1,
            "aria-label": _ctx.t("toggleDropdown")
          }, _ctx.iconProps), null, 16, ["aria-label"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(_ctx.filteredSlots, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(__spreadProps83(__spreadValues93({}, slotScope), { toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus }))))
            ])
          };
        }),
        _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
          name: "prependInner",
          fn: withCtx((slotScope) => [
            renderSlot(_ctx.$slots, "prependInner", normalizeProps(guardReactiveProps(__spreadProps83(__spreadValues93({}, slotScope), { toggleDropdown: _ctx.toggleDropdown, showDropdown: _ctx.showDropdown, hideDropdown: _ctx.hideDropdown, isOpen: _ctx.isOpenSync, focus: _ctx.focus })))),
            _ctx.$props.leftIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
              key: 0,
              "aria-label": _ctx.t("toggleDropdown")
            }, _ctx.iconProps), null, 16, ["aria-label"])) : createCommentVNode("", true)
          ])
        } : void 0
      ]), 1040, ["style"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        "no-padding": "",
        onKeydown: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["esc"]),
        onKeypress: withKeys(withModifiers(_ctx.hideDropdown, ["prevent"]), ["enter"])
      }, {
        default: withCtx(() => [
          createVNode(_component_va_time_picker, mergeProps({ ref: "timePicker" }, _ctx.timePickerProps, {
            modelValue: _ctx.modelValueSync,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.modelValueSync = $event)
          }), null, 16, ["modelValue"])
        ]),
        _: 1
      }, 8, ["onKeydown", "onKeypress"])
    ]),
    _: 3
  }, 16, ["modelValue", "class", "style"]);
}
var _VaTimeInput = _export_sfc(_sfc_main89, [["render", _sfc_render88]]);

// node_modules/vuestic-ui/dist/es/src/components/va-time-input/index.js
var VaTimeInput = withConfigTransport(_VaTimeInput);

// node_modules/vuestic-ui/dist/es/src/components/va-time-picker/index.js
var VaTimePicker = withConfigTransport(_VaTimePicker);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimeline.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimeline.css";
var __defProp94 = Object.defineProperty;
var __defProps84 = Object.defineProperties;
var __getOwnPropDescs84 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols94 = Object.getOwnPropertySymbols;
var __hasOwnProp94 = Object.prototype.hasOwnProperty;
var __propIsEnum94 = Object.prototype.propertyIsEnumerable;
var __defNormalProp94 = (obj, key, value) => key in obj ? __defProp94(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues94 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp94.call(b2, prop))
      __defNormalProp94(a2, prop, b2[prop]);
  if (__getOwnPropSymbols94)
    for (var prop of __getOwnPropSymbols94(b2)) {
      if (__propIsEnum94.call(b2, prop))
        __defNormalProp94(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps84 = (a2, b2) => __defProps84(a2, __getOwnPropDescs84(b2));
var getPropsData = (slot) => slot == null ? void 0 : slot.props;
var getIsActive = (slot) => {
  var _a;
  return !!((_a = slot == null ? void 0 : slot.props) == null ? void 0 : _a.active) || false;
};
var isVueFragment = (slot) => slot.type === Fragment;
var isEmptyArray = (arr) => arr && arr.length === 0;
function getSlots(slots) {
  var _a;
  const defaultSlots = (_a = slots.default) == null ? void 0 : _a.call(slots);
  if (!defaultSlots || isEmptyArray(defaultSlots)) {
    return [];
  }
  if (isVueFragment(defaultSlots[0])) {
    return defaultSlots[0].children;
  }
  return defaultSlots;
}
var processSlots = (context) => {
  const slots = getSlots(context.slots);
  slots.forEach((slot, index) => {
    if (!getPropsData(slot)) {
      slot.props = {};
    }
    const propsData = getPropsData(slot);
    propsData.vertical = context.props.vertical;
    if (context.props.centered) {
      propsData.inverted = !!(index % 2);
    }
    if (index === 0) {
      propsData.isFirst = true;
    }
    if (index === slots.length - 1) {
      propsData.isLast = true;
    }
    const currentSlotActive = propsData.active;
    if (!currentSlotActive) {
      return;
    }
    if (index === 0) {
      propsData.activePrevious = currentSlotActive;
    }
    if (index === slots.length - 1) {
      propsData.activeNext = currentSlotActive;
    }
    const previousSlotActive = getIsActive(slots[index - 1]);
    if (previousSlotActive) {
      propsData.activePrevious = true;
    }
    const nextSlotActive = getIsActive(slots[index + 1]);
    if (nextSlotActive) {
      propsData.activeNext = true;
    }
  });
  return slots;
};
var COMPONENT_NAME = "va-timeline";
var _sfc_main90 = {
  name: COMPONENT_NAME,
  props: __spreadProps84(__spreadValues94({}, useComponentPresetProp), {
    vertical: { type: Boolean },
    centered: { type: Boolean },
    alignTop: { type: Boolean }
  }),
  setup(props, { slots }) {
    return () => h("div", {
      class: {
        [COMPONENT_NAME]: true,
        [`${COMPONENT_NAME}--vertical`]: props.vertical,
        [`${COMPONENT_NAME}--align-top`]: props.alignTop
      }
    }, processSlots({ props, slots }));
  }
};

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/index.js
var VaTimeline = withConfigTransport(_sfc_main90);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/VaTreeView.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeView.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeHelpers.js
var useTreeViewProps = {
  nodes: {
    type: Array,
    default: []
  },
  stateful: {
    type: Boolean,
    default: true
  },
  selectable: {
    type: Boolean,
    default: false
  },
  selectionType: {
    type: String,
    default: "leaf",
    validator: (v2) => ["leaf", "independent"].includes(v2)
  },
  valueBy: {
    type: [String, Function],
    default: "id"
  },
  textBy: {
    type: [String, Function],
    default: "label"
  },
  trackBy: {
    type: [String, Function],
    default: "id"
  },
  iconBy: {
    type: [String, Function],
    default: "icon"
  },
  disabledBy: {
    type: [String, Function],
    default: "disabled"
  },
  expandedBy: {
    type: [String, Function],
    default: "expanded"
  },
  checkedBy: {
    type: [String, Function],
    default: "checked"
  },
  expandAll: {
    type: Boolean,
    default: false
  },
  expanded: {
    type: Array,
    default: []
  },
  filter: {
    type: String,
    default: ""
  },
  filterMethod: {
    type: Function,
    default: void 0
  },
  checked: {
    type: Array,
    default: []
  },
  color: {
    type: String,
    default: "primary"
  }
};
var useTreeViewEmits = ["update:modelValue", "update:checked", "update:expanded"];
var useTreeHelpers = (props) => {
  const isStringOrNumber = (node) => {
    const typeOfNode = typeof node;
    return typeOfNode === "string" || typeOfNode === "number";
  };
  const getNodeProperty = (node, key) => !key || isStringOrNumber(node) ? node : getValueByKey(node, key);
  const getValue2 = (node) => getNodeProperty(node, props.valueBy);
  const getNodeByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.nodes.find((node) => value === getValue2(node)) || value;
  };
  const getText = (node) => getNodeProperty(node, props.textBy);
  const getChecked = (node) => getNodeProperty(node, props.checkedBy);
  const getDisabled = (node) => getNodeProperty(node, props.disabledBy);
  const getExpanded = (node) => getNodeProperty(node, props.expandedBy);
  const getTrackBy = (node) => getNodeProperty(node, props.trackBy);
  const iterateNodes = (nodes, cb) => {
    nodes.forEach((node) => {
      const children = node.children || [];
      if (children.length) {
        iterateNodes(children, cb);
      }
      cb(node);
    });
  };
  return {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeByValue,
    getNodeProperty
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/types.js
var TreeViewKey = Symbol("TreeView");

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/hooks/useTreeView.js
var __defProp95 = Object.defineProperty;
var __defProps85 = Object.defineProperties;
var __getOwnPropDescs85 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols95 = Object.getOwnPropertySymbols;
var __hasOwnProp95 = Object.prototype.hasOwnProperty;
var __propIsEnum95 = Object.prototype.propertyIsEnumerable;
var __defNormalProp95 = (obj, key, value) => key in obj ? __defProp95(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues95 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp95.call(b2, prop))
      __defNormalProp95(a2, prop, b2[prop]);
  if (__getOwnPropSymbols95)
    for (var prop of __getOwnPropSymbols95(b2)) {
      if (__propIsEnum95.call(b2, prop))
        __defNormalProp95(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps85 = (a2, b2) => __defProps85(a2, __getOwnPropDescs85(b2));
var useTreeView = (props, emit) => {
  const { getColor } = useColors();
  const colorComputed = computed(() => getColor(props.color));
  const isLeafSelectionComputed = computed(() => props.selectionType === "leaf");
  const {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeProperty
  } = useTreeHelpers(props);
  const { nodes, expandAll, filter, filterMethod, textBy } = toRefs(props);
  const { valueComputed: expandedList } = useStateful(props, emit, "expanded");
  const { valueComputed: checkedList } = useStateful(props, emit, "checked");
  const updateModel = (model, values, state) => {
    if (state) {
      model.value = model.value.concat(values).filter((value, idx, self2) => self2.indexOf(value) === idx);
    } else {
      model.value = model.value.filter((v2) => !values.includes(v2));
    }
  };
  const toggleCheckbox = (node, state) => {
    let stateValue = state === null ? true : state;
    if (state && node.indeterminate) {
      stateValue = false;
    }
    const values = [getValue2(node)];
    if (isLeafSelectionComputed.value && node.hasChildren) {
      const toggleChildren = (nodes2) => {
        nodes2.forEach((node2) => {
          var _a;
          if (node2.disabled) {
            return;
          }
          if ((_a = node2.children) == null ? void 0 : _a.length) {
            toggleChildren(node2.children);
          }
          values.push(getValue2(node2));
        });
      };
      toggleChildren(node.children);
    }
    updateModel(checkedList, values, stateValue);
  };
  const toggleNode = (node) => {
    if (node.hasChildren) {
      updateModel(expandedList, [getValue2(node)], !node.expanded);
    }
  };
  const createNode = ({ node, level, children = [], computedFilterMethod: computedFilterMethod2 }) => {
    var _a;
    const valueBy = getValue2(node);
    let matchesFilter = true;
    const hasChildren = !!children.length;
    const disabled = getDisabled(node) || false;
    let indeterminate = false;
    let checked = checkedList.value.includes(valueBy) || false;
    if (isLeafSelectionComputed.value && hasChildren) {
      const isAllChildrenChecked = children.every((c2) => c2.checked);
      checked = isAllChildrenChecked;
      indeterminate = !isAllChildrenChecked && children.some((c2) => c2.indeterminate || c2.checked);
      if (indeterminate) {
        checked = null;
      }
    }
    if (filter.value) {
      matchesFilter = (children == null ? void 0 : children.some((c2) => c2.matchesFilter)) || ((_a = computedFilterMethod2.value) == null ? void 0 : _a.call(computedFilterMethod2, node, filter.value, textBy.value));
    }
    return __spreadProps85(__spreadValues95({}, node), {
      level,
      checked,
      children,
      disabled,
      expanded: expandedList.value.includes(valueBy) || false,
      hasChildren,
      matchesFilter,
      indeterminate
    });
  };
  const computedFilterMethod = computed(() => {
    if (filterMethod == null ? void 0 : filterMethod.value) {
      return filterMethod.value;
    }
    return (node, filter2) => getText(node).toLowerCase().includes(filter2.toLowerCase());
  });
  const buildTree = (nodes2, level = 0) => nodes2.map((node) => {
    var _a;
    if ((_a = node.children) == null ? void 0 : _a.length) {
      const children = buildTree(node.children, level + 1);
      return createNode({ node, level, children, computedFilterMethod });
    }
    return createNode({ node, level, computedFilterMethod, children: [] });
  });
  const getFilteredNodes = (nodes2) => nodes2.slice().filter((node) => {
    if (node.hasChildren) {
      getFilteredNodes(node.children.slice());
    }
    return node.matchesFilter ? node : false;
  });
  provide(TreeViewKey, {
    colorComputed,
    iconBy: props.iconBy,
    selectable: props.selectable,
    getText,
    getTrackBy,
    toggleNode,
    toggleCheckbox,
    getNodeProperty
  });
  const treeItems = computed(() => buildTree(nodes.value));
  const checkForInitialValues = () => {
    const expandedValues = [];
    const checkedValues = [];
    iterateNodes(nodes.value, (node) => {
      if (expandAll.value) {
        expandedValues.push(getValue2(node));
      } else {
        getExpanded(node) && expandedValues.push(getValue2(node));
      }
      if (getChecked(node)) {
        checkedValues.push(getValue2(node));
      }
    });
    if (expandedValues.length) {
      updateModel(expandedList, expandedValues, true);
    }
    if (checkedValues.length) {
      updateModel(checkedList, checkedValues, true);
    }
  };
  checkForInitialValues();
  return {
    treeItems: computed(() => getFilteredNodes(treeItems.value)),
    getText,
    getTrackBy,
    toggleCheckbox
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/components/VaTreeNode/VaTreeNode.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-tree-view/components/VaTreeNode/VaTreeNode.css";
var INJECTION_ERROR_MESSAGE5 = "The VaTreeNode component should be used in the context of VaTreeView component";
var _sfc_main91 = defineComponent({
  name: "VaTreeNode",
  props: {
    node: {
      type: Object,
      required: true
    }
  },
  components: { VaCheckbox, VaIcon: VaIcon2 },
  setup: (props) => {
    const {
      iconBy,
      selectable,
      colorComputed,
      getText,
      getTrackBy,
      toggleNode,
      getNodeProperty,
      toggleCheckbox
    } = useStrictInject(TreeViewKey, INJECTION_ERROR_MESSAGE5);
    const labelComputed = computed(() => getText(props.node) || "");
    const isExpandedComputed = computed(() => !!props.node.expanded);
    const iconComputed = computed(() => getNodeProperty(props.node, iconBy));
    const treeNodeClassComputed = useBem("va-tree-node", () => ({
      disabled: !!props.node.disabled
    }));
    const expandedClassComputed = useBem("va-tree-node-children", () => ({
      expanded: isExpandedComputed.value
    }));
    const indentClassComputed = useBem("va-tree-node-content", () => ({
      indent: props.node.hasChildren === false
    }));
    const tabIndexComputed = computed(() => props.node.disabled ? -1 : 0);
    const handleToggleNode = (event, node) => {
      var _a;
      if (node.expanded) {
        (_a = event.target) == null ? void 0 : _a.blur();
      } else {
        toggleNode(node);
      }
    };
    return {
      selectable,
      getText,
      getTrackBy,
      toggleNode,
      handleToggleNode,
      toggleCheckbox,
      iconComputed,
      labelComputed,
      colorComputed,
      tabIndexComputed,
      indentClassComputed,
      isExpandedComputed,
      expandedClassComputed,
      treeNodeClassComputed
    };
  }
});
var _hoisted_164 = ["aria-expanded", "aria-disabled", "aria-checked", "tabindex"];
var _hoisted_233 = {
  key: 0,
  class: "va-tree-node-content__item va-tree-node-content__item--leaf"
};
var _hoisted_318 = {
  key: 2,
  class: "va-tree-node-content__item"
};
var _hoisted_412 = { class: "va-tree-node-content__body" };
var _hoisted_59 = ["aria-hidden"];
function _sfc_render89(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_checkbox = resolveComponent("va-checkbox");
  const _component_va_tree_node = resolveComponent("va-tree-node", true);
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-tree-node", _ctx.treeNodeClassComputed]),
    role: "treeitem",
    "aria-expanded": _ctx.$props.node.expanded,
    "aria-disabled": _ctx.$props.node.disabled,
    "aria-checked": !!_ctx.$props.node.checked,
    tabindex: _ctx.tabIndexComputed,
    onKeydown: [
      _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.handleToggleNode($event, _ctx.$props.node), ["stop", "prevent"]), ["right"])),
      _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleToggleNode($event, _ctx.$props.node), ["stop", "prevent"]), ["left"]))
    ]
  }, [
    createBaseVNode("div", {
      class: "va-tree-node-root",
      onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.toggleNode(_ctx.$props.node), ["stop"]))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["va-tree-node-content", _ctx.indentClassComputed])
      }, [
        _ctx.$props.node.hasChildren ? (openBlock(), createElementBlock("div", _hoisted_233, [
          renderSlot(_ctx.$slots, "icon-toggle", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createVNode(_component_va_icon, {
              name: _ctx.isExpandedComputed ? "keyboard_arrow_down" : "keyboard_arrow_right",
              size: "20px"
            }, null, 8, ["name"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.selectable ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "va-tree-node-content__item",
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "checkbox", {}, () => [
            createVNode(_component_va_checkbox, {
              "model-value": _ctx.$props.node.checked,
              color: _ctx.colorComputed,
              indeterminate: "",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = (v2) => _ctx.toggleCheckbox(_ctx.$props.node, v2)),
              class: "va-tree-node__checkbox"
            }, null, 8, ["model-value", "color"])
          ])
        ])) : createCommentVNode("", true),
        _ctx.iconComputed ? (openBlock(), createElementBlock("div", _hoisted_318, [
          renderSlot(_ctx.$slots, "icon", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createVNode(_component_va_icon, {
              name: _ctx.iconComputed,
              size: "small"
            }, null, 8, ["name"])
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_412, [
          renderSlot(_ctx.$slots, "content", normalizeProps(guardReactiveProps(_ctx.$props.node)), () => [
            createTextVNode(toDisplayString(_ctx.labelComputed), 1)
          ])
        ])
      ], 2)
    ]),
    withDirectives(createBaseVNode("div", {
      role: "group",
      "aria-hidden": !_ctx.$props.node.expanded,
      class: normalizeClass(["va-tree-node-children", _ctx.expandedClassComputed])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.node.children, (childNode) => {
        return openBlock(), createBlock(_component_va_tree_node, {
          key: _ctx.getTrackBy(childNode),
          node: childNode
        }, createSlots({ _: 2 }, [
          renderList(_ctx.$slots, (_2, name) => {
            return {
              name,
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
              ])
            };
          })
        ]), 1032, ["node"]);
      }), 128))
    ], 10, _hoisted_59), [
      [vShow, _ctx.$props.node.hasChildren]
    ])
  ], 42, _hoisted_164);
}
var _VaTreeNode = _export_sfc(_sfc_main91, [["render", _sfc_render89]]);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/components/VaTreeNode/index.js
var VaTreeNode = withConfigTransport(_VaTreeNode);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/VaTreeView.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-tree-view/VaTreeView.css";
var __defProp96 = Object.defineProperty;
var __getOwnPropSymbols96 = Object.getOwnPropertySymbols;
var __hasOwnProp96 = Object.prototype.hasOwnProperty;
var __propIsEnum96 = Object.prototype.propertyIsEnumerable;
var __defNormalProp96 = (obj, key, value) => key in obj ? __defProp96(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues96 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp96.call(b2, prop))
      __defNormalProp96(a2, prop, b2[prop]);
  if (__getOwnPropSymbols96)
    for (var prop of __getOwnPropSymbols96(b2)) {
      if (__propIsEnum96.call(b2, prop))
        __defNormalProp96(a2, prop, b2[prop]);
    }
  return a2;
};
var _sfc_main92 = defineComponent({
  name: "VaTreeView",
  props: __spreadValues96({}, useTreeViewProps),
  emits: [...useTreeViewEmits],
  components: { VaTreeNode },
  setup: (props, { emit }) => {
    const { treeItems, getTrackBy } = useTreeView(props, emit);
    return { treeItems, getTrackBy };
  }
});
var _hoisted_165 = {
  class: "va-tree-view",
  role: "tree"
};
var _hoisted_234 = createTextVNode("No matching nodes found");
function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_tree_node = resolveComponent("va-tree-node");
  return openBlock(), createElementBlock("div", _hoisted_165, [
    _ctx.$props.filter && !_ctx.treeItems.length ? renderSlot(_ctx.$slots, "not-found", { key: 0 }, () => [
      _hoisted_234
    ]) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.treeItems, (nodeItem) => {
      return openBlock(), createBlock(_component_va_tree_node, {
        key: _ctx.getTrackBy(nodeItem),
        node: nodeItem
      }, createSlots({ _: 2 }, [
        renderList(_ctx.$slots, (_2, name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1032, ["node"]);
    }), 128))
  ]);
}
var _VaTreeView = _export_sfc(_sfc_main92, [["render", _sfc_render90]]);

// node_modules/vuestic-ui/dist/es/src/components/va-tree-view/index.js
var VaTreeView = withConfigTransport(_VaTreeView);

// node_modules/vuestic-ui/dist/es/src/components/va-scroll-container/VaScrollContainer.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-scroll-container/VaScrollContainer.css";
var __default__5 = defineComponent({
  name: "VaScrollContainer",
  props: {
    vertical: {
      type: Boolean,
      default: false
    },
    horizontal: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: "secondary"
    },
    size: {
      type: String,
      default: "thin"
    }
  },
  setup(props) {
    const { getColor } = useColors();
    return {
      overflowX: computed(() => props.horizontal ? "auto" : "hidden"),
      overflowY: computed(() => props.vertical ? "auto" : "hidden"),
      scrollColor: computed(() => getColor(props.color)),
      scrollbarWidth: computed(() => props.size === "default" ? "auto" : props.size)
    };
  }
});
var __injectCSSVars__5 = () => {
  useCssVars((_ctx) => ({
    "3df6be13": _ctx.scrollColor,
    "95f9955a": _ctx.overflowX,
    "95f99558": _ctx.overflowY,
    "f572b6ba": _ctx.scrollbarWidth
  }));
};
var __setup__5 = __default__5.setup;
__default__5.setup = __setup__5 ? (props, ctx) => {
  __injectCSSVars__5();
  return __setup__5(props, ctx);
} : __injectCSSVars__5;
var _sfc_main93 = __default__5;
var _hoisted_166 = { class: "va-scroll-container" };
var _hoisted_235 = { class: "va-scroll-container__content" };
function _sfc_render91(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_166, [
    createBaseVNode("div", _hoisted_235, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
var _VaScrollContainer = _export_sfc(_sfc_main93, [["render", _sfc_render91]]);

// node_modules/vuestic-ui/dist/es/src/components/va-scroll-container/index.js
var VaScrollContainer = withConfigTransport(_VaScrollContainer);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItem.css";
var __defProp97 = Object.defineProperty;
var __defProps86 = Object.defineProperties;
var __getOwnPropDescs86 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols97 = Object.getOwnPropertySymbols;
var __hasOwnProp97 = Object.prototype.hasOwnProperty;
var __propIsEnum97 = Object.prototype.propertyIsEnumerable;
var __defNormalProp97 = (obj, key, value) => key in obj ? __defProp97(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues97 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp97.call(b2, prop))
      __defNormalProp97(a2, prop, b2[prop]);
  if (__getOwnPropSymbols97)
    for (var prop of __getOwnPropSymbols97(b2)) {
      if (__propIsEnum97.call(b2, prop))
        __defNormalProp97(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps86 = (a2, b2) => __defProps86(a2, __getOwnPropDescs86(b2));
var _sfc_main94 = defineComponent({
  name: "VaSidebarItem",
  props: __spreadProps86(__spreadValues97(__spreadValues97({}, useRouterLinkProps), useComponentPresetProp), {
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    borderColor: { type: String, default: void 0 }
  }),
  setup(props) {
    const rootElement = useElementRef();
    const sidebar = useSidebarItem();
    const { isHovered } = useHover(rootElement);
    const { getColor, getHoverColor: getHoverColor2, getFocusColor: getFocusColor2 } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const backgroundColorComputed = computed(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        return getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      return "#ffffff00";
    });
    const textBackground = computed(() => applyColors(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
    const { textColorComputed } = useTextColor(textBackground);
    const computedStyle = computed(() => {
      const style = { color: textColorComputed.value };
      if (isHovered.value || props.active || hasKeyboardFocus.value) {
        style.backgroundColor = backgroundColorComputed.value;
      }
      if (props.active) {
        const mergedProps = __spreadValues97(__spreadValues97({}, sidebar), props);
        style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor2(getColor(props.hoverColor || props.activeColor));
      }
      return style;
    });
    const { tagComputed, hrefComputed } = useRouterLink(props);
    return {
      rootElement,
      computedStyle,
      keyboardFocusListeners,
      tagComputed,
      hrefComputed,
      isHovered,
      backgroundColorComputed,
      bg: getColor(sidebar == null ? void 0 : sidebar.color),
      textBackground
    };
  }
});
function _sfc_render92(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), mergeProps({
    ref: "rootElement",
    class: ["va-sidebar__item va-sidebar-item", { "va-sidebar-item--active": _ctx.$props.active }],
    tabindex: "0",
    style: _ctx.computedStyle,
    href: _ctx.hrefComputed,
    to: _ctx.$props.to
  }, toHandlers(_ctx.keyboardFocusListeners)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "style", "href", "to"]);
}
var _VaSidebarItem = _export_sfc(_sfc_main94, [["render", _sfc_render92]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemContent.css";
var _sfc_main95 = defineComponent({
  name: "VaSidebarItemContent"
});
var _hoisted_167 = { class: "va-sidebar__item__content va-sidebar-item-content" };
function _sfc_render93(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_167, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaSidebarItemContent = _export_sfc(_sfc_main95, [["render", _sfc_render93]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/VaSidebarItemTitle.css";
var _sfc_main96 = defineComponent({
  name: "VaSidebarItemTitle"
});
var _hoisted_168 = { class: "va-sidebar__title va-sidebar-item-title" };
function _sfc_render94(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_168, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var _VaSidebarItemTitle = _export_sfc(_sfc_main96, [["render", _sfc_render94]]);

// node_modules/vuestic-ui/dist/es/src/components/va-sidebar/VaSidebarItem/index.js
var VaSidebarItemContent = withConfigTransport(_VaSidebarItemContent);
var VaSidebarItemTitle = withConfigTransport(_VaSidebarItemTitle);
var VaSidebarItem = withConfigTransport(_VaSidebarItem);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/components/VaTab/VaTab.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-tabs/components/VaTab/VaTab.css";
var __defProp98 = Object.defineProperty;
var __defProps87 = Object.defineProperties;
var __getOwnPropDescs87 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols98 = Object.getOwnPropertySymbols;
var __hasOwnProp98 = Object.prototype.hasOwnProperty;
var __propIsEnum98 = Object.prototype.propertyIsEnumerable;
var __defNormalProp98 = (obj, key, value) => key in obj ? __defProp98(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues98 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp98.call(b2, prop))
      __defNormalProp98(a2, prop, b2[prop]);
  if (__getOwnPropSymbols98)
    for (var prop of __getOwnPropSymbols98(b2)) {
      if (__propIsEnum98.call(b2, prop))
        __defNormalProp98(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps87 = (a2, b2) => __defProps87(a2, __getOwnPropDescs87(b2));
var _sfc_main97 = defineComponent({
  name: "VaTab",
  components: { VaIcon: VaIcon2 },
  emits: ["click", "keydown-enter", "focus"],
  props: __spreadProps87(__spreadValues98(__spreadValues98({}, useRouterLinkProps), useComponentPresetProp), {
    selected: { type: Boolean, default: false },
    color: { type: String, default: "" },
    icon: { type: String, default: "" },
    label: { type: String, default: "" },
    disabled: { type: Boolean },
    name: { type: [String, Number] },
    tag: { type: String, default: "div" }
  }),
  setup: (props, { emit }) => {
    const tabElement = shallowRef();
    const isActive = ref(false);
    const hoverState = ref(false);
    const rightSidePosition = ref(0);
    const leftSidePosition = ref(0);
    const { keyboardFocusListeners, hasKeyboardFocus } = useKeyboardOnlyFocus();
    const { tagComputed, hrefComputed, isActiveRouterLink } = useRouterLink(props);
    const classComputed = computed(() => ({ "va-tab--disabled": props.disabled }));
    const {
      parentDisabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    } = inject(TabsViewKey, {
      parentDisabled: false,
      tabsList: [],
      selectTab: (tab) => tab,
      moveToTab: (tab) => tab,
      registerTab: (tab) => tab,
      unregisterTab: (tab) => tab
    });
    const tabIndexComputed = computed(() => props.disabled || parentDisabled ? -1 : 0);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      color: hoverState.value || isActive.value ? colorComputed.value : "inherit"
    }));
    const updateHoverState = (isHover) => {
      hoverState.value = isHover;
    };
    const updateSidePositions = () => {
      var _a, _b;
      const componentOffsetLeft = ((_a = tabElement.value) == null ? void 0 : _a.offsetLeft) || 0;
      const componentOffsetWidth = ((_b = tabElement.value) == null ? void 0 : _b.offsetWidth) || 0;
      rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
      leftSidePosition.value = componentOffsetLeft;
    };
    const onTabClick = () => {
      selectTab(tabComponent);
      emit("click");
    };
    const onTabKeydown = () => {
      selectTab(tabComponent);
      emit("keydown-enter");
    };
    const onFocus = () => {
      if (hasKeyboardFocus.value) {
        moveToTab(tabComponent);
      }
      emit("focus");
    };
    const tabComponent = {
      name: computed(() => props.name),
      id: null,
      tabElement,
      isActive,
      tabIndexComputed,
      isActiveRouterLink,
      rightSidePosition,
      leftSidePosition,
      onTabClick,
      onTabKeydown,
      onFocus,
      updateSidePositions
    };
    onMounted(() => {
      registerTab(tabComponent);
    });
    onBeforeUnmount(() => {
      unregisterTab(tabComponent);
    });
    return {
      tabElement,
      parentDisabled,
      isActive,
      hoverState,
      tagComputed,
      hrefComputed,
      isActiveRouterLink,
      colorComputed,
      classComputed,
      computedStyle,
      tabIndexComputed,
      rightSidePosition,
      leftSidePosition,
      updateHoverState,
      updateSidePositions,
      onTabClick,
      onTabKeydown,
      onFocus,
      keyboardFocusListeners
    };
  }
});
var _hoisted_169 = ["tabindex"];
var _hoisted_236 = ["textContent"];
function _sfc_render95(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.tagComputed), {
    ref: "tabElement",
    class: normalizeClass(["va-tab", _ctx.classComputed]),
    role: "tab",
    "aria-selected": _ctx.isActive,
    "aria-disabled": _ctx.$props.disabled || _ctx.parentDisabled,
    href: _ctx.hrefComputed,
    target: _ctx.target,
    to: _ctx.to,
    replace: _ctx.replace,
    exact: _ctx.exact,
    "active-class": _ctx.activeClass,
    "exact-active-class": _ctx.exactActiveClass,
    style: normalizeStyle(_ctx.computedStyle),
    onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.updateHoverState(true)),
    onMouseleave: _cache[4] || (_cache[4] = ($event) => _ctx.updateHoverState(false))
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({
        class: "va-tab__content",
        tabindex: _ctx.tabIndexComputed,
        onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onTabClick && _ctx.onTabClick(...args)),
        onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onTabKeydown && _ctx.onTabKeydown(...args), ["enter"]))
      }, toHandlers(_ctx.keyboardFocusListeners)), [
        renderSlot(_ctx.$slots, "default", {}, () => [
          _ctx.icon ? (openBlock(), createBlock(_component_va_icon, {
            key: 0,
            class: "va-tab__icon",
            size: "small",
            name: _ctx.icon
          }, null, 8, ["name"])) : createCommentVNode("", true),
          createBaseVNode("span", {
            class: "va-tab__label",
            textContent: toDisplayString(_ctx.label)
          }, null, 8, _hoisted_236)
        ])
      ], 16, _hoisted_169)
    ]),
    _: 3
  }, 40, ["aria-selected", "aria-disabled", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"]);
}
var _VaTab = _export_sfc(_sfc_main97, [["render", _sfc_render95]]);

// node_modules/vuestic-ui/dist/es/src/components/va-tabs/components/VaTab/index.js
var VaTab = withConfigTransport(_VaTab);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/VaTimelineItem.js
init_vue_runtime_esm_bundler();

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.js
init_vue_runtime_esm_bundler();
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineSeparator/VaTimelineSeparator.css";
var __defProp99 = Object.defineProperty;
var __defProps88 = Object.defineProperties;
var __getOwnPropDescs88 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols99 = Object.getOwnPropertySymbols;
var __hasOwnProp99 = Object.prototype.hasOwnProperty;
var __propIsEnum99 = Object.prototype.propertyIsEnumerable;
var __defNormalProp99 = (obj, key, value) => key in obj ? __defProp99(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues99 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp99.call(b2, prop))
      __defNormalProp99(a2, prop, b2[prop]);
  if (__getOwnPropSymbols99)
    for (var prop of __getOwnPropSymbols99(b2)) {
      if (__propIsEnum99.call(b2, prop))
        __defNormalProp99(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps88 = (a2, b2) => __defProps88(a2, __getOwnPropDescs88(b2));
var componentName = "va-timeline-separator";
var _sfc_main98 = defineComponent({
  name: componentName,
  props: __spreadProps88(__spreadValues99({}, useComponentPresetProp), {
    color: { type: String, default: "primary" },
    vertical: { type: Boolean },
    active: { type: Boolean },
    activePrevious: { type: Boolean },
    activeNext: { type: Boolean }
  }),
  setup(props) {
    const { getColor } = useColors();
    return () => h("div", {
      class: {
        [componentName]: true,
        [`${componentName}--vertical`]: props.vertical
      }
    }, [
      h("div", {
        class: {
          [`${componentName}__line`]: true,
          [`${componentName}__line--active`]: props.activePrevious
        },
        style: {
          backgroundColor: getColor(props.activePrevious ? props.color : "divider")
        }
      }),
      h("div", {
        class: {
          [`${componentName}__center`]: true,
          [`${componentName}__center--active`]: props.active
        },
        style: {
          backgroundColor: getColor(props.active ? props.color : "divider")
        }
      }),
      h("div", {
        class: {
          [`${componentName}__line`]: true,
          [`${componentName}__line--active`]: props.activeNext
        },
        style: {
          backgroundColor: getColor(props.activeNext ? props.color : "divider")
        }
      })
    ]);
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineSeparator/index.js
var VaTimelineSeparator = withConfigTransport(_sfc_main98);

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/VaTimelineItem.js
import "/Users/acapxasyraf/Desktop/handover code /fe/template-fe/node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/VaTimelineItem.css";
var __defProp100 = Object.defineProperty;
var __defProps89 = Object.defineProperties;
var __getOwnPropDescs89 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols100 = Object.getOwnPropertySymbols;
var __hasOwnProp100 = Object.prototype.hasOwnProperty;
var __propIsEnum100 = Object.prototype.propertyIsEnumerable;
var __defNormalProp100 = (obj, key, value) => key in obj ? __defProp100(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues100 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp100.call(b2, prop))
      __defNormalProp100(a2, prop, b2[prop]);
  if (__getOwnPropSymbols100)
    for (var prop of __getOwnPropSymbols100(b2)) {
      if (__propIsEnum100.call(b2, prop))
        __defNormalProp100(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps89 = (a2, b2) => __defProps89(a2, __getOwnPropDescs89(b2));
var COMPONENT_NAME2 = "va-timeline-item";
var VaTimelineSeparatorProps = extractComponentProps(VaTimelineSeparator);
var _sfc_main99 = defineComponent({
  name: COMPONENT_NAME2,
  props: __spreadProps89(__spreadValues100(__spreadValues100({}, useComponentPresetProp), VaTimelineSeparatorProps), {
    color: { type: String, default: "primary" },
    isFirst: { type: Boolean },
    isLast: { type: Boolean },
    inverted: { type: Boolean }
  }),
  setup(props, { slots }) {
    const children = [
      h(VaTimelineSeparator, __spreadValues100({}, filterComponentProps(props, VaTimelineSeparatorProps).value))
    ];
    const before = props.inverted ? slots.after : slots.before;
    if (before) {
      children.unshift(h("div", { class: `${COMPONENT_NAME2}__before` }, before()));
    }
    const after = props.inverted ? slots.before : slots.after;
    if (after) {
      children.push(h("div", { class: `${COMPONENT_NAME2}__after` }, after()));
    }
    return () => h("div", {
      class: [
        { [COMPONENT_NAME2]: true },
        { [`${COMPONENT_NAME2}--vertical`]: props.vertical },
        { [`${COMPONENT_NAME2}--is-first`]: props.isFirst },
        { [`${COMPONENT_NAME2}--is-last`]: props.isLast }
      ]
    }, children);
  }
});

// node_modules/vuestic-ui/dist/es/src/components/va-timeline/VaTimelineItem/index.js
var VaTimelineItem = withConfigTransport(_sfc_main99);

// node_modules/vuestic-ui/dist/es/src/vuestic-plugin/vuestic-components.js
var vuesticComponents = Object.freeze(Object.defineProperty({
  __proto__: null,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAvatar,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton: VaButton2,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaFileUpload,
  VaForm,
  VaHover,
  VaIcon: VaIcon2,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMessageList,
  VaModal,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaSelect,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSlider,
  VaSpacer,
  VaSplit,
  VaSwitch,
  VaTabs,
  VaTab,
  VaTimeInput,
  VaTimeline,
  VaTimelineItem,
  VaTimePicker,
  VaTreeNode,
  VaTreeView,
  VaScrollContainer,
  VaVirtualScroller
}, Symbol.toStringTag, { value: "Module" }));

// node_modules/vuestic-ui/dist/es/src/vuestic-plugin/create-vuestic/create-vuestic.js
var createVuestic = defineVuesticPlugin((options = {}) => ({
  install(app2) {
    const { config } = options;
    setCurrentApp(app2);
    Object.entries(vuesticComponents).forEach(([name, component]) => {
      app2.component(name, component);
    });
    usePlugin(app2, GlobalConfigPlugin(config));
    usePlugin(app2, CachePlugin);
    usePlugin(app2, BreakpointConfigPlugin);
    usePlugin(app2, ColorConfigPlugin);
    usePlugin(app2, VaDropdownPlugin);
    usePlugin(app2, VaToastPlugin);
    usePlugin(app2, VaModalPlugin);
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/es/src/vuestic-plugin/create-vuestic/create-vuestic-essential.js
var ESSENTIAL_PLUGIN_NAMES = ["GlobalConfigPlugin", "ColorConfigPlugin"];
var createVuesticEssential = defineVuesticPlugin((options = {}) => ({
  install(app2) {
    const { config, components, plugins } = options;
    setCurrentApp(app2);
    usePlugin(app2, (plugins == null ? void 0 : plugins.GlobalConfigPlugin) || GlobalConfigPlugin, config);
    usePlugin(app2, (plugins == null ? void 0 : plugins.CachePlugin) || CachePlugin);
    usePlugin(app2, (plugins == null ? void 0 : plugins.ColorConfigPlugin) || ColorConfigPlugin);
    if (plugins) {
      Object.entries(plugins).forEach(([name, plugin]) => {
        if (ESSENTIAL_PLUGIN_NAMES.includes(name)) {
          return;
        }
        usePlugin(app2, plugin);
      });
    }
    if (components) {
      Object.entries(components).forEach(([name, component]) => {
        app2.component(name, component);
      });
    }
    setCurrentApp(null);
  }
}));

// node_modules/vuestic-ui/dist/es/src/composables/useElementTextColor.js
var isRefString = (r2) => typeof r2.value === "string";
var useElementTextColor = (background) => {
  if (isRefString(background) || typeof background === "string") {
    const { textColorComputed: textColorComputed2 } = useTextColor(background);
    return textColorComputed2;
  }
  const { background: elBg } = useElementBackground(background);
  const { textColorComputed } = useTextColor(elBg);
  return textColorComputed;
};

// node_modules/vuestic-ui/dist/es/src/composables/useBreakpoint.js
init_vue_runtime_esm_bundler();
var useBreakpoint = () => {
  return inject(vaBreakpointSymbol, {});
};

// node_modules/vuestic-ui/dist/es/src/composables/useI18n.js
init_vue_runtime_esm_bundler();
var __defProp101 = Object.defineProperty;
var __getOwnPropSymbols101 = Object.getOwnPropertySymbols;
var __hasOwnProp101 = Object.prototype.hasOwnProperty;
var __propIsEnum101 = Object.prototype.propertyIsEnumerable;
var __defNormalProp101 = (obj, key, value) => key in obj ? __defProp101(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues101 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp101.call(b2, prop))
      __defNormalProp101(a2, prop, b2[prop]);
  if (__getOwnPropSymbols101)
    for (var prop of __getOwnPropSymbols101(b2)) {
      if (__propIsEnum101.call(b2, prop))
        __defNormalProp101(a2, prop, b2[prop]);
    }
  return a2;
};
var useI18nConfig = () => {
  const { globalConfig, mergeGlobalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  const mergeIntoConfig = (newConfig) => {
    mergeGlobalConfig({
      i18n: __spreadValues101(__spreadValues101({}, config.value), newConfig)
    });
  };
  return {
    config,
    mergeIntoConfig
  };
};

// node_modules/vuestic-ui/dist/es/src/components/va-modal/hooks/useModal.js
init_vue_runtime_esm_bundler();
var useModal = () => {
  var _a;
  const appContext = (_a = getCurrentInstance()) == null ? void 0 : _a.appContext;
  if (!appContext) {
    throw new Error("useModal can be used only in setup function. You can use app.config.globalProperties.$vaModal outside setup function");
  }
  const init = (options) => {
    return createModalInstance(options, appContext);
  };
  return { init };
};

// node_modules/vuestic-ui/dist/es/src/components/va-rating/components/VaRatingItem/index.js
var VaRatingItem = withConfigTransport(_VaRatingItem);

// node_modules/vuestic-ui/dist/es/src/components/va-toast/hooks/useToast.js
init_vue_runtime_esm_bundler();
var useToast = () => {
  var _a;
  const appContext = (_a = getCurrentInstance()) == null ? void 0 : _a.appContext;
  const createdInThisSetupContext = [];
  const init = (options) => {
    const id = createToastInstance(options, appContext);
    if (id) {
      createdInThisSetupContext.push(id);
    }
    return id;
  };
  const close = (id) => closeById(id);
  const closeAll = (allApps = false) => closeAllNotifications(allApps ? void 0 : appContext);
  const closeAllCreatedInThisHook = () => {
    createdInThisSetupContext.forEach((id) => closeById(id));
  };
  return {
    init,
    close,
    closeAll,
    closeAllCreatedInThisHook
  };
};
export {
  BreakpointConfigPlugin,
  CachePlugin,
  ColorConfigPlugin,
  GlobalConfigPlugin,
  TabsViewKey,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAvatar,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton2 as VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaDropdownPlugin,
  VaFileUpload,
  VaFileUploadGalleryItem,
  VaFileUploadKey,
  VaFileUploadList,
  VaFileUploadListItem,
  VaFileUploadSingleItem,
  VaFileUploadUndo,
  VaForm,
  VaHover,
  VaIcon2 as VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMessageList,
  VaMessageListWrapper,
  VaModal,
  VaModalPlugin,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaRatingItem,
  VaScrollContainer,
  VaSelect,
  VaSelectOption,
  VaSelectOptionList,
  VaSeparator,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSlider,
  VaSpacer,
  VaSplit,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaTimelineSeparator,
  VaToast,
  VaToastPlugin,
  VaTreeNode,
  VaTreeView,
  VaVirtualScroller,
  VuesticIconAliases,
  VuesticIconFonts,
  createIconsConfig,
  createVuestic,
  createVuesticEssential,
  useBreakpoint,
  useColors,
  useElementTextColor,
  useGlobalConfig,
  useI18nConfig,
  useIcons,
  useModal,
  useToast
};
//# sourceMappingURL=vuestic-ui.js.map
