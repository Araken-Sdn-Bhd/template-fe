var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, shallowRef, computed, ref, watch, resolveComponent, openBlock, createElementBlock, withKeys, withModifiers, Fragment, renderList, toDisplayString, createCommentVNode, createBlock, withCtx, mergeProps, renderSlot, normalizeProps } from "vue";
import { p as pick_1 } from "../../../../../vendor.js";
import { a as useColorProps } from "../../../../composables/useColors.js";
import { u as useComponentPresetProp } from "../../../../composables/useComponentPreset.js";

import { e as extractHTMLElement } from "../../../../composables/useHTMLElement.js";

import { u as useObjectRefs } from "../../../../composables/useObjectRefs.js";
import { c as checkSlotChildrenDeep } from "../../../../services/utils.js";
import { s as scrollToElement } from "../../../../utils/scroll-to-element.js";
import { V as VaVirtualScroller } from "../../../va-virtual-scroller/index.js";
import { V as VaSelectOption } from "../VaSelectOption/index.js";
import { _ as _export_sfc } from "../../../../../plugin-vue_export-helper.js";
var VaSelectOptionList_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaSelectOptionList",
  components: { VaVirtualScroller, VaSelectOption },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  props: __spreadProps(__spreadValues(__spreadValues({}, useColorProps), useComponentPresetProp), {
    options: { type: Array, default: () => [] },
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    getGroupBy: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: Number, default: 0 },
    hoveredOption: { type: [String, Number, Object], default: null },
    virtualScroller: { type: Boolean, default: true }
  }),
  setup(props, { emit, slots }) {
    const root = shallowRef();
    const focus = () => {
      var _a;
      (_a = root.value) == null ? void 0 : _a.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a, _b;
      return (_b = (_a = root.value) == null ? void 0 : _a.clientHeight) != null ? _b : 200;
    });
    const handleScrollToBottom = () => emit("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => props.hoveredOption || null);
    const updateCurrentOption = (option, source) => {
      emit("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const filteredOptions = computed(() => {
      if (!props.search) {
        return props.options;
      }
      return props.options.filter((option) => {
        const optionText = props.getText(option).toString().toUpperCase();
        const search = props.search.toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => filteredOptions.value.reduce((groups, option) => {
      if (typeof option !== "object" || !props.getGroupBy(option)) {
        groups._noGroup.push(option);
      } else {
        const groupBy = props.getGroupBy(option);
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value) {
        return;
      }
      updateCurrentOption(option || null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option || null, "keyboard");
    };
    const selectOption = (option) => emit("select-option", option);
    const currentOptionIndex = computed(() => filteredOptions.value.findIndex((option) => {
      return !!currentOptionComputed.value && props.getTrackBy(option) === props.getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => pick_1(props, ["getSelectedState", "getText", "getTrackBy", "color"]));
    const isSlotContentPassed = computed(() => checkSlotChildrenDeep(slots.default));
    const focusPreviousOption = () => {
      if (!currentOptionComputed.value) {
        filteredOptions.value.length && updateFocusedOption(filteredOptions.value.at(-1));
        return;
      }
      if (filteredOptions.value[currentOptionIndex.value - 1]) {
        updateFocusedOption(filteredOptions.value[currentOptionIndex.value - 1]);
      } else {
        emit("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!currentOptionComputed.value) {
        filteredOptions.value.length && updateFocusedOption(filteredOptions.value[0]);
        return;
      }
      if (filteredOptions.value[currentOptionIndex.value + 1]) {
        updateFocusedOption(filteredOptions.value[currentOptionIndex.value + 1]);
      }
    };
    const focusFirstOption = () => {
      var _a;
      return updateFocusedOption((_a = filteredOptions.value) == null ? void 0 : _a[0]);
    };
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a;
      if (!option) {
        return;
      }
      const element = itemRefs.value[props.getTrackBy(option)];
      if (element) {
        scrollToElement(extractHTMLElement(element));
      }
      if (props.virtualScroller) {
        (_a = virtualScrollerRef.value) == null ? void 0 : _a[0].virtualScrollTo(currentOptionIndex.value);
      }
    };
    const publicMethods = {
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    };
    watch(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && newOption && scrollToOption(newOption);
    });
    return __spreadValues({
      root,
      virtualScrollerRef,
      rootHeight,
      optionGroups,
      filteredOptions,
      selectOptionProps,
      isSlotContentPassed,
      currentOptionComputed,
      onScroll,
      setItemRef,
      selectOption,
      updateHoveredOption,
      handleScrollToBottom
    }, publicMethods);
  }
});
const _hoisted_1 = ["tabindex"];
const _hoisted_2 = {
  key: 0,
  class: "va-select-option-list__group-name"
};
const _hoisted_3 = {
  key: 0,
  class: "va-select-option-list--empty"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_select_option = resolveComponent("va-select-option");
  const _component_va_virtual_scroller = resolveComponent("va-virtual-scroller");
  return openBlock(), createElementBlock("div", {
    ref: "root",
    class: "va-select-option-list",
    tabindex: _ctx.tabindex,
    onKeydown: [
      _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["up"])),
      _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.focusPreviousOption && _ctx.focusPreviousOption(...args), ["stop", "prevent"]), ["left"])),
      _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["down"])),
      _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.focusNextOption && _ctx.focusNextOption(...args), ["stop", "prevent"]), ["right"]))
    ],
    onScrollPassive: _cache[4] || (_cache[4] = (...args) => _ctx.onScroll && _ctx.onScroll(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.optionGroups, (options, groupName) => {
      return openBlock(), createElementBlock(Fragment, { key: groupName }, [
        groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(groupName), 1)) : createCommentVNode("", true),
        _ctx.$props.virtualScroller ? (openBlock(), createBlock(_component_va_virtual_scroller, {
          key: 1,
          ref_for: true,
          ref: "virtualScrollerRef",
          items: options,
          "track-by": _ctx.$props.getTrackBy,
          "wrapper-size": _ctx.rootHeight,
          "onScroll:bottom": _ctx.handleScrollToBottom
        }, {
          default: withCtx(({ item: option, index }) => [
            !_ctx.isSlotContentPassed ? (openBlock(), createBlock(_component_va_select_option, mergeProps({
              key: 0,
              option,
              "current-option": _ctx.currentOptionComputed
            }, _ctx.selectOptionProps, {
              onClick: ($event) => _ctx.selectOption(option),
              onMousemove: ($event) => _ctx.updateHoveredOption(option)
            }), null, 16, ["option", "current-option", "onClick", "onMousemove"])) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, { option, index, selectOption: _ctx.selectOption })))
          ]),
          _: 2
        }, 1032, ["items", "track-by", "wrapper-size", "onScroll:bottom"])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(options, (option, index) => {
          return openBlock(), createElementBlock(Fragment, {
            key: _ctx.$props.getTrackBy(option)
          }, [
            !_ctx.isSlotContentPassed ? (openBlock(), createBlock(_component_va_select_option, mergeProps({
              key: 0,
              ref_for: true,
              ref: _ctx.setItemRef(_ctx.$props.getTrackBy(option)),
              "current-option": _ctx.currentOptionComputed,
              option
            }, _ctx.selectOptionProps, {
              onClick: ($event) => _ctx.selectOption(option),
              onMousemove: ($event) => _ctx.updateHoveredOption(option)
            }), null, 16, ["current-option", "option", "onClick", "onMousemove"])) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, { option, index, selectOption: _ctx.selectOption })))
          ], 64);
        }), 128))
      ], 64);
    }), 128)),
    !_ctx.filteredOptions.length ? (openBlock(), createElementBlock("div", _hoisted_3, toDisplayString(_ctx.noOptionsText), 1)) : createCommentVNode("", true)
  ], 40, _hoisted_1);
}
var _VaSelectOptionList = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaSelectOptionList as _ };

import './VaSelectOptionList.css';
//# sourceMappingURL=VaSelectOptionList.js.map
