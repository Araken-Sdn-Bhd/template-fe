var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { computed } from "vue";
import { u as useGlobalConfigSafe } from "../services/global-config/global-config.mjs";
import { a as getBoxShadowColor, f as getBoxShadowColorFromBg, c as getHoverColor, b as getFocusColor, g as getGradientBackground, s as shiftHSLAColor, h as setHSLAColor, d as colorToRgba, i as getStateMaskGradientBackground, j as isColor, k as isCSSVariable, l as getColorLightness } from "../services/color-config/color-functions.mjs";
import { w as warn } from "../services/utils.mjs";
import { n as normalizeColorName, c as cssVariableName } from "../services/color-config/utils.mjs";
import { u as useCache } from "../services/cache/useCache.mjs";
import { u as useReactiveComputed } from "./useReactiveComputed.mjs";
const useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
const useColors = () => {
  const gc = useGlobalConfigSafe();
  if (!gc) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { setGlobalConfig, globalConfig } = gc;
  const colors = useReactiveComputed({
    get: () => globalConfig.value.colors.variables,
    set: (v) => {
      setColors(v);
    }
  });
  const setColors = (colors2) => {
    globalConfig.value.colors.variables = __spreadValues(__spreadValues({}, globalConfig.value.colors.variables), colors2);
  };
  const getColors = () => {
    return colors;
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = getColors().primary;
    }
    const colors2 = getColors();
    if (!prop) {
      prop = getColor(defaultColor);
    }
    const normalizedColor = normalizeColorName(prop);
    if (colors2[normalizedColor]) {
      return preferVariables ? `var(${cssVariableName(prop)})` : colors2[normalizedColor];
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    return getColor(defaultColor);
  };
  const getComputedColor = (color) => {
    return computed(() => getColor(color));
  };
  const colorsToCSSVariable = (colors2, prefix = "va") => {
    return Object.keys(colors2).filter((key) => colors2[key] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix}-${colorName}`] = getColor(colors2[colorName], void 0, true);
      return acc;
    }, {});
  };
  const cache = useCache();
  const getColorLightnessFromCache = (color) => {
    if (typeof color !== "string") {
      return getColorLightness(color);
    }
    if (!cache.colorContrast[color]) {
      cache.colorContrast[color] = getColorLightness(color);
    }
    return cache.colorContrast[color];
  };
  const computedDarkColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > globalConfig.value.colors.threshold ? "textInverted" : "textPrimary";
  });
  const computedLightColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > globalConfig.value.colors.threshold ? "textPrimary" : "textInverted";
  });
  const getTextColor = (color, darkColor, lightColor) => {
    darkColor = darkColor || computedDarkColor.value;
    lightColor = lightColor || computedLightColor.value;
    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;
  };
  const currentPresetName = computed(() => globalConfig.value.colors.currentPresetName);
  const presets = computed(() => globalConfig.value.colors.presets);
  const applyPreset = (presetName) => {
    globalConfig.value.colors.currentPresetName = presetName;
    if (!globalConfig.value.colors.presets[presetName]) {
      return warn(`Preset ${presetName} does not exist`);
    }
    globalConfig.value.colors.variables = __spreadValues({}, globalConfig.value.colors.presets[presetName]);
  };
  return {
    colors,
    currentPresetName,
    presets,
    applyPreset,
    setColors,
    getColors,
    getColor,
    getComputedColor,
    getBoxShadowColor,
    getBoxShadowColorFromBg,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable,
    colorToRgba,
    getStateMaskGradientBackground
  };
};
export { useColorProps as a, useColors as u };
//# sourceMappingURL=useColors.mjs.map
